[
  {
    "objectID": "regression.html",
    "href": "regression.html",
    "title": "回归分析",
    "section": "",
    "text": "作者认为，一个国家的生活水平取决于该国与其他国家的国际贸易、该国的国内贸易以及其他因素。从一个简单的计量模型出发： \\[\n\\ln Y_{i} = \\alpha + \\beta T_{i} + \\gamma W_{i} + \\epsilon_{i}\n\\]\n其中，被解释变量是人均收入 \\(Y_{i}\\) 的对数；解释变量 \\(T_{i}\\) 表示国际贸易，\\(W_{i}\\) 表示国内贸易，\\(\\epsilon_{i}\\) 为误差项，表示其他对收入影响的因素。\n预期国际贸易和\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.rcParams['font.family']='SimHei'\nplt.rcParams['axes.unicode_minus'] = False\nimport statsmodels.api as sm",
    "crumbs": [
      "回归分析",
      "线性回归"
    ]
  },
  {
    "objectID": "regression.html#建立计量模型",
    "href": "regression.html#建立计量模型",
    "title": "回归分析",
    "section": "",
    "text": "作者认为，一个国家的生活水平取决于该国与其他国家的国际贸易、该国的国内贸易以及其他因素。从一个简单的计量模型出发： \\[\n\\ln Y_{i} = \\alpha + \\beta T_{i} + \\gamma W_{i} + \\epsilon_{i}\n\\]\n其中，被解释变量是人均收入 \\(Y_{i}\\) 的对数；解释变量 \\(T_{i}\\) 表示国际贸易，\\(W_{i}\\) 表示国内贸易，\\(\\epsilon_{i}\\) 为误差项，表示其他对收入影响的因素。\n预期国际贸易和\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.rcParams['font.family']='SimHei'\nplt.rcParams['axes.unicode_minus'] = False\nimport statsmodels.api as sm",
    "crumbs": [
      "回归分析",
      "线性回归"
    ]
  },
  {
    "objectID": "regression.html#ols-估计量",
    "href": "regression.html#ols-估计量",
    "title": "回归分析",
    "section": "OLS 估计量",
    "text": "OLS 估计量\n\n# Generate random data\nnp.random.seed(0)\nx = np.random.rand(20)\ny = 2 * x + np.random.randn(20)\n\n# Fit a line using OLS\ncoefficients = np.polyfit(x, y, 1)\npoly = np.poly1d(coefficients)\nx_fit = np.linspace(0, 1, 100)\ny_fit = poly(x_fit)\n\n# Calculate residuals\nresiduals = y - poly(x)\n# Plot scatter plot and fitted line\nplt.scatter(x, y, label='Data')\nplt.plot(x_fit, y_fit, color='red', label='Fitted Line')\nplt.scatter(x[4], y[4], color='red', label='Selected Residual')\nplt.plot([x[4], x[4]], [y[4], poly(x[4])], color='red', linestyle='--')\n\n# Add annotation of the residual\nplt.annotate(f'$e_i $ ', \n             xy=(x[4], -1), \n             xytext=(x[4]+0.1, y[4]+0.5),\n             arrowprops=dict(facecolor='black', arrowstyle='-&gt;'))\n\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n\n\n\n\n\n\n\n\n\nOkun’s law\n\nimport pandas_datareader.data as web\nstart_date = '1947-01-01'\nend_date = '2019-12-31'\n\ndata = web.DataReader(['UNRATE','GDPC1'], 'fred', start_date, end_date)\ndf = data.resample('Q').mean()\ndf['gdp_growth_rate'] = np.log(df['GDPC1']/df['GDPC1'].shift(1))*100\ndf['unemp_changed'] = df['UNRATE'].diff()\ndf.dropna(inplace=True)\nfig,ax=plt.subplots(figsize=(10,6))\nsns.regplot(df, y='gdp_growth_rate',x='unemp_changed',ax=ax,marker='+')\nax.set_xlabel('Quarterly change in unemployment rate')\nax.set_ylabel('Quarterly change in Real GDP')\nax.grid()\nmodel = sm.OLS(df['gdp_growth_rate'], sm.add_constant(df['unemp_changed'])).fit()\nprint(model.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:        gdp_growth_rate   R-squared:                       0.466\nModel:                            OLS   Adj. R-squared:                  0.464\nMethod:                 Least Squares   F-statistic:                     248.4\nDate:                Sat, 16 Aug 2025   Prob (F-statistic):           1.11e-40\nTime:                        18:31:37   Log-Likelihood:                -295.55\nNo. Observations:                 287   AIC:                             595.1\nDf Residuals:                     285   BIC:                             602.4\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n=================================================================================\n                    coef    std err          t      P&gt;|t|      [0.025      0.975]\n---------------------------------------------------------------------------------\nconst             0.7788      0.040     19.403      0.000       0.700       0.858\nunemp_changed    -1.6609      0.105    -15.762      0.000      -1.868      -1.453\n==============================================================================\nOmnibus:                       11.629   Durbin-Watson:                   1.912\nProb(Omnibus):                  0.003   Jarque-Bera (JB):               13.361\nSkew:                           0.383   Prob(JB):                      0.00125\nKurtosis:                       3.729   Cond. No.                         2.63\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\nC:\\Users\\admin\\AppData\\Local\\Temp\\ipykernel_4592\\1037386578.py:6: FutureWarning: 'Q' is deprecated and will be removed in a future version, please use 'QE' instead.\n  df = data.resample('Q').mean()\n\n\n\n\n\n\n\n\n\n\n\n无偏性\n\nnp.random.seed(12345)\ntrue_intercept = 2.0\ntrue_slope = 3.0\nsample_size = 100\nnum_simulations = 10000\n\nestimated_slopes = np.zeros(num_simulations)\nfor i in range(num_simulations):\n    x = np.random.randn(sample_size)\n    y = true_intercept + true_slope * x + np.random.randn(sample_size)\n    X = sm.add_constant(x)\n    model = sm.OLS(y, X).fit()\n    estimated_slopes[i] = model.params[1]\naverage_slope = np.mean(estimated_slopes)\n\nprint(f\"斜率真实值: {true_slope}\")\nprint(f\"斜率估计值的平均值: {average_slope}\")\n\nfig, ax = plt.subplots(figsize=(10,6))\nax.hist(estimated_slopes, bins=50, color='steelblue', alpha=0.7)\nax.axvline(x=3.0, color='red', linestyle='--') \nax.set_xlabel('斜率估计值')\nax.set_ylabel('频率')\nax.set_title('斜率估计值的直方图')\nplt.show()\n\n斜率真实值: 3.0\n斜率估计值的平均值: 2.9993457145927493\n\n\n\n\n\n\n\n\n\n\n\n置信区间\n\n### ci\nlower, upper = (1.0941-1.96*0.029, 1.0941+1.96*0.029)\nnp.round((lower, upper),3)\n\narray([1.037, 1.151])\n\n\n\n\n联合显著性检验\n\n\n解释回归结果\n\n\n函数形式变化\n\n\n回归诊断分析\n\n\n应用：Mankiw, Romer, Weil (1992)\n这一部分以@mankiw1992contribution 为例，阐释最小二乘法的应用。\n\nimport pandas as pd\nimport numpy as np\n\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nimport matplotlib.pyplot as plt\n\n# Load data\ndata = pd.read_csv(\"datasets/mrw.csv\")\n\n# Generate variables\ndata['lnY85'] = np.log(data['rgdpw85'])\ndata['lnY60'] = np.log(data['rgdpw60'])\ndata['lns'] = np.log(data['i_y'] / 100)\ndata['lnngd'] = np.log(data['popgrowth'] / 100 + 0.05)\ndata['lnschool'] = np.log(data['school'] / 100)\ndata['growth'] = data['lnY85'] - data['lnY60']\ndata['growth_annu'] = 100 * data['growth'] / 25\ndata['lns_lnngd'] = data['lns'] - data['lnngd']\ndata['lnschool_lnngd'] = data['lnschool'] - data['lnngd']\n\n# Table I\nsamples = {'n': data['n'] == 1, 'i': data['i'] == 1, 'o': data['o'] == 1}\nresults_table1 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns + lnngd', data=data[condition]).fit()\n    results_table1[sample] = model.summary()\n\n# Estimate alpha\nmodel_i = smf.ols('lnY85 ~ lns + lnngd', data=data[data['i'] == 1]).fit()\nalpha = model_i.params['lns'] / (1 + model_i.params['lns'])\n\n# Restricted regression\nresults_restricted = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns_lnngd', data=data[condition]).fit()\n    results_restricted[sample] = model.summary()\n\n# Table II\ncorrelation = data.loc[data['i'] == 1, ['school', 'i_y', 'popgrowth']].corr()\nresults_table2 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns + lnngd + lnschool', data=data[condition]).fit()\n    results_table2[sample] = model.summary()\n\n# Test coefficients\ntest_model = smf.ols('lnY85 ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ntest1 = test_model.t_test('lns + lnngd + lnschool = 0')\ntest2 = test_model.t_test('lns = lnschool')\n\n# Implicit alpha\nalpha_lns = test_model.params['lns'] / (1 + test_model.params['lns'] + test_model.params['lnschool'])\nalpha_lnschool = test_model.params['lnschool'] / (1 + test_model.params['lns'] + test_model.params['lnschool'])\n\n# Restricted regression with school\nresults_restricted_school = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns_lnngd + lnschool_lnngd', data=data[condition]).fit()\n    results_restricted_school[sample] = model.summary()\n\n# Table III\nresults_table3 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60', data=data[condition]).fit()\n    results_table3[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Table IV\nresults_table4 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60 + lns + lnngd', data=data[condition]).fit()\n    results_table4[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Table V\nresults_table5 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60 + lns + lnngd + lnschool', data=data[condition]).fit()\n    results_table5[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Figure I\nplt.figure(figsize=(15, 5))\n\n# Unconditional scatter plot\nplt.subplot(1, 3, 1)\nplt.scatter(data.loc[data['i'] == 1, 'lnY60'], data.loc[data['i'] == 1, 'growth_annu'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Unconditional\")\n\n# Partial out lns and lnngd\nresidual_model1 = smf.ols('lnY60 ~ lns + lnngd', data=data[data['i'] == 1]).fit()\ndata['lnY60_residual1'] = residual_model1.resid + residual_model1.params['Intercept']\nresidual_model2 = smf.ols('growth_annu ~ lns + lnngd', data=data[data['i'] == 1]).fit()\ndata['growth_annu_residual1'] = residual_model2.resid\nplt.subplot(1, 3, 2)\nplt.scatter(data['lnY60_residual1'], data['growth_annu_residual1'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Conditional on lns and lnngd\")\n\n# Partial out lns, lnngd, and lnschool\nresidual_model3 = smf.ols('lnY60 ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ndata['lnY60_residual2'] = residual_model3.resid + residual_model3.params['Intercept']\nresidual_model4 = smf.ols('growth_annu ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ndata['growth_annu_residual2'] = residual_model4.resid\nplt.subplot(1, 3, 3)\nplt.scatter(data['lnY60_residual2'], data['growth_annu_residual2'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Conditional on lns, lnngd, and lnschool\")\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "回归分析",
      "线性回归"
    ]
  },
  {
    "objectID": "regression.html#iv-估计",
    "href": "regression.html#iv-估计",
    "title": "回归分析",
    "section": "IV 估计",
    "text": "IV 估计\n\n应用：开放与增长\n这一部分中，用 Frankel and Romer (1999) 的经典论文，阐释OLS和IV估计的方法，包括：\n\n如何从理论观点中确定一个统计模型；\n如何理解回归分析的逻辑；\n如何为统计模型中的变量准备数据；\n如何估计统计模型；\n如何解释模型估计的结果；\n如何根据模型估计值进行统计推断；\n如何解释模型整体拟合度。",
    "crumbs": [
      "回归分析",
      "线性回归"
    ]
  },
  {
    "objectID": "python_basics.html",
    "href": "python_basics.html",
    "title": "Python 语言基础",
    "section": "",
    "text": "这一部分简要介绍Python语言的基本内容，包括变量的类型、条件语句、循环、自定义函数和类等内容。",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#变量与数据类型",
    "href": "python_basics.html#变量与数据类型",
    "title": "Python 语言基础",
    "section": "变量与数据类型",
    "text": "变量与数据类型\n变量是用来存储数据的“容器”，可以赋不同类型的值。Python常见数据类型有：整数(int)、浮点数(float)、字符串(str)、布尔(bool)等。\n\n变量赋值\n变量赋值把一个具体的值存储到一个变量中，方便后续使用和操作。要注意变量命名的规则：\n\n变量名只能包含字母、数字和下划线，且不能以数字开头\n区分大小写（如：age 和 Age 是不同变量）\n不可使用Python关键字作为变量名（如：if, for, class 等）\n建议使用有意义的英文单词，遵循小写加下划线的风格。\n\n例如\n\nschool = \"Nanjing Normal University\"\nprice = 12.5\nquantity = 20\ntotal_sales = price * quantity\ntotal_sales\n\n250.0\n\n\n如果命名方式不符合要求，软件将返回错误。将下面例子中表示注释的#去掉，再试运行命令，看提示的错误类型是什么？\n\n#1student = \"Bob\"      \n# class = \"Math\"       \n# student-name = \"Tom\" \n# t&2 = 30             \n\n上面的class，属于软件内部保留的33个关键词之一，注意在命名时应避免与关键词冲突：\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\nPython基本数据类型\n下面是几种常用的基本数据类型，可以通过type()函数查看一个对象的类型。\n整数（int）：用于表示整数类型的数据。\n\na = 5\nprint(type(a))  \n#\nb = 10\nc = b/a\nprint(c)\n\n&lt;class 'int'&gt;\n2.0\n\n\n注意两个整数的比值为浮点数。\n整数int是类（class）的一种。在Python中，所有的数据类型，包括数字、字符串、列表等，都是通过类来定义的。如果我们输入变量的名字和一个点，a.，Python会出现提示可能的属性（attributes）或方法（methods）。\n\n\n\n\n\n\nFigure 1: 整数的属性和方法\n\n\n\n例如，.is_integer()判断数值是否为整数，.as_integer_ratio()返回一对整数，其比率与原始整数完全相等，且具有正数分母:\n\na.is_integer()\na.as_integer_ratio()\n\n(5, 1)\n\n\n浮点数（float）：用于表示带小数点的数值\n\npi = 3.14159\nradius = 1.75\narea = pi * radius **2\nprint(type(pi))    \nprint(area)\n\n&lt;class 'float'&gt;\n9.621119375\n\n\n字符串（str）：用于表示文本数据\n可以用双引号或者 单引号定义字符串。当字符串较长时，可以用三引号进行定义。例如：\n\nsentence = \"Python's syntax is easy to learn.\"\nmultiline = \"\"\"这个句子\n被我\n分成了几行。这样\n看起来，像诗一样。\n\"\"\"\n\n字符串有许多属性和方法，在进行文本分析时会经常用到。如 Table 1 所示：\n\n\n\nTable 1: 常见的字符串方法\n\n\n\n\n\n\n\n\n\n\n方法\n功能说明\n示例\n\n\n\n\ns.lower()\n转换为小写\n\"Hello\".lower() → \"hello\"\n\n\ns.upper()\n转换为大写\n\"hello\".upper() → \"HELLO\"\n\n\ns.capitalize()\n首字母大写，其余小写\n\"hello world\".capitalize() → \"Hello world\"\n\n\ns.title()\n每个单词首字母大写\n\"hello world\".title() → \"Hello World\"\n\n\ns.strip()\n去除字符串首尾空白字符\n\"  hello  \".strip() → \"hello\"\n\n\ns.lstrip()\n去除左侧空白\n\"  hello\".lstrip() → \"hello\"\n\n\ns.rstrip()\n去除右侧空白\n\"hello  \".rstrip() → \"hello\"\n\n\ns.replace(old, new)\n替换子串\n\"banana\".replace(\"a\", \"o\") → \"bonono\"\n\n\ns.find(sub)\n查找子串位置，找不到返回 -1\n\"hello\".find(\"l\") → 2\n\n\ns.count(sub)\n统计子串出现次数\n\"banana\".count(\"a\") → 3\n\n\ns.startswith(prefix)\n是否以指定前缀开头\n\"hello\".startswith(\"he\") → True\n\n\ns.endswith(suffix)\n是否以指定后缀结尾\n\"hello\".endswith(\"lo\") → True\n\n\ns.split(sep)\n按分隔符拆分字符串\n\"a,b,c\".split(\",\") → [\"a\", \"b\", \"c\"]\n\n\nsep.join(iterable)\n使用分隔符连接字符串序列\n\",\".join([\"a\", \"b\", \"c\"]) → \"a,b,c\"\n\n\n\n\n\n\n注意，当对字符串使用某一方法时，虽然结果显示了变化，并没有改变原本对字符串。如果要保存结果可以赋值。\n\n# 例：将日期字符串按“-”分割成年、月、日\ndate_str = \"2024-06-01\"\nparts = date_str.split(\"-\")\nyear, month, day = parts\nprint(f\"年份：{year}，月份：{month}，日期：{day}\")\n\n# 例：用join方法将列表中的单词拼接成一句话\nwords = [\"Python\", \"is\", \"fun\"]\nsentence = \"$#$_\".join(words)\nprint(sentence) \n\n年份：2024，月份：06，日期：01\nPython$#$_is$#$_fun\n\n\n布林类型（bool）：只有True和False两个值，常用于条件判断\n\nname = \"Jane\"\nage = 20\nscore = 57\nis_adult = age &gt;= 18\nhas_passed = score &gt;= 60\n\nprint(type(is_adult))  # &lt;class 'bool'&gt;\nprint(f\"是否成年：{is_adult}\")\nprint(f\"是否及格：{has_passed}\")\n\n&lt;class 'bool'&gt;\n是否成年：True\n是否及格：False",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#print与-f-string",
    "href": "python_basics.html#print与-f-string",
    "title": "Python 语言基础",
    "section": "print与 f-string",
    "text": "print与 f-string\n经常需要将运算结果或字符串显示出来，主要的函数是上面已经出现多次的print()函数，它可以输出字符串、变量、表达式等，并支持格式化输出。\n\nprint(multiline)\n\n这个句子\n被我\n分成了几行。这样\n看起来，像诗一样。\n\n\n\n\n带引号的字符\n在Python语言中，字符可以使用单引号或者双引号表示，在输出带引号的字符串时，可以利用该特点。例如\n\nprint('She said, \"Hello!\"')      # 外单内双\nprint(\"It's a nice day.\")        # 外双内单\n\nShe said, \"Hello!\"\nIt's a nice day.\n\n\n如果字符串本身包含同样的引号，可以用转义符”\\“避免冲突\n\nprint('It\\'s a nice day.') \nprint(\"She said, \\\"Hello!\\\"\")\n\nIt's a nice day.\nShe said, \"Hello!\"\n\n\n三引号可以包含单双引号和多行内容\n\nprint(\"\"\"他说：\"It's OK!\" \"\"\")\n\n他说：\"It's OK!\" \n\n\n\n\n格式化输出\n格式化输出常用的有`.format()方法和f-string方法。\nformat方法\n.format()方法的基本用法如下：\n\nprint('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n\nWe are the knights who say \"Ni!\"\n\n\n也可以使用关键字参数：\n\nprint('This {food} is {adjective}.'.format(\n      food='spam', adjective='absolutely horrible'))\n\nThis spam is absolutely horrible.\n\n\nf-string\nf-string（格式化字符串字面量）是 Python 3.6 及以上版本提供的一种字符串格式化方式，它让我们可以在字符串中直接嵌入变量或表达式。\n\nimport math\nprint(f'The value of pi is approximately {math.pi:.3f}.')\n\nThe value of pi is approximately 3.142.\n\n\n其中，.3f表示小数点3位；\n输出结果时也可以进行数学运算：\n\nyear = 2024\nGDP_per_capita = 95749\ngrowth = 0.051\n\nmy_string = f\"{year}年，人均国内生产总值为{GDP_per_capita/10000:.3f}万元，比去年增长{growth:.3%}\"\nprint(my_string)\n\n2024年，人均国内生产总值为9.575万元，比去年增长5.100%\n\n\n注意 %将浮点数转换位百分数显示。",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#运算符与表达式",
    "href": "python_basics.html#运算符与表达式",
    "title": "Python 语言基础",
    "section": "运算符与表达式",
    "text": "运算符与表达式\n运算符用于对数据进行各种操作，主要包括：\n\n算术运算符：+（加），-（减），*（乘），/（除），//（整除），%（取余），**（幂）\n比较运算符：==（等于），!=（不等于），&gt;（大于），&lt;（小于），&gt;=（大于等于），&lt;=（小于等于）\n逻辑运算符：and（与），or（或），not（非）\n赋值运算符：=（赋值），+=，-=，*=，/= 等\n成员运算符：in，not in（判断元素是否属于序列）\n身份运算符：is，is not（判断两个对象是否为同一对象）\n\n下面分别介绍常用的运算符及其用法。\n\n算术运算符\n加减乘除等算术运算符与通常的表示方法类似，例如，将华氏度转换位摄氏度的公式为：\n例如，华氏温度和摄氏温度的转换公式：\n\\[\n{}^{\\circ}C = \\frac{5}{9}({}^{\\circ}F - 32)\n\\]\n\nF = 92\nC = 5/9 * (F - 32)\nprint(f\"F = {F}, C = {C:.2f}\")\n\nF = 92, C = 33.33\n\n\n值得注意的是//（整除），%（取余），**（幂）：\n\na = 15\nb = 4\nprint(a/b)\nprint(\"a // b =\", a // b)  \nprint(\"a % b =\", a % b)    \nprint(\"a ** b =\", a ** b)  \n\n3.75\na // b = 3\na % b = 3\na ** b = 50625\n\n\n\n\n比较运算符\n比较运算符用于比较两个值，结果为布尔类型（True或 False ）。\n\nprint(\"a &gt; b:\", a &gt; b)\nprint(\"a == b:\", a == b)   \nprint(\"a != b:\", a != b)   \n\na &gt; b: True\na == b: False\na != b: True\n\n\n\n\n逻辑运算符\n逻辑运算符用于连接多个条件表达式，常用于复合条件判断。\n\nx = 8\ny = 3\n#\nprint((x &gt; 5) and (y &lt; 5))  \nprint((x &lt; 5) or (y &lt; 5))   \nprint(not (x &gt; y))          \n\nTrue\nTrue\nFalse\n\n\n要注意and 和or组合的结果。\n\nprint(True and False)\nprint(True or False)\n\nFalse\nTrue\n\n\n\n\n赋值运算符\n赋值运算符用于给变量赋值或在原有基础上进行运算后赋值:\n\nx = 10      \nx += 5   \nx -= 3   \nx *= 2   \nx /= 4   \nx //= 2  \nx %= 2   \nx **= 3  \n#\nprint(x)\n\n1.0\n\n\n\n\n成员运算符\n成员运算符用于判断某个元素是否属于某个序列，如列表、元组、字符串等。例如：\n\nprint('is' in 'this')\n\nfor i in range(5):\n  print(i)\n\nTrue\n0\n1\n2\n3\n4",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#控制结构条件与循环",
    "href": "python_basics.html#控制结构条件与循环",
    "title": "Python 语言基础",
    "section": "控制结构：条件与循环",
    "text": "控制结构：条件与循环\n\n条件语句\n条件语句（if语句）用于根据条件判断执行不同的代码块，基本结构：\n\n# if 条件:\n#     代码块1\n# elif 其他条件:\n#     代码块2\n# else:\n#     代码块3\n\n例如，使用if-esle判断是奇数还是偶数。注意缩进：\n\nnum = 8\nif num%2 == 0:\n    print(f\"{num} is even.\")\nelse:\n    print(f\"{num} is odd.\")\n\n8 is even.\n\n\n以世界银行经济体收入分组标准为例：\n世界银行按照人均国民收入把世界各经济体分成四组，如 Table 2 所示，中、低收入国家被称为发展中国家，高收入国家被称为发达国家。\n\n\n\nTable 2: 世界银行经济体收入分组标准\n\n\n\n\n\n经济体分组\n划分标准（人均国民总收入）\n\n\n\n\n低收入经济体\n1145 美元以下\n\n\n中等偏下收入经济体\n1146—4515 美元\n\n\n中等偏上收入经济体\n4516—14005 美元\n\n\n高收入经济体\n14005 美元以上\n\n\n\n\n\n\n可以使用嵌套条件语句if-elif-else来进行判别：\n\ngni = 13660\n\nif gni &lt;= 1135:\n    economy = \"低收入经济体\"\nelif gni &lt;= 4465:\n    economy =  \"中等偏下收入经济体\"\nelif gni &lt;= 13845:\n    economy = \"中等偏上收入经济体\"\nelse:\n    economy = \"高收入经济体\"\n\nprint(f\"人均国民总收入为 {gni} 美元，属于：{economy}\")\n\n人均国民总收入为 13660 美元，属于：中等偏上收入经济体\n\n\n再来看一个计算BMI（Body Mass Index）指数的例子： \\[\nBMI = \\frac{weight(kg)}{height(m)^{2}}\n\\]\n\nheight = 1.75 \nweight = 75 \n\n# 计算BMI\nbmi = weight / (height ** 2)\n\nif bmi &lt; 18.5:\n    status = \"偏瘦\"\nelif bmi &lt; 24:\n    status = \"正常\"\nelif bmi &lt; 28:\n    status = \"超重\"\nelse:\n    status = \"肥胖\"\nprint(f\"BMI = {bmi:.2f}，{status}\")\n\nBMI = 24.49，超重\n\n\n\n\n循环\nPython 中主要有两种循环结构：for 循环和 while 循环。 for 循环用于遍历序列（如列表、字符串、元组等）或可迭代对象中的元素，而 while 循环则在给定条件为真时重复执行一段代码。\n例如，对列表中的元素循环：\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n    print(fruit)\n\napple\nbanana\ncherry\n\n\n下面的例子计算从1到100之和，注意range()函数的用法：\n\ntotal = 0\nfor i in range(1, 101):\n    total += i\nprint(\"1到100的和为：\", total)\n\n1到100的和为： 5050\n\n\nwhile循环是一种基于条件判断的循环结构，当条件为True时，循环体会反复执行，直到条件变为False为止。另外， while循环要注意循环变量的更新，否则可能会造成死循环。\n例如，同样计算1到100的和\n\ntotal = 0\nn = 1\nwhile n &lt;= 100:\n    total += n\n    n += 1\nprint(\"1到100的和为：\", total)\n\n1到100的和为： 5050",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#容器类型列表字典元组集合",
    "href": "python_basics.html#容器类型列表字典元组集合",
    "title": "Python 语言基础",
    "section": "容器类型：列表、字典、元组、集合",
    "text": "容器类型：列表、字典、元组、集合\n列表（list）、字典（dict）、元组（tuple）、集合（set）是Python中常用的容器类型。\n\n字典：用{}定义，键值对结构\n元组：用()定义，有序不可变\n集合：用set()或{}定义，无序不重复\n\n\n列表\n列表是最常用的数据类型之一，新建列表用[]进行定义。可以用索引（从0开始）访问列表的元素。\n\nnumbers = [10, 20, 30, 40]\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nprint(numbers[0])\nprint(fruits[-1])\n\n10\ncherry\n\n\n可以根据索引使用:对列表进行切片（slicing）。\n\nprint(numbers[1:3])     \nprint(numbers[::-1])\n\n[20, 30]\n[40, 30, 20, 10]\n\n\n列表是可变的（mutatable），元素可以更改。例如，将numbers的第2个元素（索引1）的值替换为25：\n\nnumbers[1] = 25\nprint(numbers)         \n\n[10, 25, 30, 40]\n\n\n可以使用.append()、.insert()方法往列表添加元素:\n\nfruits.append(\"orange\")  \nfruits.insert(1, \"pear\") \nprint(fruits)                 \n\n['apple', 'pear', 'banana', 'cherry', 'orange']\n\n\ndel .remove()和.pop()都可以用来删除元素：\n\ndel numbers[2]                 # 按索引删除\nfruits.remove(\"banana\")        # 按值删除\nprint(numbers)                 \nprint(fruits)                  \nfruit = fruits.pop()\nprint(fruit)\n\n[10, 25, 40]\n['apple', 'pear', 'cherry', 'orange']\norange\n\n\n经常涉及遍历列表的操作，尤其是for循环：\n\nfor fruit in fruits:\n    print(fruit)\n\napple\npear\ncherry\n\n\n例：计算净现值\n如果某项资产在多个时间周期内支付一系列收益流，那么我们可以使用贴现率来计算这整个收益序列对消费者的当前价值。 用 \\(y_t\\) 表示第 \\(t\\) 期的收益，并假设这些收益现在是已知的，贴现率 \\(r\\ge 0\\)。用一个求和表达式来表示整条收益序列的净现值总价值：\n\\[\nP_{0} = \\sum_{t=0}^{T} (\\frac{1}{1+r})^{t}y_{t}\n\\]\n将假设的收益序列保存为列表： y = [-100, 30, 60, 50, 40]，贴现率假设为0.05。我们用遍历列表的方法求和：\n\ny = [-100, 30, 60, 50, 40]\nr = 0.05\nP0 = 0\nfor t in range(len(y)):\n    P0 = P0 + y[t] / (1 + r) ** t\nprint(f\"The Total Present Value = ：{P0:.2f}\")\n\nThe Total Present Value = ：59.09\n\n\n\n\n元组\n元组（tuple）是有序、不可变的元素集合，用()表示。\n\npoint = (3, 4)\ncolors = (\"red\", \"green\", \"blue\")\n\n# 访问元素\nprint(point[0])                # 3\nprint(colors[-1])              # blue\n\n# 元组不可修改\n# point[1] = 5  # 会报错\n\n# 单元素元组要加逗号\nsingle = (5,)\nprint(type(single))            # &lt;class 'tuple'&gt;\n\n3\nblue\n&lt;class 'tuple'&gt;\n\n\n元组可以用于多变量赋值，许多函数返回的结果是元组的形式。\n\nx, y = point\nprint(x, y) \n\n3 4\n\n\n例：Jarque-Bera 正态性检验\n给定 \\(n\\)个观测值的样本，样本偏度为： \\[\nS = \\frac{\\hat{\\mu}_{3}}{\\hat{\\sigma}^{3}} = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{3}}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2})^{3/2}}\n\\]\n样本峰度为： \\[\nK = \\frac{\\hat{\\mu}_{4}}{\\hat{\\sigma}^{4}} = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{4}}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2})^{2}}\n\\]\nJarque-Bera正态性检验的核心思想是，如果一个数据集服从正态分布，那么它的偏度和峰度应该分别接近于0和3。统计量定义为： \\[\nJarque-Bera = \\frac{n}{6}\\left(S^{2} + \\frac{1}{4}(K - 3)^{2}\\right)\n\\]\n我们用Scipy库的stats.jarque_bera()函数为例:\n\nimport scipy.stats as sc\nimport numpy as np\nnp.random.seed(123)\nx = np.random.normal(loc=0, scale=1, size=100)\n\ns, p = sc.jarque_bera(x=x)\nprint(f\"Jarque-Berat Statistics = {s:.3f}, p-value = {p:.3f}\")\n\nJarque-Berat Statistics = 1.734, p-value = 0.420\n\n\n\n\n字典\n字典（dict）是一种用于存储键值对的数据结构。每个元素由“键”（key）和“值”（value）组成，键必须唯一且不可变，值可以是任意类型。 字典用大括号{}表示，键和值之间用冒号:分隔，多个键值对之间用逗号，分隔。\n例如，下面是江苏省2023年的一些社会经济指标：\n\njiangsu = {\"population\": 8526,\n           \"employment\": 4840,\n           \"GDP\": 128222.16}\nprint(jiangsu)\nprint(jiangsu[\"population\"])   \n\n{'population': 8526, 'employment': 4840, 'GDP': 128222.16}\n8526\n\n\n可以很方便地往字典中添加或修改元素\n\njiangsu['capital city'] = \"Nan jing\"\nprint(jiangsu)\n\n{'population': 8526, 'employment': 4840, 'GDP': 128222.16, 'capital city': 'Nan jing'}\n\n\n可以使用for循环 遍历字典，\n\nfor key, value in jiangsu.items():\n    print(key, value)\n\npopulation 8526\nemployment 4840\nGDP 128222.16\ncapital city Nan jing\n\n\n应用：利用字典进行词频统计\n统计一段文本中每个单词出现的次数，例如统计下面英文歌词代词出现的次数。首先将字母转化为小写字母，然后利用字符的切分方法.split()，将结果保存在字典freq之中，然后按词频排序，注意使用了lambda函数的方法。\n\ntext = \"\"\"Generals gathered in their masses\nJust like witches at black masses\nEvil minds that plot destruction\nSorcerer of death's construction\nIn the fields, the bodies burning\nAs the war machine keeps turning\nDeath and hatred to mankind\nPoisoning their brainwashed minds\nOh, Lord, yeah\nPoliticians hide themselves away\nThey only started the war\nWhy should they go out to fight?\nThey leave that role to the poor, yeah\nTime will tell on their power minds\nMaking war just for fun\nTreating people just like pawns in chess\nWait 'til their judgement day comes, yeah\nNow in darkness, world stops turning\nAshes where their bodies burning\nNo more war pigs have the power\nHand of God has struck the hour\nDay of judgement, God is calling\nOn their knees, the war pigs crawling\nBegging mercy for their sins\nSatan laughing, spreads his wings\nOh, Lord, yeah\n\"\"\"\n\nwords = text.lower().split()\nfreq = {}\n\nfor word in words:\n    if word in freq:         # 判断单词是否已在字典中\n        freq[word] += 1\n    else:\n        freq[word] = 1\n\nsorted_freq = sorted(freq.items(), \n                      key=lambda item: item[1], \n                      reverse=True)\n\nfor word, count in sorted_freq[:10]:\n    print(f\"{word}: {count}\")\n\nthe: 8\ntheir: 7\nwar: 5\nin: 4\nyeah: 4\njust: 3\nminds: 3\nof: 3\nto: 3\nthey: 3",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#函数与模块",
    "href": "python_basics.html#函数与模块",
    "title": "Python 语言基础",
    "section": "函数与模块",
    "text": "函数与模块\n\n内置函数的调用\nPython内置函数是系统自带的、可以直接使用的函数，无需导入模块。常见内置函数有：abs(), len(),max(), min(), sum(), type(), int(), float(), str(), list(), dict(), range() 等。\n\nprint(abs(-10))\nlst = [1, 2, 3, 4]\nprint(len(lst))\nprint(max(5, 8, 2))\nprint(min([7, 3, 9]))\n\nprint(sum([1, 2, 3]))    \n\n10\n4\n8\n3\n6\n\n\n\n\n自定义函数\n自定义函数使用def关键字，指定函数名、参数列表和函数体。下面是几个简单的自定义函数的例子。\n例如，定义一个不包含参数的函数print_hello()，其唯一作用是显示Hello World!：\n\ndef print_hello():\n    print(\"Hello World!\")\n\nprint_hello()\n\nHello World!\n\n\n函数通常带有参数，下面的例子定义了一个计算圆的面积的例子，需要输入参数半径radius的值：\n\nimport math\ndef area(radius):\n    res = math.pi * radius ** 2\n    print(f\"半径为 {radius} 的圆的面积为 {res:.2f}!\")\narea(radius=2)\n\n半径为 2 的圆的面积为 12.57!\n\n\n这个函数运行的结果是在屏幕上显示一行字。如果将运行结果赋值给变量，结果如何？\n\nres = area(radius=2)\nprint(res)\n\n半径为 2 的圆的面积为 12.57!\nNone\n\n\n看到结果显示的是None。原因在于函数定义时并没有返回结果，这就需要return结果：\n\nimport math\ndef area(radius):\n    return math.pi * radius ** 2\n\nradius = 2\nres = area(radius)\nprint(f\"半径为 {radius} 的圆的面积为 {res:.2f}!\")\n\n半径为 2 的圆的面积为 12.57!\n\n\n再例如，给定列表中都是数值，计算其平均数：\n\ndef mean(numbers):\n    total = sum(numbers)\n    N = len(numbers)\n    avg = total / N\n\n    return avg\nnums = [3, 8, 1, 6]\nprint(mean(nums))\n\n4.5\n\n\n定义的函数经常会带有默认参数值，在调用函数时可以省略输入参数。例如下面的Cobb-Douglas生产函数的例子。\n例：定义Cobb-Douglas函数\nCobb-Douglas生产函数是经济学中最常见的函数设定，例如一个规模报酬不变的CD函数表示为： \\[\nY = AK^{\\alpha}L^{1-\\alpha}\n\\]\n其中，\\(\\alpha\\) 表示资本的产出弹性，\\(A\\) 表示全要素生产率。下面定义一个CD函数，默认参数值 \\(\\alpha = 1/3, A = 1\\)。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef cobb_douglas(K, L, alpha = 1/3, A = 1):\n    output = A * K**alpha * L**(1 - alpha)\n    return output\ncobb_douglas(K=1, L=0.5)\n\n0.6299605249474366\n\n\n从微观经济学内容我们知道，等产量曲线是带来相同产出的要素组合 \\((K, L)\\) 形成的曲线，可以应用matplotlib中的contour函数绘制上面函数定义的等产量曲线：\n\n# 生成K和L的网格\nK = np.linspace(0.1, 2, 100)\nL = np.linspace(0.1, 2, 100)\nK_grid, L_grid = np.meshgrid(K, L)\n\nY = cobb_douglas(K_grid, L_grid, alpha=1/2)\n# \nfig, ax = plt.subplots(figsize=(8, 6), dpi=300)\ncontours = ax.contour(K_grid, L_grid, Y, levels=8, cmap='viridis')\nax.clabel(contours, inline=True, fontsize=8)\nax.set_xlabel('K')\nax.set_ylabel('L')\nax.set_title('Cobb-Douglas isoquant')\nax.grid(True, linestyle='--', alpha=0.5)\nplt.show()\n\n\n\n\n\n\n\n\n函数也可以有多个返回值（返回元组）\n\ndef min_max(numbers):\n    return min(numbers), max(numbers)\n\nnums = [3, 8, 1, 6]\nmin, max = min_max(nums)\n\n可变参数：*args 接收任意数量的位置参数，类型为元组\n\ndef total(*args):\n    return sum(args)\n\nprint(total(1, 2, 3))\nprint(total(5, 10))  \n\n6\n15\n\n\n关键字参数：**kwargs 接收任意数量的关键字参数，类型为字典\n\ndef show_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nshow_info(name=\"Alice\", age=20)\n\nname: Alice\nage: 20\n\n\n\n\n自定义函数的例子\nBMI指数函数\n同样，也可以将上面计算BMI指数的过程，定义为一个函数：\n\ndef bmi(height, weight):\n    \"\"\"计算BMI指数并返回数值和健康状况\"\"\"\n    bmi = weight / (height ** 2)\n    if bmi &lt; 18.5:\n        status = \"偏瘦\"\n    elif bmi &lt; 24:\n        status = \"正常\"\n    elif bmi &lt; 28:\n        status = \"超重\"\n    else:\n        status = \"肥胖\"\n    return bmi, status\n\n# 示例调用\nbmi, status = bmi(1.75, 75)\nprint(f\"BMI = ：{bmi:.2f}，{status}\")\n\nBMI = ：24.49，超重\n\n\n世界银行经济体分组\n自定义函数常与其他功能结合使用，例如Pandas库的df.apply()方法。\n将前面例子中的if语句代码，赋值粘贴至某一个AI大模型平台，输入提示：“将下面的Python代码定义为一个函数”。得到类似下面的函数：\n\ndef classify_economy(gni):\n    if gni &lt;= 1135:\n        economy = \"低收入经济体\"\n    elif gni &lt;= 4465:\n        economy = \"中等偏下收入经济体\"\n    elif gni &lt;= 13845:\n        economy = \"中等偏上收入经济体\"\n    else:\n        economy = \"高收入经济体\"\n    return economy\ne = classify_economy(13500)\nprint(e)\n\n中等偏上收入经济体\n\n\n然后我们将该函数应用至世界银行数据。\n我们需要从World Bank数据库下载2024年GDP per capita (current US$)数据，.dropna()函数用于删除缺失值，然后对列[‘NY.GDP.PACP.CD’]应用自定义的classify_economy()函数：\n\nimport pandas as pd\nimport wbgapi as wb\ngdp_pc_2024 = wb.data.DataFrame(\"NY.GDP.PCAP.CD\", time = 2024)\ngdp_pc_2024 = gdp_pc_2024.dropna()\ngdp_pc_2024['NY.GDP.PCAP.CD'].apply(classify_economy)\n\neconomy\nAFE    中等偏下收入经济体\nAFW    中等偏下收入经济体\nAGO    中等偏下收入经济体\nALB    中等偏上收入经济体\nAND       高收入经济体\n         ...    \nXKX    中等偏上收入经济体\nYEM       低收入经济体\nZAF    中等偏上收入经济体\nZMB    中等偏下收入经济体\nZWE    中等偏下收入经济体\nName: NY.GDP.PCAP.CD, Length: 232, dtype: object\n\n\n\n\n模块的导入与使用\nPython的模块（module）是包含一组功能的代码文件，可以通过import语句导入并使用其中的函数、变量等。分为三类： - python自带模块，不需要安装，直接import载入就可以了，如math包； - 第三方模块，通常需要下载安装，然后载入，如numpy，scipy等； - 自定义模块，自己写的实现某些功能的py文件的集合。\n上面的例子中，实际上已经出现多次模块载入的应用，如Pandas、Numpy、Matplotlib等。\n\nimport math\nprint(math.sqrt(16))     \nprint(math.pi)           \n#\nfrom random import randint\nprint(randint(1, 10))    \n\n#\nimport datetime as dt\nnow = dt.datetime.now()\nprint(now)\n\n4.0\n3.141592653589793\n5\n2025-08-16 18:30:19.434528\n\n\n可以把自定义的函数等保存在.py格式等脚本文件中，自定义模块。例如，在文件夹pyfiles中my_module.py文件保存了一个计算BMI的函数，我们载入该函数然后进行计算：\n\nfrom pyfiles.my_module import bmi_index\n# \nbmi, status = bmi_index(1.75, 75)\nprint(f\"BMI = {bmi:.2f}\")\nprint(f\"健康状况：{status}\")\n\nBMI = 24.49\n健康状况：超重",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#面向对象的编程",
    "href": "python_basics.html#面向对象的编程",
    "title": "Python 语言基础",
    "section": "面向对象的编程",
    "text": "面向对象的编程\nPython 是面向对象编程的语言。面向对象编程（Object Oriented Programming，OOP）是一种程序设计思想。它把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，相同属性和操作方法的对象被抽象为类。类（Class）就类似上面所说的模具，而对象（Object）就是使用模具生产出的零件，对象就是类的实例（Instance）。\n\n对象\n类（class）是面向对象编程（OOP）的核心概念，用于描述具有相同属性和方法的一类对象的模板或蓝图。 对象（object）是类的实例，拥有类定义的属性和方法。\n所有的数据类型，值，变量，函数，类，实例等等一切可操作的基本单元在 Python 都使用对象（Object）表示。每个对象有三个基本属性：ID，类型和值，也即有一块内存中存储了一个对象，这块内存中一定存有这三个属性。\n\na = 1\nprint(id(a), type(a), a)\nprint(id(bmi_index), type(bmi_index), bmi_index)\n\n140724214383528 &lt;class 'int'&gt; 1\n1799177547872 &lt;class 'function'&gt; &lt;function bmi_index at 0x000001A2E756B060&gt;\n\n\n0x0000024FE78C6AC0 是这个函数在计算机内存中的地址。\n\n\n定义一个简单的类\n下面定义一个简单的类Student，它具有两个属性name、age，和一个方法introduce()：\n\nclass Student，定义了一个类，名为Student；\ndef __init__(self, name, age)，__init__ 是一个特殊的方法，被称为构造方法。当创建一个类的实例（也就是一个对象）时，它会自动被调用，主要作用是初始化对象的属性；\nself 是一个约定俗成的参数，它代表了正在被创建的那个对象本身。Python 通过 self 来知道操作的是哪个具体的对象。\nname 和 age 是在创建对象时需要传入的参数，它们将被用来设置对象的初始属性。\nself.name = name 和 self.age = age，将传入的 name 和 age 参数的值赋给了对象的属性，这里分别存储学生的名字和年龄；\ndef introduce(self)，定义introduce方法，它定义了 Student 对象可以执行的一个行为这里是打印一段包含学生姓名和年龄的自我介绍。\nstu1 = Student(name=\"Alice\", age=20)，创建了一个具体的对象，或者说实例，并将其赋值给变量 stu1。此时调用了 Student 类的构造方法 __init__，将 \"Alice\" 赋给 name，20 赋给 age。\nstu1.introduce()，调用了 stu1 对象的 introduce 方法。\n\n\n\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def introduce(self):\n        print(f\"Hello，My name is {self.name}，I'm {self.age} years old.\")\n \nstu1 = Student(name=\"Alice\", age=20)\nstu2 = Student(name=\"Bob\", age=22)\n \nstu1.introduce()\nstu2.introduce()\n\nHello，My name is Alice，I'm 20 years old.\nHello，My name is Bob，I'm 22 years old.\n\n\n\n\n例：定义一个局部均衡分析模型\n微观经济学中，简单的局部均衡市场模型表示为: \\[\n\\begin{cases}\nQ_{D} = a - b\\times P \\\\\nQ_{S} = c + d\\times P \\\\\nQ_{D} = Q_{S}\n\\end{cases}\n\\]\n我们定义一个类Market，将参数定义为属性，将需求、供给和均衡条件定义为三个方法：\n\ndemand计算给定价格的需求量；\nsupply计算给定价格的供给量\nequilibrium计算均衡价格和均衡数量;\n\n\nclass Market:\n    def __init__(self, a, b, c, d):\n        \"\"\"        \n        Qd = a - b*P\n        Qs = c + d*P\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    def demand(self, P):        \n        return self.a - self.b * P\n\n    def supply(self, P):        \n        return self.c + self.d * P\n\n    def equilibrium(self):\n        \"\"\"\n        Qd = Qs\n        \"\"\"\n        # a - b*P = c + d*P\n        # (a - c) = (b + d)*P        \n        P_eq = (self.a - self.c) / (self.b + self.d)\n        Q_eq = self.demand(P_eq)\n        return P_eq, Q_eq\n\n# \nmarket = Market(a=100, b=2, c=20, d=3)\nP_star, Q_star = market.equilibrium()\nprint(f\"Equilibrium Price = {P_star:.2f}\")\nprint(f\"Equilibrium Quantity = {Q_star:.2f}\")\n\nEquilibrium Price = 16.00\nEquilibrium Quantity = 68.00\n\n\n可以利用定义的market类中的方法绘制需求曲线和供给曲线：\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 生成价格区间\nP = np.linspace(0, 50, 200)\nQd = [market.demand(p) for p in P]\nQs = [market.supply(p) for p in P]\n\n# 绘图\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(Qd, P, label=\"Demand Qd\", color=\"blue\")\nax.plot(Qs, P, label=\"Supply Qs\", color=\"orange\")\nax.scatter(Q_star, P_star, color=\"red\", zorder=5)\nax.annotate(f\"Equilibrium\\n(Q={Q_star:.1f}, P={P_star:.1f})\",\n             xy=(Q_star, P_star), xytext=(Q_star+10, P_star+5),\n             arrowprops=dict(arrowstyle=\"-&gt;\", color=\"red\"))\nax.set_xlabel(\"Q\")\nax.set_ylabel(\"P\")\nax.legend()\nax.grid(True, linestyle=\"--\", alpha=0.5)\nplt.show()",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "numpy.html",
    "href": "numpy.html",
    "title": "Numpy 基础",
    "section": "",
    "text": "本部分简要介绍Numpy的基础用法，并用几个例子说明随机数生成器的作用。",
    "crumbs": [
      "Python基础",
      "Numpy 基础"
    ]
  },
  {
    "objectID": "numpy.html#数组",
    "href": "numpy.html#数组",
    "title": "Numpy 基础",
    "section": "数组",
    "text": "数组\n\n创建数组\n有许多种方法创建数组，下面是一些简单的例子，使用np.array()函数，将列表、元组转化为数组：\n\nimport numpy as np\n\na = np.array([1, 2, 3, 4])\nprint(a)\n\n[1 2 3 4]\n\n\n注意，与列表不同，Numpy数组只能包含相同类型的数据，下面的例子中，np.array()函数自动将列表中的整数转换为浮点数：\n\nb = np.array([3.14, 4, 2, 3])\nb\n\narray([3.14, 4.  , 2.  , 3.  ])\n\n\n列表总是一维的，Numpy数组可以是多维的，例如下面的例子使用：\n\ndata = np.array([[1.5, -0.1, 3],\n                [0, -3, 6.5]])\ndata\n\narray([[ 1.5, -0.1,  3. ],\n       [ 0. , -3. ,  6.5]])\n\n\n数组data是二维数组，可以查看属性ndim和shape：\n\ndata.ndim\ndata.shape\n\n(2, 3)\n\n\n可以对data进行通常的数学运算：\n\nprint(data * 10)\nprint(data + data)\n\n[[ 15.  -1.  30.]\n [  0. -30.  65.]]\n[[ 3.  -0.2  6. ]\n [ 0.  -6.  13. ]]\n\n\nNumpy也有函数来生成一些特定格式的数组,如表 Table 1 所示：\n\n\n\nTable 1: Numpy中生成数组的函数\n\n\n\n\n\n\n\n\n\n函数名\n描述\n\n\n\n\narray\n将输入数据（列表、元组、数组或其他序列类型）转换为 ndarray，可以自动推断或显式指定数据类型；默认会复制输入数据\n\n\nasarray\n将输入转换为 ndarray，如果输入已经是 ndarray，则不会进行复制\n\n\narange\n类似于内置的 range，但返回的是 ndarray 而不是列表\n\n\nones, ones_like\n生成给定形状和数据类型的全 1 数组；ones_like 以另一个数组为模板，生成相同形状和数据类型的全 1 数组\n\n\nzeros, zeros_like\n类似于 ones 和 ones_like，但生成的是全 0 数组\n\n\nempty, empty_like\n通过分配新内存创建新数组，但不会像 ones 和 zeros 那样填充值\n\n\nfull, full_like\n生成给定形状和数据类型的数组，所有值都设置为指定的“填充值”；full_like 以另一个数组为模板，生成相同形状和数据类型的填充值数组\n\n\neye,identity\n生成单位矩阵（对角线为 1，其余为 0）\n\n\n\n\n\n\n下面是一些例子：\n\nzeros = np.zeros(10)\nprint(zeros)\nones = np.ones((2,3), dtype=float)\nprint(ones)\n# 生成零矩阵\nidents = np.identity(3)\nprint(idents)\n\nevens = np.arange(0, 20, 2)\nprint(evens)\ngrids = np.linspace(0, 1, 21)\nprint(grids)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[1. 1. 1.]\n [1. 1. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[ 0  2  4  6  8 10 12 14 16 18]\n[0.   0.05 0.1  0.15 0.2  0.25 0.3  0.35 0.4  0.45 0.5  0.55 0.6  0.65\n 0.7  0.75 0.8  0.85 0.9  0.95 1.  ]\n\n\nNumpy中random子库包含丰富的生成随机数的函数，用来生成数组进行模拟运算。如 np.random.normal()可以生成正态分布随机数、np.random.randint()用来生成随机整数：\n\n#生成正态分布\nnums_norm = np.random.normal(loc=0, scale=1, size=(4, 3))\nprint(nums_norm)\nnums_int = np.random.randint(low=1, high=11, size=(2, 10))\nprint(nums_int)\n\n[[ 0.55566037  0.50309805  1.10401547]\n [ 2.37296246 -1.30508066 -0.33671401]\n [ 0.47472266 -0.08108065  0.02869927]\n [ 1.39099264  1.82176333  1.48874973]]\n[[ 7  5  8  5 10  7  2  2  9  6]\n [ 8 10  8  7  9  4  2  1  2  7]]\n\n\n\n\n数组运算效率\n数组采用的是向量化操作，运算速度比列表要快许多。让我们通过一个简单的例子来直观感受两者的速度差异：对一百万个元素的集合求平方运算，一种使用列表推导式，一种采用数组。\n\nimport numpy as np\nimport time\n#\nlist_data = list(range(1000000))\narray_data = np.arange(1000000)\n\n# 使用列表推导式进行运算\nstart_time = time.time()\nlist_result = [x ** 2 for x in list_data]\nend_time = time.time()\nprint(f\"Time: {end_time - start_time} s\")\n\n# 使用NumPy的向量化运算\nstart_time = time.time()\narray_result = array_data ** 2\nend_time = time.time()\nprint(f\"Time: {end_time - start_time} s\")\n\nTime: 0.05379652976989746 s\nTime: 0.0019237995147705078 s\n\n\n可见列表方式运算耗费的时间是数组运算的几十倍。\n\n\n数组的索引\n注意索引与列表一样，从0开始，在选择元素时不包括右侧。\n\nz = np.array((1,2,3,4,5))\nz[0]\nz[0:2]\nz[-1]\nz[::2]\nz[::-1]\n\narray([5, 4, 3, 2, 1])\n\n\n2维数组用类似行和列的方式进行切片：\n\nz = np.array([[1,2],\n              [3, 4]])\nz[0, 0]\nz[0, :]\nz[:, 1]\n\narray([2, 4])",
    "crumbs": [
      "Python基础",
      "Numpy 基础"
    ]
  },
  {
    "objectID": "numpy.html#数组方法",
    "href": "numpy.html#数组方法",
    "title": "Numpy 基础",
    "section": "数组方法",
    "text": "数组方法\n数组方法众多，\n\n聚合与统计方法\n这些方法用于对数组中的数据进行汇总计算，返回一个单一的值或一个较小的数组。例如：\n\narr.sum(): 计算数组所有元素的总和，默认是所有值之和；\narr.mean(): 计算数组元素的平均值。\narr.min(), arr.max(): 找出数组中的最小值和最大值。\narr.std(), arr.var(): 计算数组的标准差和方差。\narr.argmin(), arr.argmax(): 返回数组中最小值或最大值所在的索引。\n\n要注意在2D数组时，参数axis = 0按列求和（默认），或 arr.sum(axis=1)按行求和。\n\nimport numpy as np\nnp.random.seed(123)\nx = np.random.normal(loc=0, scale=1, size=(100, 2))\nx.sum(axis=0)\nx.mean(axis=0)\nx.std(axis=0)\n\narray([0.98109429, 1.10461422])\n\n\n要寻找最大/小值所处的位置，可以使用：\n\nx[x.argmax(axis=0)]\n\narray([[2.39236527, 0.41291216],\n       [0.71226464, 2.59830393]])\n\n\n另外，累积求和或乘积也是常见的运算。下面是一个简单随机游走过程。假设独立的随机变量，\\(Z_{1},Z_{2},\\cdots,Z_{n}\\) ，每一个变量分别有50%的概率取值 \\(1\\) 或 \\(-1\\)。设 \\(S_{0} = 0\\)， \\(S_{n} = \\sum_{i=1}^{n}Z_{i}\\) 是一个简单随机游走过程。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(123)\nn_steps = 1000\nsteps = np.random.choice([-1, 1], size=n_steps)\nwalk = np.cumsum(steps)\n#\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(walk)\nax.set_title('Random Walk')\nax.set_xlabel('Step')\nax.set_ylabel('Position')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n形状操作方法\n这些方法用于改变数组的形状或维度，但通常不会改变数组中的数据。\n\narr.reshape(shape): 返回一个具有新形状的数组，但原始数组不变。例如，arr.reshape(2, 3)。\narr.T: 返回数组的转置。这是一个属性，而非方法，但功能上属于形状操作。\narr.flatten(): 返回一个一维数组的副本。\narr.transpose(): 也是返回数组的转置，与 arr.T 类似。\n\n\narr = np.arange(12).reshape(3, 4)\narr.T\n\narray([[ 0,  4,  8],\n       [ 1,  5,  9],\n       [ 2,  6, 10],\n       [ 3,  7, 11]])\n\n\n\n\n排序和搜索方法\n这些方法用于对数组进行排序或查找特定元素:\n\narr.sort(): 对原始数组进行就地排序。\nnp.sort(arr): 返回一个已排序的数组副本，不改变原始数组。\narr.argsort(): 返回排序后元素的索引，而不是排序后的值。\nnp.where(): 这是一个函数，但常用于搜索操作。它根据条件返回满足条件的元素的索引。\n\n\nnp.where(arr&gt;4, \"High\", \"Low\")\n\narray([['Low', 'Low', 'Low', 'Low'],\n       ['Low', 'High', 'High', 'High'],\n       ['High', 'High', 'High', 'High']], dtype='&lt;U4')\n\n\n\n\n数组的数学运算\n注意，运算符 +, - , *, / 和 **，都是逐元素运算。例如：\n\na = np.array([1,2,3,4])\nb = np.array([5,6,7,8])\na + b\na * b\na + 10\na * 10\n# 2D array\nA = np.ones((2,2))\nB = np.ones((2,2))\nA + B\nA+10\nA * B\n(A+1) ** 2\n\narray([[4., 4.],\n       [4., 4.]])\n\n\n可以使用 @ 或 np.dot() 进行矩阵乘法。如果是向量则计算内积。\n\nA = np.array([[1,2],\n              [3,4]])\nB = np.array([[5,6,],\n              [7,8]])\nA@B\n#or\nnp.dot(A,B)\n#\nb = np.array([0, 1])\nA@b\n\narray([2, 4])\n\n\n一个常用的矩阵运算是特征根和特征向量： \\[\nAe = \\lambda e\n\\]\nNumpy 线性代数子库中的eig()函数可以计算特征根和对应的特征向量：\n\nA = np.array([[1, 2],\n              [3, 4]])\neig, vec = np.linalg.eig(A)\n#print(eig)\nprint(vec[:, 0])\n\n[-0.82456484  0.56576746]\n\n\n主要与第 \\(i\\) 个特征根对应的特征向量是特征向量矩阵的第 \\(i\\) 列， vec[:,i]。",
    "crumbs": [
      "Python基础",
      "Numpy 基础"
    ]
  },
  {
    "objectID": "numpy.html#random子库",
    "href": "numpy.html#random子库",
    "title": "Numpy 基础",
    "section": "Random子库",
    "text": "Random子库\nNumpy中有大量的与随机数生成器有关的函数。\n\n例，t分布的厚尾特征\n下面是一个例子比较了 \\(t\\) 分布的厚尾特征，随机抽取了标准正态分布和t分布的随机数，绘制直方图。如果不设定随机种子数，因此每次运行结果会略有不同。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 10000\nnormal_data = np.random.randn(N)\nt_data = np.random.standard_t(df=3, size=N)\n \nfig, ax = plt.subplots(figsize=(10, 6))\nbins = np.linspace(-10, 10, 100)\nax.hist(normal_data, bins=bins, density=True, \n        edgecolor=\"black\",alpha=0.6, label='Standard Normal Distribution')\nax.hist(t_data, bins=bins, density=True, \n        edgecolor=\"black\", alpha=0.5, label='Student T Distribution(df = 3)')\nax.set_label('value')\nax.set_ylabel('density')\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n例，中心极限定理\n中心极限定理 (Central Limit Theorem, CLT) 是概率论中一个非常强大的定理。它指出，当从任何形状的总体中抽取足够大的独立同分布 (i.i.d.) 样本时，这些样本均值的分布将近似于正态分布，无论原始总体分布如何。样本量越大，近似程度越好。\n在 Figure 1 中，我们将通过以下步骤来模拟验证 CLT：\n\n选择一个非正态分布的总体: 比如，一个指数分布或均匀分布，它们的形状都不是钟形的。\n设置样本参数: 定义每次抽样的样本大小 (sample_size) 和重复抽样的次数 (num_samples)。\n重复抽样并计算均值: 从总体中抽取 num_samples 次样本，每次抽取 sample_size 个数据点，并计算每次抽样的平均值。\n可视化: 绘制样本均值的直方图，并与原始总体分布的直方图进行对比。\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\npopulation_size = 1000000 \nsample_size = 30          \nnum_samples = 10000       \nnp.random.seed(123)\n\npopulation_data = np.random.exponential(\n                    scale=2.0, size=population_size)\n# population_data_uniform = np.random.uniform(\n#                       low=0.0, high=10.0, size=population_size)\n\nsample_means = []\nfor _ in np.arange(num_samples):    \n    sample = np.random.choice(\n        population_data, size=sample_size,\n        replace=True)\n    sample_means.append(np.mean(sample))\nsample_means = np.array(sample_means)\n#\nfig, ax = plt.subplots(nrows = 2, ncols= 1,  figsize=(12, 12))\nax[0].hist(population_data, \n        bins=50, density=True,\n        color='skyblue', edgecolor='black', alpha=0.7)\n\nax[0].set_xlabel('value')\nax[0].set_ylabel('Density')\nax[0].grid(True, linestyle='--', alpha=0.6)\n\nax[1].hist(sample_means, \n            bins=50, density=True,\n            color='lightcoral', edgecolor='black', alpha=0.7)\nax[1].set_ylabel('Density')\nax[1].grid(True, linestyle='--', alpha=0.6)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure 1: Central limit theorem\n\n\n\n\n\n\n\n通用函数\nNumpy中许多函数是通用函数(universal functions)，是一种在 ndarray 数据中进行逐元素操作的函数，大多数数学函数属于此类。\n例如 np.cos() 函数：\n\nnp.cos(1.0)\nnp.cos(np.linspace(0, 1, 3))\n\narray([1.        , 0.87758256, 0.54030231])\n\n\n例如，我们想计算\\(\\frac{0}{1},\\frac{1}{2},\\cdots, \\frac{4}{5}\\):\n\nnp.arange(5) / np.arange(1, 6)\n\narray([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])\n\n\n\n\n\nTable 2: Numpy中算术运算子和函数\n\n\n\n\n\n\n\n\n\n\n\n运算符\n对应的 ufunc\n描述\n示例\n\n\n\n\n+\nnp.add\n加法\n1 + 1 = 2\n\n\n-\nnp.subtract\n减法\n3 - 2 = 1\n\n\n-\nnp.negative\n一元取反\n-2\n\n\n*\nnp.multiply\n乘法\n2 * 3 = 6\n\n\n/\nnp.divide\n除法\n3 / 2 = 1.5\n\n\n//\nnp.floor_divide\n向下取整除法\n3 // 2 = 1\n\n\n**\nnp.power\n幂运算\n2 ** 3 = 8\n\n\n%\nnp.mod\n取模/余数\n9 % 4 = 1\n\n\n\n\n\n\n\n\n例：通用函数\n考察最大化函数 \\(f(x,y)\\) 在区间 $ [−a,a] $ 上的最大值： \\[\nf(x,y)= \\frac{cos(x^{2} + y^{2})}{1 + x^2 + y^2}\n\\] ​ 令\\(a=3\\)。 我们定义一个函数，然后生成数组，计算对应的-值，通过栅格（grid）搜索最大值（等于1）。\n\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nimport matplotlib.pyplot as plt\n\ndef f(x, y):\n    return np.cos(x**2 + y**2) / (1 + x**2 + y**2)\n\ngrid = np.linspace(-3, 3, 50)\nx, y = np.meshgrid(grid, grid)\nz = f(x, y)\n\n# 最大值\nmax_value = np.max(z)\nprint(\"函数的最大值:\", max_value)\n\n# 绘制3D图像\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x, y, z, cmap='viridis')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x, y)')\nplt.show()\n\n函数的最大值: 0.9925310162998334\n\n\n\n\n\n\n\n\n\n\n\n例：洛伦茨曲线和基尼系数\n这个例子里，定义了两个函数，用来计算洛伦茨曲线和基尼系数。\n\nimport numpy as np # 载入numpy库\ndef lorenz_curve(y):\n    n = len(y)\n    y = np.sort(y) # 从小到大排序\n    s = np.zeros(n + 1) # 生成n+1 个数值零\n    s[1:] = np.cumsum(y) # 从第2个数（索引1）累计求和，使第一个数据点为（0，0）\n    cum_people = np.linspace(0, 1, n + 1)\n    cum_income = s / s[n] # s[n]为最后的值，即所有值的和\n    return cum_people, cum_income\n\n\nn = 2000\nnp.random.seed(1)\nsample = np.exp(np.random.randn(n))\nf_vals, l_vals = lorenz_curve(sample)\n#\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(f_vals, l_vals, label=f'lognormal sample', lw = 2)\nax.plot([0, 1], [0, 1], label='equality', lw = 2)\nax.fill_between(f_vals,l_vals, f_vals, alpha=0.06)\nax.fill_between(f_vals, l_vals, np.zeros_like(f_vals),alpha=0.06)\nax.vlines([0.8], [0], [0.43], linestyles='--', colors='gray')\nax.hlines([0.43], [0], [0.8], linestyles='--', colors='gray')\nax.set_xlim((0,1))\nax.set_ylim((0,1))\nax.text(0.55, 0.4,\"A\", fontsize=16)\nax.text(0.75,0.15,\"B\",fontsize=16)\nax.set_xlabel('Cumulative share of people')\nax.set_ylabel('Cumulative share of income')\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n基尼系数\n从图形上看，基尼系数 \\[\nG = \\frac{A}{A+B}\n\\]\n实际应用中常采用的公式为： \\[\nG = \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\vert x_{i} - x_{j}\\vert}{2n^{2}\\bar{x}} = \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\vert x_{i} - x_{j}\\vert}{2n^{2}\\sum_{i=1}^{n}x_{i}}\n\\]\n\ndef gini(x):\n    n = len(x)\n    x_1 = np.reshape(x, (n, 1))\n    x_2 = np.reshape(x, (1, n))\n    g_sum = np.sum(np.abs(x_1 - x_2)) \n    return g_sum / (2 * n * np.sum(x))\n\n\n# 模拟对数正态数据\nnp.random.seed(1)\nk = 5\nsigmas = np.linspace(0.2, 4, k)\nn = 2000\nginis = []\nfor sigma in sigmas:\n    mu = -sigma ** 2 / 2\n    y = np.exp(mu + sigma * np.random.randn(n))\n    ginis.append(gini(y))\n\n\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(sigmas, ginis,\n         marker = 'o',label='simulated', lw = 2)\nax.set_xlabel('Standard deviation')\nax.set_ylabel('Gini coefficient')\nax.legend()\nplt.show()",
    "crumbs": [
      "Python基础",
      "Numpy 基础"
    ]
  },
  {
    "objectID": "logistic.html",
    "href": "logistic.html",
    "title": "Logistic 回归",
    "section": "",
    "text": "在统计学中是一种对数几率模型，是离散选择法模型之一，属于多元变量分析范畴，是社会学、生物统计学、临床、数量心理学、计量经济学、市场营销等统计实证分析的常用方法。",
    "crumbs": [
      "回归分析",
      "逻辑回归"
    ]
  },
  {
    "objectID": "logistic.html#logistic-与-lpm",
    "href": "logistic.html#logistic-与-lpm",
    "title": "Logistic 回归",
    "section": "Logistic 与 LPM",
    "text": "Logistic 与 LPM",
    "crumbs": [
      "回归分析",
      "逻辑回归"
    ]
  },
  {
    "objectID": "logistic.html#logistic回归方法",
    "href": "logistic.html#logistic回归方法",
    "title": "Logistic 回归",
    "section": "Logistic回归方法",
    "text": "Logistic回归方法\nLPM \\[\nY = \\beta_{0} + \\beta_{1}X\n\\]\n\nLogisitc sigmoid 函数\n\\[\n\\sigma(z) = \\frac{1}{1 + \\exp(-z)}\n\\]\n其形状：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef sigmoid(x):\n    return 1/(1+np.exp(-x))\nx = np.linspace(-10, 10, 500)\ny = sigmoid(x)\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(x, y, label = 'Sigmoid Function')\nax.set_title(\"Sigmoid Function Plot\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"sigmoid(x)\")\nax.grid()\nax.legend()\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "回归分析",
      "逻辑回归"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "引言",
    "section": "",
    "text": "《基于Python的经济分析与应用》旨在将经济学理论与现代数据分析技术相结合，内容涵盖Python编程基础、数据采集与处理、经济数据分析、可视化展示及实际案例应用。\n通过学习，使学生掌握应用Python进行经济数据分析的方法，提高数据处理与决策支持能力，为未来从事数据驱动的经济分析、科学研究或制定经济决策打下坚实基础。",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#内容是关于什么的",
    "href": "intro.html#内容是关于什么的",
    "title": "引言",
    "section": "内容是关于什么的？",
    "text": "内容是关于什么的？\n\n经济数据分析\n对经济数据进行分析长期以来都是政策制定、投资者、企业和消费者关注的焦点：\n\n宏观经济形式分析。如毕马威的中国经济观察季度报告等、中国宏观经济论坛发布的CMF中国宏观经济专题报告等。\n美国经济分析局（Bureau of Economic Analysis，BEA）：负责公布美国宏观经济以及行业的统计数据，以及有关美国国内生产总值（GDP）和各个市/镇/乡/村/县和大都市区的数据；\n数据科学在人工智能时代的广泛应用；\n数据服务商的重要作用。如彭博社、Wind资讯等。\n\n\n\n数据分析方法\n将数据分析方法应用至经济学、金融学和国际贸易等学科的有关主题。主要包括：\n\n经济数据分析：如增长、不平等等、通货膨胀等宏观数据；\n统计分析方法：t检验、方差分析等；\n线性回归方法\n蒙特卡洛模拟分析\n机器学习基础方法\n投入产出模型；\n网络分析方法；\n\n\n\n主要参考书\n会用到部分Python有关的内容，如：\n\nMcKinney (2022)， 在线阅读\nVanderPlas (2016)， 在线阅读\nPython Programming for Economics and Finance",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#分析工具python",
    "href": "intro.html#分析工具python",
    "title": "引言",
    "section": "分析工具：Python",
    "text": "分析工具：Python\n我们使用Python作为主要的分析工具。根据TIOBE Index for August 2025，Python是目前最流行的编程语言。\n\n\n\n\n\n\nFigure 1: TIOBE Programming Community Index\n\n\n\n\n功能强大，应用广泛\nPython广泛应用于机器学习、科学计算等各个领域：\n\n机器学习\n数据科学\n通讯\n网页开发\nCGI and GUI\n自然语言处理\n游戏开发\n等等\n\n\n\nPython的特点\nPython具有许多优点：\n\n易读、易写和易调试；\n核心内容易学；\n众多库的支持；\n初学者友好\n支持多平台\n网络资源众多",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#安装和设置软件环境",
    "href": "intro.html#安装和设置软件环境",
    "title": "引言",
    "section": "安装和设置软件环境",
    "text": "安装和设置软件环境\n\n下载安装Python\n\n自官方网站下载Python，当前版本3.13.x。\n双击打开下载的安装程序，如果是Windows操作系统，在点击“Install Now”安装程序之前，注意勾选：Add Python to PATH，将Python的安装路径添加到操作系统的环境变量Path中，如图 Figure 2 所示：\n\n\n\n\n\n\n\nFigure 2: 将Python添加至环境\n\n\n\n\n在“命令提示符”输入python --version查看安装版本，如图 Figure 3 所示。\n\n\n\n\n\n\n\nFigure 3: Python 版本\n\n\n\n\n\n安装Jupyer Lab\n\n安装JupyterLab。通过命令提示符（或Mac OS的终端）安装：pip install jupyterlab。应用过程中经常需要使用pip安装程序，建议将镜像源配置为清华大学开源软件镜像站。\n在命令提示符输入:jupyter lab，就可以在浏览器启动Jupyter Lab，新建一个Notebook就可以使用了，如 Figure 4 所示 。选中单元格（cell），设置为“code”格式（其他两种是markdown和raw），输入：\n\n\nprint(\"Hello World!\")\n\nHello World!\n\n\n\n\n\n\n\n\nFigure 4: Jupyter Lab\n\n\n\n\n\n安装Visual Studio Code\nVisual Studio Code是由微软推出的免费、开源、跨平台的代码编辑器，支持几十种主流编程语言（如JavaScript、Python、C++、Java、Go 等），并且与微软推出的Copilot人工智能工具高度融合，拥有强大的功能和灵活的扩展性。\n\n下载安装Visual Studio Code。 要将软件设置为中文，可以使用快捷键Ctrl + Shift + P打开命令面板，输入Configure Display Languate，在出现的列表中，选择“中文（简体）”，根据提示重启VS Code，界面语言就会变为中文。\n在扩展（Extensions Marketplace）搜索安装插件：\n\nPython\nJupyter,\nExcel Viewer\nRainbow CSV\n\n\n应用时，Visual Studio Code 可以“打开文件”或者 “打开文件夹”将项目所在文件夹处打开。建议以打开文件夹方式，可以比较清楚的概览代码、数据、图形等子文件夹。\n\n\n设置虚拟环境和安装第三方程序包\n要安装第三方程序包，基本的方式是通过pip命令：\npython -m pip install SomePackage\n例如，在命令提示符，或者在Visual Studio Code使用快捷键Ctrl + Shift + \\ `新建终端，输入命令使用pip安装。：\n\nNumpy: python -m pip install numpy\nPandas: python -m pip install pandas\nMatplotlib: python -m pip install matplotlib\n\n更快捷的方式是通过下载记录有程序包名字的requirements.txt文件进行安装：\npip install -r requirements.txt\n可以将需要的第三方程序一次安装。",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#脚本模式和交互模式",
    "href": "intro.html#脚本模式和交互模式",
    "title": "引言",
    "section": "脚本模式和交互模式",
    "text": "脚本模式和交互模式\nPython可以交互式或脚本模式运行。\n\n交互式\n用户输入代码，回车运行。在如IDLE，Ipython都可以方便地进行交互式操作。例如：\n\n在命令提示符（或VSC终端）输入ipython，将打开Ipython的界面，输入3 + 3，回车，将在屏幕上立刻显示计算结果；\n在应用程序中打开 IDLE Shell，也可以方便的进行交互式操作；\n在Jupyter Notebook的代码单元格内，输入代码，点击运行显示结果；\n\n\n\n脚本模式\n脚本模式是将代码保存在.py格式的文件中，然后使用命令提示符调用脚本。\n例如，在文件夹pyfiles中保存有一个文件lunch.py，定义了一个随机选择午餐的函数lunch()，当运行该函数时，随机从列表中选择一个作为推荐的午餐。\n\nimport random\n\ndef lunch():\n    \"\"\"Randomly choose a lunch option and return the result.\"\"\"\n    lunch_list = [\"Rice Bowl\", \"Ramen\", \"Salad\",\n                 \"Burger\", \"Dumplings\", \"Pizza\"]\n    return random.choice(lunch_list)\n\nif __name__ == \"__main__\":\n    result = lunch()\n    print(\"Recomm:\",result)\n\nRecomm: Rice Bowl\n\n\n在命令提示符或终端中运行：\npython pyfiles/lunch.py\n当然，也可以先改变当前文件夹至pyfiles文件夹，就可以省略路径。\n\n\n在Visual Studio Code 中 应用 Jupyter notebook\n打开VSC，点击“文件- 新建文件”，从弹出的菜单选择“Jupyter Notebook”。\n\n\n\n\n\n\nFigure 5: 新建Jupyter Notebook\n\n\n\n下面的例子来自Matplotlib官方网站，将代码复制到Notebook的一个单元格中，点击左侧的运行三角箭头（VSC也许会让你选择一个核），绘制 Figure 6 所示的一个累计概率分布图：\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu = 200\nsigma = 25\nn_bins = 25\ndata = np.random.normal(mu, sigma, size=100)\n\nfig = plt.figure(figsize=(9, 4), layout=\"constrained\")\naxs = fig.subplots(1, 2, sharex=True, sharey=True)\n\n# Cumulative distributions.\naxs[0].ecdf(data, label=\"CDF\")\nn, bins, patches = axs[0].hist(data, n_bins, density=True, histtype=\"step\",\n                               cumulative=True, label=\"Cumulative histogram\")\nx = np.linspace(data.min(), data.max())\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (x - mu))**2))\ny = y.cumsum()\ny /= y[-1]\naxs[0].plot(x, y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Complementary cumulative distributions.\naxs[1].ecdf(data, complementary=True, label=\"CCDF\")\naxs[1].hist(data, bins=bins, density=True, histtype=\"step\", cumulative=-1,\n            label=\"Reversed cumulative histogram\")\naxs[1].plot(x, 1 - y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Label the figure.\nfig.suptitle(\"Cumulative distributions\")\nfor ax in axs:\n    ax.grid(True)\n    ax.legend()\n    ax.set_xlabel(\"Annual rainfall (mm)\")\n    ax.set_ylabel(\"Probability of occurrence\")\n    ax.label_outer()\n\nplt.show()\n\n\n\n\n\n\n\nFigure 6: 累计概率分布\n\n\n\n\n\nJupyter Notebook 延续了ipython中的%run命令，可以脚本模式运行：\n\n%run pyfiles/lunch.py\n\n推荐的午餐: 披萨",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#文档与帮助",
    "href": "intro.html#文档与帮助",
    "title": "引言",
    "section": "文档与帮助",
    "text": "文档与帮助\n\nhelp() 和?\nPython有非常详细的官方帮助文档，帮助新用户快速的熟悉其用法。\n例如，Python有一个内置函数help()，可以查看定义的文档，例如对函数len()：\n\nhelp(len)\n\nHelp on built-in function len in module builtins:\n\nlen(obj, /)\n    Return the number of items in a container.\n\n\n\n由于其重要性，Ipython和Jupyter中可以使用?作为缩写：\n\nlen?\n\n当然，对自定义的对象也是适用的。下面定义的函数，有一段函数的说明文字（docstring）：\n\ndef square(x):\n    \"\"\"\n    Calculates the square of a given number.\n\n    Args:\n        x (int or float): The number to be squared.\n\n    Returns:\n        int or float: The square of the input number.\n    \"\"\"\n    return x**2\n\n如果输入help()函数：\n\nhelp(square)\n\nHelp on function square in module __main__:\n\nsquare(x)\n    Calculates the square of a given number.\n\n    Args:\n        x (int or float): The number to be squared.\n\n    Returns:\n        int or float: The square of the input number.",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "eco/Lib/site-packages/soupsieve-2.7.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/soupsieve-2.7.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pyzmq-27.0.0.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/pyzmq-27.0.0.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/period/test_indexing.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/period/test_indexing.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/datetimes/test_indexing.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/datetimes/test_indexing.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/missingno-0.5.2.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/missingno-0.5.2.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright (c) 2016 Aleksey Bilogur\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/cffi/recompiler.html",
    "href": "eco/Lib/site-packages/cffi/recompiler.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/idna-3.10.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/idna-3.10.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/numpy/random/LICENSE.html",
    "href": "eco/Lib/site-packages/numpy/random/LICENSE.html",
    "title": "NCSA Open Source License",
    "section": "",
    "text": "This software is dual-licensed under the The University of Illinois/NCSA Open Source License (NCSA) and The 3-Clause BSD License\n\nNCSA Open Source License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nDeveloped by: Kevin Sheppard (kevin.sheppard@economics.ox.ac.uk, kevin.k.sheppard@gmail.com) http://www.kevinsheppard.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\nNeither the names of Kevin Sheppard, nor the names of any contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.\n\n\n3-Clause BSD License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nComponents\nMany parts of this module have been derived from original sources, often the algorithm’s designer. Component licenses are located with the component code.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/period/test_constructors.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/period/test_constructors.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas_datareader-0.10.0.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/pandas_datareader-0.10.0.dist-info/LICENSE.html",
    "title": "pandas license",
    "section": "",
    "text": "======= License =======\npandas is distributed under a 3-clause (“Simplified” or “New”) BSD license. Parts of NumPy, SciPy, numpydoc, bottleneck, which all have BSD-compatible licenses, are included. Their licenses follow the pandas license.\n\npandas license\nCopyright (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team All rights reserved.\nCopyright (c) 2008-2011 AQR Capital Management, LLC All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials provided\n   with the distribution.\n\n* Neither the name of the copyright holder nor the names of any\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nAbout the Copyright Holders\nAQR Capital Management began pandas development in 2008. Development was led by Wes McKinney. AQR released the source under this license in 2009. Wes is now an employee of Lambda Foundry, and remains the pandas project lead.\nThe PyData Development Team is the collection of developers of the PyData project. This includes all of the PyData sub-projects, including pandas. The core team that coordinates development on GitHub can be found here: http://github.com/pydata.\nFull credits for pandas contributors can be found in the documentation.\n\n\nOur Copyright Policy\nPyData uses a shared copyright model. Each contributor maintains copyright over their contributions to PyData. However, it is important to note that these contributions are typically only changes to the repositories. Thus, the PyData source code, in its entirety, is not the copyright of any single person or institution. Instead, it is the collective copyright of the entire PyData Development Team. If individual contributors want to maintain a record of what changes/contributions they have specific copyright on, they should indicate their copyright in the commit message of the change when they commit the change to one of the PyData repositories.\nWith this in mind, the following banner should be used in any source code file to indicate the copyright and license terms:\n#—————————————————————————– # Copyright (c) 2012, PyData Development Team # All rights reserved. # # Distributed under the terms of the BSD Simplified License. # # The full license is in the LICENSE file, distributed with this software. #—————————————————————————–\nOther licenses can be found in the LICENSES directory.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/seaborn-0.13.2.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/seaborn-0.13.2.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright (c) 2012-2023, Michael L. Waskom All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "前言",
    "section": "",
    "text": "前言\n本书是为南京师范大学商学院国际商务、数字经济专业硕士准备的课程讲义。目的是掌握基本的数据分析方法，为从事科学研究、论文写作奠定基础。\n本书特色：\n\n将Python与经济分析紧密结合；\n应用实际数据集。，无论是宏观还是微观数据，都是实际学术研究中常使用的数据集，如Penn World Table、CFPS数据集、CHNS等。另外，还大量使用了数据接口，如世界银行数据库的WBGAPI、AKshare等API接口下载数据。\n适合高年级本科生和研究生使用。分析方法是学术期刊经常出现，如熵权法、泰尔指数分解、出口产品复杂度等。\n\n本书内容来自教学实践，囿于作者水平，难免出现疏漏错误，欢迎批评指正。\n\n\n\n\n Back to top",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "matplotlib.html",
    "href": "matplotlib.html",
    "title": "数据可视化",
    "section": "",
    "text": "官方使用教程是非常重要的学习来源。",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "matplotlib.html#图形的构成",
    "href": "matplotlib.html#图形的构成",
    "title": "数据可视化",
    "section": "图形的构成",
    "text": "图形的构成\n图形的构成可以参考Matplotlib官方网站上Anatomy of a figure的说明：\n\n\n\n图形解剖图\n\n\n我们用一个例子来说明绘图的过程。下面的全球电影票房数据来自维基百科全球最高電影票房收入列表\n\nimport pandas as pd\nimport re\ndata = pd.read_excel(\"datasets/highest_gross_films.xlsx\")\ndata['全球票房'] = data['全球票房'].apply(lambda ser: pd.to_numeric(re.sub(r'\\D','', ser)))\ndf = data[:10]\ndf\n\n\n\n\n\n\n\n\n排名\n峰值\n影片名称\n全球票房\n年份\n\n\n\n\n0\n1\n1\n阿凡达\n2923706026\n2009\n\n\n1\n2\n1\n复仇者联盟：终局之战\n2797501328\n2019\n\n\n2\n3\n3\n阿凡达：水之道\n2320250281\n2022\n\n\n3\n4\n1\n泰坦尼克号\n2257844554\n1997\n\n\n4\n5\n5\n哪吒2\n2217080000\n2025\n\n\n5\n6\n3\n星球大战：原力觉醒\n2068223624\n2015\n\n\n6\n7\n4\n复仇者联盟：无限战争\n2048359754\n2018\n\n\n7\n8\n6\n蜘蛛侠：英雄无归\n1922598800\n2021\n\n\n8\n9\n8\n头脑特工队2\n1698863816\n2024\n\n\n9\n10\n3\n侏罗纪世界\n1671537444\n2015",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "matplotlib.html#绘图一般步骤",
    "href": "matplotlib.html#绘图一般步骤",
    "title": "数据可视化",
    "section": "绘图一般步骤",
    "text": "绘图一般步骤\n图形的种类非常多，应用Python绘图时可以大致分为几个步骤。\n\n载入必要的库\n除了基本的绘图工具Matplotlib外，Seaborn库也经常使用，在应用之前均应载入。\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n另外，Matplotlib 默认情况下不支持中文字符。如果你直接在图表标题、坐标轴标签或图例中使用中文，很可能会看到方框乱码或者问号。\n\nplt.rcParams['font.sans-serif'] = ['SimHei', 'Heiti TC', 'WenQuanYi Zen Hei', 'Arial']\n\nplt.rcParams[\"axes.unicode_minus\"] = False\n\n现在有了图形轴（Axes）的实例，就可以在上面绘制图形了。例如绘制一幅柱形图，使用.bar()方法：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(x=df['影片名称'], height=df['全球票房'], color='skyblue')\nplt.show()\n\n\n\n\n\n\n\n\n显然，图形还有改善的空间。比如横轴的标签，即电影名字挤在一起看不清楚，也可以设置纵轴标签、图形标题等：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(x=df['影片名称'], height=df['全球票房'], color='skyblue')\nax.set_yscale(\"log\")\nax.set_title('电影全球总票房前十名', fontsize=16, fontweight='bold')\nax.set_xlabel('影片名称', fontsize=12)\nax.set_ylabel('全球票房 ($)', fontsize=12)\nplt.xticks(rotation=45, ha='right') \nplt.show()\n\n\n\n\n\n\n\n\n横向柱形图\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.barh(y = df['影片名称'], width=df['全球票房'], color='skyblue')\nax.set_xscale(\"log\")\nax.set_title('电影全球总票房前十名', fontsize=16, fontweight='bold')\nax.set_ylabel('影片名称', fontsize=12)\nax.set_xlabel('全球票房 ($)', fontsize=12)\n\nplt.show()",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "matplotlib.html#常用的图形",
    "href": "matplotlib.html#常用的图形",
    "title": "数据可视化",
    "section": "常用的图形",
    "text": "常用的图形\n\n直方图\n直方图可以被看作是估计概率密度函数（PDF）的一种基本而直观的方法，但严格来说，它估计的是概率质量函数（PMF），尤其是在处理离散数据时。当用于连续数据时，它更像是PDF的一个粗略估计。\n直方图将数据分成一系列不重叠的“箱子”（bins）。对于每个箱子，它统计落入该箱子中的数据点的数量，并以一个矩形柱的高度来表示这个数量，当然也可以用每个柱子的高度表示该箱子中数据点所占的比例或频率。\n下面的例子自雅虎财经网站下载几支股票的月度（后复权调整）收盘价数据，然后使用df.pct_change()函数计算了简单收益率。\n\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\n#import yfinance as yf\n# stocks_list = ['AAPL','BA','MGM','AMZN','IBM','TSLA','GOOG','^GSPC']\n# start_date = \"2012-01-01\"\n# end_date = \"2025-06-30\"\n# df = yf.download(tickers=stocks_list,\n#          start=start_date,\n#          end=end_date, \n#          interval=\"1mo\",\n#          auto_adjust=True,\n#          progress=False)['Close']\n\n# df.to_csv(\"datasets/stocks_price_us.csv\")\n\nstocks_price_us = pd.read_csv(\"datasets/stocks_price_us.csv\",\n                     header=0, index_col=0, parse_dates=True )\n\nreturns = stocks_price_us.pct_change()\n\n例如，绘制苹果公司股票收益率的直方图：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.hist(x=returns['AAPL'], bins=20, \n        color=\"skyblue\", edgecolor=\"black\") \nax.vlines(x=returns['AAPL'].mean(), \n        ymin=0, ymax=18, colors=\"darkred\",        \n        alpha=0.6)\nax.set_xlabel(\"Monthly Return of AAPL\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n\n\n\n\n\n\n\n\n如果纵轴希望表示为概率密度，加上参数density=True。\n下载的数据包含8家7家企业以及标准普尔500指数（GSPC），下面将收益率为子图绘制直方图。为了可比，横轴使用了sharex=True参数：\n\nfig, axes = plt.subplots(nrows=2, \n                        ncols=4,\n                        figsize=(15, 10),\n                        sharex=True)\nstock_index = 0\nfor row in range(2):\n    for col in range(4):\n        stock = returns.columns[stock_index]        \n        axes[row, col].hist(returns[stock], color=\"skyblue\",\n                edgecolor='black', bins=20)\n        axes[row, col].set_title(f'{stock}', fontsize=14)\n        stock_index += 1\nfig.supxlabel(\"Monthly Returns\", fontsize=16)\nfig.supylabel(\"Frequency\", fontsize=16)\nfig.suptitle(\"Histograms of Monthly Returns\", fontsize=18)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n核密度图\n对连续数据来讲，估计概率密度函数的更好的方法是核密度函数估计（Kernel Density Estimator，KDE）。\n设 \\((x_{1}, x_{2},\\cdots ,x_{n})\\) 为从单变量分布中抽取的独立同分布样本，给定点 \\(x\\) 有未知的概率密度 \\(f(x)\\)，我们需要估计观察到的值的概率密度函数 \\(\\hat{f}(x)\\) 。\n在KDE估计过程中处于核心地位的是核函数，我们逐步来看应用的过程。\n假设有一个观测值，例如 \\(x = 0\\)，我们要估计观测值服从的概率密度函数，最合理的估计是使用一个PDF在该点取峰值，向两侧衰减。例如函数 \\(= \\exp(-x^{2})\\) 满足这个条件。但是我们知道，PDF下面积应为1，因此进行适当转换以满足该条件，记为： \\[\nK(x) = \\frac{1}{\\sqrt{2\\pi}}\\exp(\\frac{-x^{2}}{2})\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef k(x):\n    return np.exp(-x**2)\ndef K(x):\n    return (1/np.sqrt(2*np.pi))*np.exp(-x**2/2)\n\nx = np.linspace(-3.5, 3.5, 1000)\ny1 = k(x)\ny2 = K(x)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(x, y1, linewidth = 2.5, label = r\"$\\exp(-x^{2})$\")\nax.plot(x, y2, linewidth = 2.5, label = r\"$\\frac{1}{\\sqrt{2\\pi}}\\exp(\\frac{-x^{2}}{2})$\")\nax.set_xlabel(r'$x$', fontsize=16)\nax.set_ylabel('') \nax.legend(fontsize=16)\nplt.tight_layout()\nplt.show() \n\n\n\n\n\n\n\n\n这样我们就得到了一个非常常用的核函数 \\(K(x)\\)，零均值和单位方差的高斯（Gaussian）分布。\n对观测值中的任意点 \\(x_{i}\\)，相当于沿着 \\(x\\) 轴平移曲线，用核函数表示为： \\[\nK(x - x_{i})\n\\]\n要让曲线更宽或更窄，可以加入一个常数 \\(h\\) 在分母上，称为带宽。这样将核函数曲线下面积乘了 \\(h\\) ，为保持单位面积需要除以 \\(h\\)，即：\n \\[\n\\frac{1}{h}K(\\frac{x - x_{i}}{h})\\tag{5.1}\n\\]\n带宽的选择影响估计的密度函数，带宽越宽，曲线越平缓；带宽越小，曲线越陡峭。\nKDE估计阐释性例子\n下面利用上面的函数 5.1，从最简单的情况开始，逐步阐释KDE是如何进行的。\n首先假设观测值只包含一个点，\\(x_{1} = 1.33\\)，我们选择一个带宽，比如 \\(h=0.3\\)，估计的PDF为： \\[\n\\frac{1}{h}K(\\frac{x - x_{1}}{h})\n\\]\n\nx1 = 1.5\nh = 0.3\n\nx_grid = np.linspace(-1, 2.5, num = 500)\nfig, ax = plt.subplots(figsize=(8, 6))\nf_grid = K((x_grid-x1)/h)/h\nax.plot(x_grid, f_grid, linestyle = \"--\")\nax.scatter(x1, 0, marker=\"s\",s=50)\nax.annotate(r\"$x_{1}$\", xy=[x1, 0.02], fontsize=16)\nplt.show()\n\n\n\n\n\n\n\n\n现在假设第二个观测值为 \\(x_{2} = 0.5\\)，可以同样的方式估计 \\[\n\\frac{1}{h}K(\\frac{x - x_{2}}{h})\n\\]\n要得到一个概率密度函数，需要将两者加起来，然后除以2：\n\\[\nf(x) = \\frac{1}{2h}\\left[K(\\frac{x-x_{1}}{h}) + K(\\frac{x-x_{2}}{h}) \\right] = \\frac{1}{2h}\\sum_{i=1}^{2}K(\\frac{x-x_{i}}{h})\n\\]\n在Scipy库中，有常见的统计分布的概率密度函数，可以利用其正态分布的概率密度函数norm().pdf()非常简便的进行计算:\n\n对每个数据点xi，创建一个均值为xi、标准差为h的正态分布对象；\n对每个对象，计算x_d网格上的PDF值；\n对所有PDF值进行求和；\n\n\n\nfrom scipy.stats import norm\nx = np.array([1.5, 0.5])\nh = 0.3\nx_grid = np.linspace(-1, 2.5, num = 500)\n\nn = len(x)\ndensity = sum(norm(loc=xi, scale=h).pdf(x_grid) for xi in x)/n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nfor xi in x:\n    ax.plot(x_grid, norm(xi,h).pdf(x_grid), color = 'black', linestyle = \"--\")            \nax.plot(x_grid, density, color='red', \n            linewidth = 2.5, label = \"KDE with gaussian kernel function\")\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n很容易将上述方法类推到 \\(n\\) 个观测值 \\((x_{1}, x_{2},\\cdots ,x_{n})\\) 的情况：\n \\[\nf(x) = \\frac{1}{nh}\\sum_{i=1}^{n}K(\\frac{x-x_{i}}{h}) \\tag{5.2}\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\ndef plot_kde_scipy(data, h, n_points=500):\n    data_min = np.min(data)\n    data_max = np.max(data)\n    x_min = data_min - 3 * h\n    x_max = data_max + 3 * h\n    n = len(data)\n    x_grid = np.linspace(x_min, x_max, num=n_points)   \n    density = sum(norm(loc=xi, scale=h).pdf(x_grid) for xi in data)/n          \n    plt.figure(figsize=(8, 6))    \n    plt.fill_between(x_grid, density, alpha=0.3, color='skyblue')   \n    plt.plot(x_grid, density, color='cornflowerblue', linewidth=2)   \n    \n    plt.title(f'KDE Estimate using SciPy (Bandwidth h = {h})', fontsize=18)\n    plt.xlabel('x', fontsize=14)\n    plt.ylabel('Density', fontsize=14)\n    plt.ylim(bottom=-0.02)\n    plt.grid(True, linestyle='--', alpha=0.6)\n    plt.show()\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nbandwidth1 = 0.3\nplot_kde_scipy(data, h=bandwidth1)\n\n\n\n\n\n\n\n\nSeaborn中的kdeplot方法\nSeaborn库中有kdeplot函数，可以方便用来估计。带宽选择参数bw_method:\n\nScott方法(Scott (2015)): \\[\nh\\approx 1.06\\cdot\\hat{\\sigma}n^{-1/5}\n\\]\nSilvermans 方法(Silverman (2018))： \\[\nh = 0.9\\cdot \\min(\\hat{\\sigma}, IQR/1.35)n^{-1/5}\n\\]\n\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nimport seaborn as sns\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.kdeplot(data, bw_method=\"scott\",\n            alpha = 0.3,\n            linewidth = 2.5,\n            ax=ax)\n\nax.set_xlabel(\"value\", fontsize=14)\nax.set_ylabel(\"density\", fontsize=14)\nsns.despine(left=False, bottom=True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n可以取不同带宽看其影响。注意这里bw_adjust是作为一个系数乘以scott方法得到的带宽值，详见说明文档：\n\nbw_adjust_values = [0.2, 0.8, 1.4, 2.0]\nfig, ax = plt.subplots(figsize=(12, 8))\nfor bw in bw_adjust_values:\n    sns.kdeplot(data, bw_adjust=bw, label=f'bw_adjust = {bw}', linewidth=2.5)\nax.plot(data, np.zeros_like(data), '|k', markeredgewidth=1, label='Data Points')\n\nax.set_title('KDE Plots with Different Bandwidth Adjustments', fontsize=18)\nax.set_xlabel('x', fontsize=14)\nax.set_ylabel('Density', fontsize=14)\nax.legend(title='Bandwidth', fontsize=12)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n我们可以定义一个函数计算soctt方法的带宽值，然后用自定义的函数来绘制KDE图：\n\ndef scott_method(x):\n    h = 1.06*x.std()*len(x)**(-0.2)\n    return h\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nscott_value = scott_method(data)\nplot_kde_scipy(data, h=scott_value)\n\n\n\n\n\n\n\n\n除了正态核函数以外，还有其他核函数，但总体来讲核函数的影响没有带宽影响的差异大，Seaborn的kdeplot方法甚至取消了原本可以选择的设定。Scikit-Learn Kernel Density 算法提供了6种不同的核函数。另外，Pandas库的s.plot.kde()方法也可以绘制核密度图。\n\n\n热图\n热图是一种数据可视化技术，用颜色深浅来表示数据集中不同数值的大小或密集程度。\n\ncorr = returns.corr().round(2)\n\nfig, ax = plt.subplots(figsize=(10, 8))\nsns.heatmap(corr, annot=True,\n            ax=ax,\n            cmap='coolwarm')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n箱形图\n\n\n散点图",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "matplotlib.html#多图和子图",
    "href": "matplotlib.html#多图和子图",
    "title": "数据可视化",
    "section": "多图和子图",
    "text": "多图和子图\n当有多幅图形绘制时，可以放在一张图形上或用子图排列。 ### 多图\n\n# 正态分布\nimport numpy as np\nfrom scipy.stats import norm\nnp.random.seed(12345)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nx = np.linspace(-4, 4, 500)\nfor i in range(3):\n    mu, std = np.random.uniform(-1,1), np.random.uniform(1, 3)\n    y = norm.pdf(x, loc = mu, scale = std)\n    current_label = rf\"$\\mu = {mu:.2f}$\"\n    ax.plot(x, y, linewidth = 2, alpha = 0.6, label = current_label)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n子图\n下面的例子绘制了4个子图，按照 \\(2\\times 2\\) 的方式排列nrows=2, ncols=2：\n\nnp.random.seed(123)\nfig, axes = plt.subplots(nrows=2, ncols=2,figsize=(10,8),sharex=True,sharey=True)\nfor i in range(2):\n    for j in range(2):\n        m, s = np.random.uniform(-1, 1), np.random.uniform(1, 2)\n        x = np.random.normal(m,s,100)\n        axes[i, j].hist(x, alpha = 0.6, bins=20)\n        title = rf\"$\\mu = {m:.2f},\\quad \\sigma = {s:.2f}$\"\n        axes[i, j].set(title = title, xticks = [-4, 0, 4],yticks = [])\nplt.show()\n\n\n\n\n\n\n\n\n\n\n图形风格\n\nplt.style.available\n\n['Solarize_Light2',\n '_classic_test_patch',\n '_mpl-gallery',\n '_mpl-gallery-nogrid',\n 'bmh',\n 'classic',\n 'dark_background',\n 'fast',\n 'fivethirtyeight',\n 'ggplot',\n 'grayscale',\n 'petroff10',\n 'seaborn-v0_8',\n 'seaborn-v0_8-bright',\n 'seaborn-v0_8-colorblind',\n 'seaborn-v0_8-dark',\n 'seaborn-v0_8-dark-palette',\n 'seaborn-v0_8-darkgrid',\n 'seaborn-v0_8-deep',\n 'seaborn-v0_8-muted',\n 'seaborn-v0_8-notebook',\n 'seaborn-v0_8-paper',\n 'seaborn-v0_8-pastel',\n 'seaborn-v0_8-poster',\n 'seaborn-v0_8-talk',\n 'seaborn-v0_8-ticks',\n 'seaborn-v0_8-white',\n 'seaborn-v0_8-whitegrid',\n 'tableau-colorblind10']\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use(\"ggplot\")\n\ndef f(x, theta):\n    return np.cos(np.pi * theta * x ) * np.exp(- x)\n\nθ_vals = np.linspace(0, 2, 10)\nx = np.linspace(0, 5, 200)\nfig, ax = plt.subplots(figsize=(8, 6))\n\nfor theta in θ_vals:\n    ax.plot(x, f(x, theta), label = rf\"$\\theta = {theta:.2f}$\")\n\nax.legend()\nplt.show()",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "matplotlib.html#应用收益率的几个典型事实",
    "href": "matplotlib.html#应用收益率的几个典型事实",
    "title": "数据可视化",
    "section": "应用：收益率的几个典型事实",
    "text": "应用：收益率的几个典型事实\n这部分内容，\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport yfinance as yf\nimport scipy.stats as stats\nimport statsmodels.api as sm\n\n然后下载或读取数据：\n\n# df = yf.download(['^GSPC', '^VIX'], \n#                 start='1990-01-01',\n#                 auto_adjust=True,                \n#                 progress=False)['Close']\n# df.to_csv('datasets/sp500_vix.csv')\n\ndf = pd.read_csv('datasets/sp500_vix.csv',                \n                header=0,\n                index_col=0,\n                parse_dates=True)\ndf.columns = [\"SP500\", \"VIX\"]\ndf['log_ret'] = np.log(df['SP500']/df['SP500'].shift(1))\ndf.dropna(inplace=True)\n\n\n厚尾\n\nfig,ax =plt.subplots(1,2,figsize=(10,6))\nsns.kdeplot(df['log_ret'], fill=False,label='kernel density',ax=ax[0])\nmu, sigma = stats.norm.fit(df['log_ret'])\nx = np.linspace(df['log_ret'].min(), df['log_ret'].max(), 1000)\ny = stats.norm.pdf(x, mu, sigma)\nax[0].plot(x, y, color='r', label='Normal Distribution',linestyle='--')\nax[0].legend(frameon=False)\nsm.qqplot(df['log_ret'], line='s', ax=ax[1])\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n高斯性质\n\nperiods = ['D','W','ME']\nfrequency = ['daily','weekly','monthly']\n\nfig, ax = plt.subplots(2,3,figsize=(12,8))\nfor i, p in enumerate(periods):\n    df_resample = df.resample(p).last()\n    log_return = np.log(df_resample['SP500']/df_resample['SP500'].shift(1)).dropna()\n    sns.histplot(log_return, kde=True,label='Histogram',ax=ax[0][i])\n    ax[0][i].set_title(frequency[i])\n    sm.qqplot(log_return, line='s', ax=ax[1][i])\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n波动集聚性\n\nfig, ax = plt.subplots(dpi=300,figsize=(10,6))\nax.plot(df['log_ret']*100,\n        label='SP500 Log Return')\nax.set_ylabel('Log Returns(%)')\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n自相关\n\nfrom statsmodels.graphics.tsaplots import plot_acf\n\nperiods = ['D','W','ME']\nfrequency = ['daily','weekly','monthly']\n\nfig, ax = plt.subplots(3,3,figsize=(12, 8))\nfor i, p in enumerate(periods):\n    df_resample = df.resample(p).last()\n    log_return = np.log(df_resample['SP500']/df_resample['SP500'].shift(1)).dropna()\n    plot_acf(log_return,ax=ax[i][0],title='')  \n    plot_acf(log_return**2,ax=ax[i][1],title='')    \n    plot_acf(np.abs(log_return),ax=ax[i][2],title='')    \nax[0][0].set_ylabel('Daily Return')\nax[1][0].set_ylabel('Weekly Return')\nax[2][0].set_ylabel('Monthly Return')\nax[0][0].set_title('Log Return')\nax[0][1].set_title('Squared Return')\nax[0][2].set_title('Absolute Return')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n杠杆效应\n\ndf = pd.read_csv('datasets/sp500_vix.csv',                \n                header=0,\n                index_col=0,\n                parse_dates=True)\ndf.columns = [\"SP500\", \"VIX\"]\nret_sp = np.log(df/df.shift(1)).dropna()\n\nfig, ax = plt.subplots(2,1,figsize=(10, 8))\nax[0].plot(df['SP500'].loc[\"2018\":],\n             color='blue',lw=2)\nax[0].set_xlabel('Time')\nax[0].set_ylabel('Close Price')\nax2 = ax[0].twinx()\nax2.plot(ret_sp['SP500'].loc[\"2018\":],\n             color='red',alpha=0.7,lw=0.5)\nax2.set_ylabel('Log Return')\nsns.regplot(x='SP500', y='VIX', \n            data=ret_sp, ax=ax[1])\nax[1].set_xlabel('Log Returns of SP500')\nax[1].set_ylabel('Log Returns of Implied VIX')\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "数据分析",
      "数据的可视化"
    ]
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "Pandas 基础应用",
    "section": "",
    "text": "Pandas是数据分析最常用的包，从基本的数据处理到更复杂的统计功能，如 statsmodels 和 scikit-learn库，都是建立在pandas基础上的。\n这一部分应用Penn World Table介绍应用Pandas处理原始数据的一些常用方法。该数据集当前版本为PWT 10.01，包含183个国家1950-2019年的收入、产出、投入和生产率等指标，详细介绍可参见User Guide to PWT 10.0 data files。数据背后的方法、理论及使用建议，可参见 Feenstra, Inklaar, and Timmer (2015)。\n同样，在进行进一步操作之前，先载入必要的库：\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"] = (8, 6)\n\nimport wbgapi as wb",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#载入数据",
    "href": "pandas.html#载入数据",
    "title": "Pandas 基础应用",
    "section": "载入数据",
    "text": "载入数据\n\n创建DataFrame\n可以由数组、列表、字典、序列等创建数据框。例如，使用Numpy生成两列服从正态分布的随机数：\n\nX = np.random.normal(loc=1, scale=2, size=(100, 2))\ndf = pd.DataFrame(data=X,             \n             columns=['X1', 'X2'])\ndf.head()\n\n\n\n\n\n\n\n\nX1\nX2\n\n\n\n\n0\n1.162737\n3.940003\n\n\n1\n0.497564\n3.024172\n\n\n2\n2.910528\n0.973423\n\n\n3\n1.279349\n2.614834\n\n\n4\n1.241869\n0.985710\n\n\n\n\n\n\n\n下面来看字典的例子。定义字典常采用两种方式:\n\n面向列的字典，字典的键代表表格的列名，而每个值是一个包含该列所有数据的列表。当使用 pd.DataFrame(data) 创建 DataFrame 时，会直接将这些键作为列名，值作为列数据：\n\n\ndata = {\n    '地区': ['江苏省', '浙江省', '上海市'],\n    '人口（万人）': [8526, 6627, 2487],\n    '人均国内生产总值（元）': [150487, 125043, 19032]\n}\npd.DataFrame(data)\n\n\n\n\n\n\n\n\n地区\n人口（万人）\n人均国内生产总值（元）\n\n\n\n\n0\n江苏省\n8526\n150487\n\n\n1\n浙江省\n6627\n125043\n\n\n2\n上海市\n2487\n19032\n\n\n\n\n\n\n\n\n面向行的字典，将每一行数据定义为一个独立的字典，然后将这些字典放入一个列表中。每个字典的键是列名，值是该行对应的数据。\n\n\ndata = [\n    {'地区': '江苏省', '人口（万人）': 8526, '人均国内生产总值（元）': 150487},\n    {'地区': '浙江省', '人口（万人）': 6627, '人均国内生产总值（元）': 125043},\n    {'地区': '上海市', '人口（万人）': 2487, '人均国内生产总值（元）': 19032}\n]\npd.DataFrame(data)\n\n\n\n\n\n\n\n\n地区\n人口（万人）\n人均国内生产总值（元）\n\n\n\n\n0\n江苏省\n8526\n150487\n\n\n1\n浙江省\n6627\n125043\n\n\n2\n上海市\n2487\n19032\n\n\n\n\n\n\n\n\n\n读取数据\nPandas提供了广泛的导入数据的命令，当前主要软件存储格式的文件，csv, excel, stata, html, json,sql等，几乎都可以识别。 网站提供了Stata和Excel格式数据，假设数据保存在当前路径的datasets子文件中。Excel格式数据使用pd.read_excel()函数读取数据，有多个表单需要用参数sheet_name指明表单名称：\n\npwt = pd.read_excel(io = \"datasets/pwt1001.xlsx\",\n                header=0,                \n                sheet_name=\"Data\")\n\n注意其中的几个参数，io是文件路径；header表明列标题行，这里是第一行；sheet_name是数据所在表单名；将载入的数据赋值给pwt数据框。\n如果下载了Stata格式，使用pd.read_stata()函数读取数据：\n\npwt = pd.read_stata(filepath_or_buffer=\"datasets/pwt1001.dta\")\n\nPandas中的Series 基于Numpy数组，支持许多类似运算，可以看作一“列”数据；\n\npop = pwt['pop']\ntype(pop)\n\npandas.core.series.Series\n\n\n序列与Numpy数组一样有许多方法运算，读者可以参阅pandas.Series。数据处理中主要对象是DataFrame，类似Excel表单每一列对应一个变量。索引（index）对应行，变量列名（columns）对应列。\nPenn World Table 数据本身是一个面板数据（Panel Data），“国家 - 年” 唯一识别一个观测值。我们从截面数据入手先只保留2019年数据，然后再看多索引的情况。这里.copy()拷贝了原数据生成一个新的数据框，这样即使改变数据也不影响初始的数据框。另外，变量cor_exp在2019年全部为缺失值，这里直接删除了。\n\npwt2019 = pwt[pwt['year'] == 2019].copy().drop(labels='cor_exp', axis=1)",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#pandas的基本操作",
    "href": "pandas.html#pandas的基本操作",
    "title": "Pandas 基础应用",
    "section": "Pandas的基本操作",
    "text": "Pandas的基本操作\n\n设置索引\n先为pwt2019数据框设置索引(index)变量，这里使用国家名代码变量（countrycode），inplace=True选项原地改变数据框，不需要另外赋值：\n\npwt2019.set_index('countrycode', inplace=True)\n\n\n\n概览数据\n可以df.info()概率数据集，或者使用df.head()或df.tail()查看头部和尾部观测值：\n\npwt2019.info()\npwt2019.head()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 183 entries, ABW to ZWE\nData columns (total 50 columns):\n #   Column         Non-Null Count  Dtype   \n---  ------         --------------  -----   \n 0   country        183 non-null    object  \n 1   currency_unit  183 non-null    object  \n 2   year           183 non-null    int16   \n 3   rgdpe          183 non-null    float32 \n 4   rgdpo          183 non-null    float32 \n 5   pop            183 non-null    float64 \n 6   emp            177 non-null    float32 \n 7   avh            66 non-null     float64 \n 8   hc             145 non-null    float32 \n 9   ccon           183 non-null    float32 \n 10  cda            183 non-null    float32 \n 11  cgdpe          183 non-null    float32 \n 12  cgdpo          183 non-null    float32 \n 13  cn             180 non-null    float32 \n 14  ck             137 non-null    float32 \n 15  ctfp           118 non-null    float32 \n 16  cwtfp          118 non-null    float32 \n 17  rgdpna         183 non-null    float32 \n 18  rconna         183 non-null    float32 \n 19  rdana          183 non-null    float32 \n 20  rnna           180 non-null    float32 \n 21  rkna           137 non-null    float32 \n 22  rtfpna         118 non-null    float32 \n 23  rwtfpna        118 non-null    float32 \n 24  labsh          138 non-null    float32 \n 25  irr            137 non-null    float32 \n 26  delta          180 non-null    float32 \n 27  xr             183 non-null    float64 \n 28  pl_con         183 non-null    float32 \n 29  pl_da          183 non-null    float32 \n 30  pl_gdpo        183 non-null    float32 \n 31  i_cig          183 non-null    category\n 32  i_xm           183 non-null    category\n 33  i_xr           183 non-null    category\n 34  i_outlier      183 non-null    category\n 35  i_irr          137 non-null    category\n 36  statcap        127 non-null    float64 \n 37  csh_c          183 non-null    float32 \n 38  csh_i          183 non-null    float32 \n 39  csh_g          183 non-null    float32 \n 40  csh_x          183 non-null    float32 \n 41  csh_m          183 non-null    float32 \n 42  csh_r          183 non-null    float32 \n 43  pl_c           183 non-null    float32 \n 44  pl_i           183 non-null    float32 \n 45  pl_g           183 non-null    float32 \n 46  pl_x           183 non-null    float32 \n 47  pl_m           183 non-null    float32 \n 48  pl_n           180 non-null    float32 \n 49  pl_k           137 non-null    float32 \ndtypes: category(5), float32(38), float64(4), int16(1), object(2)\nmemory usage: 39.2+ KB\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\n\n\n5 rows × 50 columns\n\n\n\n默认显示5条观测值，如果希望看到更多观测值，可以使用 df.tail(n=10) 修改数值。\n可以应用.shape, .ndim,.columns等属性查看基本信息，可以看到数据集包含51个变量共183个观测值。\n\nprint(pwt2019.shape)\nprint(pwt2019.columns)\n\n(183, 50)\nIndex(['country', 'currency_unit', 'year', 'rgdpe', 'rgdpo', 'pop', 'emp',\n       'avh', 'hc', 'ccon', 'cda', 'cgdpe', 'cgdpo', 'cn', 'ck', 'ctfp',\n       'cwtfp', 'rgdpna', 'rconna', 'rdana', 'rnna', 'rkna', 'rtfpna',\n       'rwtfpna', 'labsh', 'irr', 'delta', 'xr', 'pl_con', 'pl_da', 'pl_gdpo',\n       'i_cig', 'i_xm', 'i_xr', 'i_outlier', 'i_irr', 'statcap', 'csh_c',\n       'csh_i', 'csh_g', 'csh_x', 'csh_m', 'csh_r', 'pl_c', 'pl_i', 'pl_g',\n       'pl_x', 'pl_m', 'pl_n', 'pl_k'],\n      dtype='object')\n\n\ndf.describe()函数报告数值型变量基本的描述统计量，如观测值数、最小/大值等：\n\npwt2019.describe()\n\n\n\n\n\n\n\n\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\n\n\ncount\n183.0\n1.830000e+02\n1.830000e+02\n183.000000\n177.000000\n66.000000\n145.000000\n1.830000e+02\n1.830000e+02\n1.830000e+02\n...\n183.000000\n183.000000\n183.000000\n183.000000\n183.000000\n183.000000\n183.000000\n183.000000\n180.000000\n137.000000\n\n\nmean\n2019.0\n6.856771e+05\n6.845371e+05\n41.425665\n18.736708\n1849.981084\n2.709271\n4.942579e+05\n6.783440e+05\n6.832245e+05\n...\n0.289549\n-0.395140\n0.047751\n0.682804\n0.806373\n0.593989\n0.647064\n0.608261\n0.563515\n0.835093\n\n\nstd\n0.0\n2.326857e+06\n2.326577e+06\n150.991398\n72.598854\n269.239240\n0.702803\n1.622457e+06\n2.332140e+06\n2.315811e+06\n...\n0.318229\n0.352245\n0.132470\n1.324540\n2.508052\n1.060947\n0.072499\n0.060341\n1.523753\n1.048638\n\n\nmin\n2019.0\n9.919158e+01\n7.769418e+01\n0.004989\n0.002537\n1380.607643\n1.224987\n1.432163e+02\n1.593778e+02\n9.965278e+01\n...\n0.000002\n-2.445801\n-0.402837\n0.164474\n0.238807\n0.048096\n0.410998\n0.430082\n0.102959\n0.157861\n\n\n25%\n2019.0\n2.542229e+04\n2.496249e+04\n2.148923\n0.966091\n1650.921776\n2.157010\n2.015232e+04\n2.440136e+04\n2.538902e+04\n...\n0.089786\n-0.500661\n-0.004248\n0.386795\n0.496182\n0.301914\n0.611683\n0.569492\n0.315582\n0.509706\n\n\n50%\n2019.0\n8.906167e+04\n8.964218e+04\n8.955102\n4.235073\n1818.281597\n2.776406\n7.898192e+04\n9.572196e+04\n8.879797e+04\n...\n0.192402\n-0.299031\n0.010712\n0.494755\n0.573736\n0.440775\n0.658543\n0.602733\n0.396131\n0.657925\n\n\n75%\n2019.0\n4.438705e+05\n4.277259e+05\n29.763979\n11.694400\n2061.049973\n3.259456\n3.095488e+05\n4.139670e+05\n4.424204e+05\n...\n0.358440\n-0.170650\n0.073669\n0.733338\n0.729491\n0.662306\n0.688106\n0.645397\n0.529977\n0.850074\n\n\nmax\n2019.0\n2.086051e+07\n2.059584e+07\n1433.783686\n798.807739\n2474.911893\n4.351568\n1.682624e+07\n2.138355e+07\n2.079136e+07\n...\n2.194109\n-0.001072\n0.704883\n18.143538\n34.444988\n14.175777\n0.882256\n0.847409\n20.694918\n12.002436\n\n\n\n\n8 rows × 43 columns\n\n\n\n\n\n选择观测值和变量\n应用中经常需要对某些观测值或特定子样本进行操作，就需要选择观测值和变量。\n选择特定的行，在Python中最基本的方法是采用数组切片（slicing）方式。例如，选择第3至5个观测值，注意索引对应的是[2:5]：\n\npwt2019[2:5]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\n\n\n3 rows × 50 columns\n\n\n\n要选择列，可以用包含列名字的列表指定：\n\nvars_selected = ['country', 'rgdpe', 'rgdpo', 'pop', 'emp', 'cgdpe', 'cgdpo', 'ctfp' ]\npwt2019_sub = pwt2019[vars_selected]\npwt2019_sub.head()\n\n\n\n\n\n\n\n\ncountry\nrgdpe\nrgdpo\npop\nemp\ncgdpe\ncgdpo\nctfp\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\n3921.261230\n3467.299561\n0.106314\n0.047601\n3912.334717\n3466.241943\nNaN\n\n\nAGO\nAngola\n228151.015625\n227855.718750\n31.825295\n16.644962\n227771.609375\n223289.312500\n0.387996\n\n\nAIA\nAnguilla\n376.634979\n225.680527\n0.014869\nNaN\n375.136444\n241.384537\nNaN\n\n\nALB\nAlbania\n35890.019531\n36103.042969\n2.880917\n1.075898\n35808.343750\n36288.328125\nNaN\n\n\nARE\nUnited Arab Emirates\n681525.812500\n645956.250000\n9.770529\n5.808834\n678241.187500\n635332.812500\nNaN\n\n\n\n\n\n\n\n\n\n.loc方法\n.loc 是基于标签（label-based） 的数据选择方法。这意味着你使用行和列的实际标签名来选择数据，而不是它们的整数位置。\n在之前我们将ISO国家代码设置位索引，因此选择列时可以用索引标签进行。例如，要选择金砖国家（BRICKS）的观测值：\n\nbricks = ['CHN', 'BRA', 'RUS', 'IND', 'ZAF']\npwt2019.loc[bricks]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCHN\nChina\nYuan Renminbi\n2019\n20056066.0\n2.025766e+07\n1433.783686\n798.807739\n2168.918848\n2.698987\n1.056606e+07\n...\n0.192402\n-0.167672\n-4.100976e-03\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nBRA\nBrazil\nBrazilian Real\n2019\n3089273.5\n3.080048e+06\n211.049527\n93.956825\n1707.795058\n3.091373\n2.566911e+06\n...\n0.132833\n-0.137775\n1.377994e-07\n0.599450\n0.528862\n0.663023\n0.646922\n0.638165\n0.355756\n0.579635\n\n\nRUS\nRussian Federation\nRussian Ruble\n2019\n4197222.5\n4.161194e+06\n145.872256\n71.670639\n1965.000000\n3.434408\n3.170826e+06\n...\n0.178951\n-0.086548\n-2.315040e-02\n0.411263\n0.573736\n0.281037\n0.576825\n0.690811\n0.466877\n0.366449\n\n\nIND\nIndia\nIndian Rupee\n2019\n8945547.0\n9.170555e+06\n1366.417754\n497.615723\n2122.940682\n2.171165\n6.608024e+06\n...\n0.051035\n-0.077878\n3.370060e-02\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.0\n7.340944e+05\n58.558270\n18.642710\n2191.363362\n2.908202\n6.236696e+05\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\n\n\n5 rows × 50 columns\n\n\n\n或者选择列指定列标签（名），效果与不使用.loc()只使用变量名效果一样。\n\nvariables = ['country', 'rgdpe', 'pop']\npwt2019.loc[:, variables]\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\nAruba\n3921.261230\n0.106314\n\n\nAGO\nAngola\n228151.015625\n31.825295\n\n\nAIA\nAnguilla\n376.634979\n0.014869\n\n\nALB\nAlbania\n35890.019531\n2.880917\n\n\nARE\nUnited Arab Emirates\n681525.812500\n9.770529\n\n\n...\n...\n...\n...\n\n\nVNM\nViet Nam\n750726.750000\n96.462106\n\n\nYEM\nYemen\n50052.933594\n29.161922\n\n\nZAF\nSouth Africa\n748940.000000\n58.558270\n\n\nZMB\nZambia\n57956.183594\n17.861030\n\n\nZWE\nZimbabwe\n42296.062500\n14.645468\n\n\n\n\n183 rows × 3 columns\n\n\n\n或者同时指定行和列：\n\npwt2019.loc[bricks, variables]\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nCHN\nChina\n20056066.0\n1433.783686\n\n\nBRA\nBrazil\n3089273.5\n211.049527\n\n\nRUS\nRussian Federation\n4197222.5\n145.872256\n\n\nIND\nIndia\n8945547.0\n1366.417754\n\n\nZAF\nSouth Africa\n748940.0\n58.558270\n\n\n\n\n\n\n\n等价于\n\npwt2019.loc[bricks][variables]\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nCHN\nChina\n20056066.0\n1433.783686\n\n\nBRA\nBrazil\n3089273.5\n211.049527\n\n\nRUS\nRussian Federation\n4197222.5\n145.872256\n\n\nIND\nIndia\n8945547.0\n1366.417754\n\n\nZAF\nSouth Africa\n748940.0\n58.558270\n\n\n\n\n\n\n\n\n\n.iloc方法\n相应的，.iloc 是使用行和列的整数位置（从 0 开始）来选择数据。这里需要注意Python中索引位置，进行切片（slicing）操作时，语法类似 [start:end]，要注意：\n\nstart：切片的起始索引，对应的元素会被包含。\nend：切片的结束索引，对应的元素不会被包含。例如：\n\n选择第2行数据（索引位置为1），结果得到一个序列:\n\npwt2019.iloc[1]\n\ncountry                 Angola\ncurrency_unit           Kwanza\nyear                      2019\nrgdpe            228151.015625\nrgdpo             227855.71875\npop                  31.825295\nemp                  16.644962\navh                        NaN\nhc                    1.481984\nccon              155943.71875\ncda              198750.421875\ncgdpe            227771.609375\ncgdpo              223289.3125\ncn                   1299231.5\nck                    0.016624\nctfp                  0.387996\ncwtfp                 0.332153\nrgdpna             222151.0625\nrconna           155270.703125\nrdana            198864.734375\nrnna                 1300951.0\nrkna                  1.005457\nrtfpna                0.936524\nrwtfpna               0.916698\nlabsh                 0.331142\nirr                    0.11585\ndelta                 0.043606\nxr                  364.825805\npl_con                0.381504\npl_da                 0.373184\npl_gdpo               0.380675\ni_cig             Extrapolated\ni_xm              Extrapolated\ni_xr              Market-based\ni_outlier              Regular\ni_irr                  Regular\nstatcap                48.8889\ncsh_c                  0.49867\ncsh_i                  0.19171\ncsh_g                 0.199723\ncsh_x                 0.344351\ncsh_m                -0.113983\ncsh_r                 -0.12047\npl_c                  0.438169\npl_i                  0.342872\npl_g                  0.240024\npl_x                  0.476486\npl_m                  0.611627\npl_n                  0.211084\npl_k                  0.396034\nName: AGO, dtype: object\n\n\n选择第1行（索引为0）、第3行（索引为2）和第5行（索引为4）\n\npwt2019.iloc[[0, 2, 4]]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\n\n\n3 rows × 50 columns\n\n\n\n选择前5行、第4至第6列观测值\n\npwt2019.iloc[:5, 3:6]\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\n3921.261230\n3467.299561\n0.106314\n\n\nAGO\n228151.015625\n227855.718750\n31.825295\n\n\nAIA\n376.634979\n225.680527\n0.014869\n\n\nALB\n35890.019531\n36103.042969\n2.880917\n\n\nARE\n681525.812500\n645956.250000\n9.770529\n\n\n\n\n\n\n\n\n\n根据条件筛选\n除了根据索引或位置选择数据外，也可以利用条件来筛选观测值。例如，根据人口变量（pop，单位：百万）选择2019年总人口超过2亿的观测值：\n\npwt2019[pwt2019['pop'] &gt;= 200]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBRA\nBrazil\nBrazilian Real\n2019\n3.089274e+06\n3.080048e+06\n211.049527\n93.956825\n1707.795058\n3.091373\n2.566911e+06\n...\n0.132833\n-0.137775\n1.377994e-07\n0.599450\n0.528862\n0.663023\n0.646922\n0.638165\n0.355756\n0.579635\n\n\nCHN\nChina\nYuan Renminbi\n2019\n2.005607e+07\n2.025766e+07\n1433.783686\n798.807739\n2168.918848\n2.698987\n1.056606e+07\n...\n0.192402\n-0.167672\n-4.100976e-03\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nIDN\nIndonesia\nRupiah\n2019\n3.104439e+06\n3.137931e+06\n270.625568\n131.170685\n2019.923395\n2.288165\n2.051190e+06\n...\n0.089377\n-0.081947\n-1.223290e-03\n0.377086\n0.359957\n0.295082\n0.601248\n0.669811\n0.215823\n0.387587\n\n\nIND\nIndia\nIndian Rupee\n2019\n8.945547e+06\n9.170555e+06\n1366.417754\n497.615723\n2122.940682\n2.171165\n6.608024e+06\n...\n0.051035\n-0.077878\n3.370060e-02\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\nNGA\nNigeria\nNaira\n2019\n9.834982e+05\n1.001537e+06\n200.963599\n73.020554\nNaN\n1.974245\n9.300954e+05\n...\n0.106134\n-0.078965\n-6.898887e-02\n0.418511\n1.166929\n0.288400\n0.507703\n0.602859\n0.788816\n0.920094\n\n\nPAK\nPakistan\nPakistan Rupee\n2019\n1.036800e+06\n1.088502e+06\n216.565318\n63.085052\n1966.907180\n1.770760\n1.023950e+06\n...\n0.040008\n-0.087298\n-2.582011e-14\n0.231672\n0.340412\n0.287822\n0.571041\n0.537927\n0.205466\nNaN\n\n\nUSA\nUnited States\nUS Dollar\n2019\n2.086051e+07\n2.059584e+07\n329.064917\n158.299591\n1765.346390\n3.749341\n1.682624e+07\n...\n0.111490\n-0.165832\n1.459136e-02\n1.005707\n0.988310\n1.266850\n0.717118\n0.752818\n1.069356\n1.000000\n\n\n\n\n7 rows × 50 columns\n\n\n\n注意，条件pwt2019['pop'] &gt;= 200 的结果是一列布林值，然后pwt2019[]选择返回取值为True的观测值。\n再例如，下面的代码包含了两个条件：\n\n国家名属于金砖国家。注意这里使用了Pandas 中的df.isin()函数；\n2019年人口超过10亿。\n\n当有不止一个条件时，我们用&, |表示and 和 or运算符；\n\nBRICKS = ['China','Brazil',  ' Russian Federation', 'India', 'South Africa']\n#\npwt2019[(pwt2019['country'].isin(BRICKS)) & (pwt2019['pop'] &gt; 1000)]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCHN\nChina\nYuan Renminbi\n2019\n20056066.0\n20257660.0\n1433.783686\n798.807739\n2168.918848\n2.698987\n10566063.0\n...\n0.192402\n-0.167672\n-0.004101\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nIND\nIndia\nIndian Rupee\n2019\n8945547.0\n9170555.0\n1366.417754\n497.615723\n2122.940682\n2.171165\n6608023.5\n...\n0.051035\n-0.077878\n0.033701\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\n\n\n2 rows × 50 columns\n\n\n\n更复杂的情况，可以在条件语句中加入数学表达式。例如，下面的代码筛选了人均实际GDP超过2万美元和人口超过5000万的国家的观测值，这里人均实际GDP是购买力平价调整后支出法衡量的实际GDP与人口的比值：\n\npwt2019[(pwt2019['rgdpe']/pwt2019['pop'] &gt; 20000) & (pwt2019['pop'] &gt; 50)]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEU\nGermany\nEuro\n2019\n4.308862e+06\n4275312.00\n83.517045\n44.795197\n1386.196834\n3.675378\n3.078229e+06\n...\n0.603715\n-0.550977\n0.000000\n0.881662\n0.850929\n1.006024\n0.701677\n0.673799\n0.822418\n0.651490\n\n\nFRA\nFrance\nEuro\n2019\n3.018885e+06\n2946958.25\n67.351247\n28.532564\n1504.912353\n3.230137\n2.233350e+06\n...\n0.274841\n-0.327385\n0.022188\n0.913003\n0.813518\n0.987091\n0.686175\n0.665962\n0.716193\n0.576515\n\n\nGBR\nUnited Kingdom\nPound Sterling\n2019\n3.118991e+06\n2989895.50\n67.530172\n32.982498\n1667.947711\n3.773596\n2.414706e+06\n...\n0.227445\n-0.346071\n0.065275\n0.992262\n0.699868\n0.912168\n0.687633\n0.668252\n0.624869\n0.796017\n\n\nITA\nItaly\nEuro\n2019\n2.508404e+06\n2466327.50\n60.550075\n25.596329\n1717.833818\n3.158385\n1.810091e+06\n...\n0.307117\n-0.292341\n0.001006\n0.846609\n0.590234\n0.969897\n0.704260\n0.657741\n0.471262\n0.585280\n\n\nJPN\nJapan\nYen\n2019\n5.028348e+06\n5036891.00\n126.860301\n69.976692\n1691.085260\n3.593987\n3.765120e+06\n...\n0.190841\n-0.190701\n0.005592\n1.048585\n1.007949\n0.932528\n0.734816\n0.751225\n1.011635\n0.788685\n\n\nKOR\nRepublic of Korea\nWon\n2019\n2.090946e+06\n2162705.25\n51.225308\n26.798534\n1979.526258\n3.765123\n1.314779e+06\n...\n0.466232\n-0.403080\n0.000459\n0.848224\n0.732208\n0.758751\n0.654067\n0.701660\n0.557140\n0.657925\n\n\nRUS\nRussian Federation\nRussian Ruble\n2019\n4.197222e+06\n4161194.50\n145.872256\n71.670639\n1965.000000\n3.434408\n3.170826e+06\n...\n0.178951\n-0.086548\n-0.023150\n0.411263\n0.573736\n0.281037\n0.576825\n0.690811\n0.466877\n0.366449\n\n\nTUR\nTurkey\nNew Turkish Lira\n2019\n2.227538e+06\n2248225.75\n83.429615\n28.087334\n1832.000000\n2.514292\n1.555716e+06\n...\n0.119963\n-0.147055\n0.066752\n0.393921\n0.313990\n0.259054\n0.671110\n0.636799\n0.207867\n0.477120\n\n\nUSA\nUnited States\nUS Dollar\n2019\n2.086051e+07\n20595844.00\n329.064917\n158.299591\n1765.346390\n3.749341\n1.682624e+07\n...\n0.111490\n-0.165832\n0.014591\n1.005707\n0.988310\n1.266850\n0.717118\n0.752818\n1.069356\n1.000000\n\n\n\n\n9 rows × 50 columns\n\n\n\n注意，当用 Pandas 进行数据筛选时，需要使用 &(|) 而不是 and(or) 来连接多个条件。\n& 和 | 是 NumPy 的按位运算符，Pandas 借用了它们来实现元素级的逻辑运算:\n\n& (按位与)：对两个布尔系列中的每个对应元素进行 AND 运算。只有当两个对应元素都为 True 时，结果才为 True。\n|(按位或)：对两个布尔系列中的每个对应元素进行 OR 运算。只要其中一个对应元素为True，结果就为 True。",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#apply-方法",
    "href": "pandas.html#apply-方法",
    "title": "Pandas 基础应用",
    "section": "apply 方法",
    "text": "apply 方法\nPandas中一个广泛应用的方法是 df.apply()，它将一个函数应用到每一行/列，返回一个序列；\n函数可以是内嵌的（built in）也可以是自定义的，例如，计算每一列的最大值，这里使用了Numpy库的max函数：\n\npwt2019_sub.apply(np.max, axis=0)\n\ncountry       Zimbabwe\nrgdpe       20860506.0\nrgdpo       20595844.0\npop        1433.783686\nemp         798.807739\ncgdpe       20791364.0\ncgdpo       20566034.0\nctfp          1.276913\ndtype: object\n\n\n或者，自定义一个函数range(x)计算极差：\n\ndef range(x):\n    return np.max(x) - np.min(x)\npwt2019_sub.select_dtypes(np.number).apply(range)\n\nrgdpe    2.086041e+07\nrgdpo    2.059577e+07\npop      1.433779e+03\nemp      7.988052e+02\ncgdpe    2.079126e+07\ncgdpo    2.056595e+07\nctfp     1.222178e+00\ndtype: float64\n\n\n再例如，归一化（normalization）经常使用minmax方法： \\[\nY = \\frac{X_{i} - \\min(X_{i})}{\\max(X_{i}) - \\min(X_{i})}\n\\]\n我们定义一个函数minmax()，然后应用apply()方法：\n\ndef minmax(S):\n    return (S-S.min())/(S.max() - S.min())\npwt2019[['pop','rgdpe', 'emp']].apply(minmax)\n\n\n\n\n\n\n\n\npop\nrgdpe\nemp\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\n0.000071\n0.000183\n0.000056\n\n\nAGO\n0.022193\n0.010932\n0.020834\n\n\nAIA\n0.000007\n0.000013\nNaN\n\n\nALB\n0.002006\n0.001716\n0.001344\n\n\nARE\n0.006811\n0.032666\n0.007269\n\n\n...\n...\n...\n...\n\n\nVNM\n0.067275\n0.035983\n0.063091\n\n\nYEM\n0.020336\n0.002395\n0.006922\n\n\nZAF\n0.040838\n0.035898\n0.023335\n\n\nZMB\n0.012454\n0.002774\n0.006538\n\n\nZWE\n0.010211\n0.002023\n0.008548\n\n\n\n\n183 rows × 3 columns\n\n\n\n经常将lambda函数方法与df.apply()方法相结合。例如，数据集中有4个指标度量GDP，分别是['rgdpe', 'rgdpo','cgdpe','cgdpo']，假设我们希望计算一个加权平均数，权重为（0.3，0.2，0.3，0.2）：\n\nvariables = ['rgdpe', 'rgdpo','cgdpe','cgdpo']\npwt2019[variables].apply(lambda row:\n    row['rgdpe']*0.3 + row['rgdpo']*0.2 + row['cgdpe']*0.3 + row['cgdpo']*0.2,\n    axis=1)\n\ncountrycode\nABW      3736.787109\nAGO    227005.796875\nAIA       318.944458\nALB     35987.785156\nARE    664187.937500\n           ...      \nVNM    739027.375000\nYEM     50759.292969\nZAF    742988.125000\nZMB     57414.339844\nZWE     41768.011719\nLength: 183, dtype: float32\n\n\n注意，选项axis = 1 ，将函数应用至每一行，默认值为0。",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#检测和处理缺失值",
    "href": "pandas.html#检测和处理缺失值",
    "title": "Pandas 基础应用",
    "section": "检测和处理缺失值",
    "text": "检测和处理缺失值\n数据集不可避免会遇到存在缺失值的情况。在@sec-reading_data 部分导入数据时，Pandas中最常用的缺失值表示是NaN（Not a Number）。可以使用isnull()或isna()函数检测缺失值，返回一个布尔型的DataFrame，其中True表示缺失值：\n\n#pwt2019.isnull()\npwt2019.isna().sum()\n\ncountry            0\ncurrency_unit      0\nyear               0\nrgdpe              0\nrgdpo              0\npop                0\nemp                6\navh              117\nhc                38\nccon               0\ncda                0\ncgdpe              0\ncgdpo              0\ncn                 3\nck                46\nctfp              65\ncwtfp             65\nrgdpna             0\nrconna             0\nrdana              0\nrnna               3\nrkna              46\nrtfpna            65\nrwtfpna           65\nlabsh             45\nirr               46\ndelta              3\nxr                 0\npl_con             0\npl_da              0\npl_gdpo            0\ni_cig              0\ni_xm               0\ni_xr               0\ni_outlier          0\ni_irr             46\nstatcap           56\ncsh_c              0\ncsh_i              0\ncsh_g              0\ncsh_x              0\ncsh_m              0\ncsh_r              0\npl_c               0\npl_i               0\npl_g               0\npl_x               0\npl_m               0\npl_n               3\npl_k              46\ndtype: int64\n\n\n下面的的代码计展示了Pandas中链式操作的强大功能，仅用一行命令实现了：\n\n计算了缺失值的数量\n除以样本容量得到缺失值比例\n按照降序排序\n并将比例最高的前15个变量绘制柱形图：\n\n\nfig, ax = plt.subplots()\n(pwt2019.isna().sum()/pwt2019.shape[0] * 100).sort_values(ascending=False)[:15].plot(kind='bar', ax=ax)\nax.set_ylabel(\"%\")\nplt.show()\n\n\n\n\n\n\n\n\n另一种图示的方法是类似矩阵绘图的方式，将缺失值标记出来，missingno库有简单的命令实现：\n\nimport missingno as msno\nfig, ax = plt.subplots(figsize=(12,6))\nmsno.matrix(pwt2019,sparkline=False, ax=ax)\nax.set_xlabel(\"Missing Values Matrix\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n删除缺失值\n处理缺失值的方法有很多种，选择哪种方法取决于你的数据特性、缺失原因以及分析目标。最直接的方法是使用df.dropna()函数删除包含缺失值的行或列：\n\n# 删除含缺失值的行\npwt2019.dropna()\n# 删除含缺失值的列\npwt2019.dropna(axis=1)\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nccon\ncda\ncgdpe\ncgdpo\n...\ncsh_i\ncsh_g\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n3023.694824\n3877.659668\n3912.334717\n3466.241943\n...\n0.246366\n0.214084\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n155943.718750\n198750.421875\n227771.609375\n223289.312500\n...\n0.191710\n0.199723\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n438.470032\n509.044983\n375.136444\n241.384537\n...\n0.292376\n0.303098\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n33399.167969\n40868.316406\n35808.343750\n36288.328125\n...\n0.205828\n0.206071\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n306771.156250\n515623.312500\n678241.187500\n635332.812500\n...\n0.328729\n0.127105\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n582677.062500\n758821.937500\n747853.750000\n723142.687500\n...\n0.243582\n0.095490\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n49266.472656\n67992.531250\n49937.042969\n51983.429688\n...\n0.360231\n0.300234\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n623669.562500\n741675.937500\n748245.937500\n735067.062500\n...\n0.160538\n0.227329\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n38698.402344\n56536.863281\n57695.066406\n56811.105469\n...\n0.313996\n0.171331\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n43961.839844\n47128.785156\n42325.117188\n41081.722656\n...\n0.077089\n0.227109\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n\n\n\n\n183 rows × 32 columns\n\n\n\n上面的命令并没有改变原数据框，可以通过赋值方式保存删除后数据，或者使用df.dropna(inplace=True)，即在原数据框中生效。\n\n\n数值填充\n数值型变量缺失值处理中最简单的是用某个值进行填充，df.fillna()是核心函数。\n在Penn World Data中有几个变量是分类变量，如i_icg, i_xm等，参见数据集Excel表中“Data information variables”的说明。如果简单使用pwt2019.fillna(0)的命令会报错。我们小需要只对数值型列的缺失值（NaN）进行填充，而其他非数值型列（如分类变量、文本等）则保持原样。下面的链式命令需要简单的说明：\n\n.select_dtypes(np.number)筛选出所有数据类型为数值型（numeric）的列变量；\n.fillna(0)对筛选后的数据框上，用0填充缺失值；\n.combine_first(pwt2019)，是整个命令中最关键的一步。combine_first 是一个强大的方法，它将两个 DataFrame 按索引和列名进行合并。它的工作原理是：\n\n对于每一个位置（即索引和列），它首先查看调用者（也就是 .fillna(0) 之后得到的那个填充了 0 的数值型 DataFrame）的值。\n如果调用者的值不是缺失值（NaN），就使用这个值。\n如果调用者的值是缺失值（NaN），它就会去使用参数 pwt2019 中对应位置的值。\n\n\n由于第一步已经将非数值型列移除了，因此在 .fillna(0) 之后的 DataFrame 中，这些被移除的列全部变成了 NaN，就会使用 pwt2019 中对应位置的值。 - 最后按照初始变量pwt2019.columns的顺序重新排列数据。\n\npwt2019.select_dtypes(np.number).fillna(0).combine_first(pwt2019)[pwt2019.columns]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\n0.000000\n0.000000\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\n0.000000\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n0.000000\n0.000000\n0.000000\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.000000\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\n0.000000\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.000000\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\n0.000000\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n0.000000\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\n0.000000\n1.842989\n49266.472656\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n0.000000\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\n0.000000\n2.686845\n38698.402344\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\n0.000000\n2.713408\n43961.839844\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 50 columns\n\n\n\n除了0值外，常使用平均值或中位数来进行数值填充。下面的命令在计算均值/中位数时，使用了numeric_only=True参数只对数值型变量进行操作：\n\npwt2019.select_dtypes(np.number).fillna(pwt2019.mean(numeric_only=True)).combine_first(pwt2019)\n# pwt2019.select_dtypes(np.number).fillna(pwt2019.median(numeric_only=True)).combine_first(pwt2019)\n\n\n\n\n\n\n\n\navh\nccon\ncda\ncgdpe\ncgdpo\nck\ncn\ncountry\ncsh_c\ncsh_g\n...\nrgdpe\nrgdpna\nrgdpo\nrkna\nrnna\nrtfpna\nrwtfpna\nstatcap\nxr\nyear\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1849.981084\n3023.694824\n3877.659668\n3912.334717\n3466.241943\n0.000209\n1.742797e+04\nAruba\n0.658242\n0.214084\n...\n3921.261230\n3068.758301\n3467.299561\n1.032467\n1.739027e+04\n0.989679\n0.994500\n67.279097\n1.790000\n2019\n\n\nAGO\n1849.981084\n155943.718750\n198750.421875\n227771.609375\n223289.312500\n0.016624\n1.299232e+06\nAngola\n0.498670\n0.199723\n...\n228151.015625\n222151.062500\n227855.718750\n1.005457\n1.300951e+06\n0.936524\n0.916698\n48.888900\n364.825805\n2019\n\n\nAIA\n1849.981084\n438.470032\n509.044983\n375.136444\n241.384537\n0.046314\n2.266816e+03\nAnguilla\n1.513381\n0.303098\n...\n376.634979\n223.456711\n225.680527\n1.079724\n2.260053e+03\n0.989679\n0.994500\n67.279097\n2.700000\n2019\n\n\nALB\n1849.981084\n33399.167969\n40868.316406\n35808.343750\n36288.328125\n0.046314\n2.239714e+05\nAlbania\n0.714312\n0.206071\n...\n35890.019531\n37204.773438\n36103.042969\n1.079724\n2.226235e+05\n0.989679\n0.994500\n78.888900\n109.850833\n2019\n\n\nARE\n1849.981084\n306771.156250\n515623.312500\n678241.187500\n635332.812500\n0.046314\n4.453746e+06\nUnited Arab Emirates\n0.355746\n0.127105\n...\n681525.812500\n647986.250000\n645956.250000\n1.079724\n4.454460e+06\n0.989679\n0.994500\n67.279097\n3.672500\n2019\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2131.968232\n582677.062500\n758821.937500\n747853.750000\n723142.687500\n0.046314\n1.962286e+06\nViet Nam\n0.710267\n0.095490\n...\n750726.750000\n741653.562500\n724123.375000\n1.079724\n1.964750e+06\n0.989679\n0.994500\n78.888900\n23050.241667\n2019\n\n\nYEM\n1849.981084\n49266.472656\n67992.531250\n49937.042969\n51983.429688\n0.046314\n5.312318e+05\nYemen\n0.647500\n0.300234\n...\n50052.933594\n40069.593750\n51828.058594\n1.079724\n5.404372e+05\n0.989679\n0.994500\n38.888867\n250.250000\n2019\n\n\nZAF\n2191.363362\n623669.562500\n741675.937500\n748245.937500\n735067.062500\n0.033228\n2.816883e+06\nSouth Africa\n0.621124\n0.227329\n...\n748940.000000\n732851.625000\n734094.375000\n1.036546\n2.811258e+06\n0.965773\n0.972355\n75.555567\n14.448427\n2019\n\n\nZMB\n1849.981084\n38698.402344\n56536.863281\n57695.066406\n56811.105469\n0.004523\n2.841112e+05\nZambia\n0.509846\n0.171331\n...\n57956.183594\n56282.273438\n56783.714844\n1.117712\n2.851388e+05\n0.955966\n0.921073\n55.555567\n12.889418\n2019\n\n\nZWE\n1849.981084\n43961.839844\n47128.785156\n42325.117188\n41081.722656\n0.000733\n5.939553e+04\nZimbabwe\n0.842998\n0.227109\n...\n42296.062500\n42694.070312\n40826.570312\n1.055221\n5.974304e+04\n0.910977\n0.902522\n56.666633\n1.000000\n2019\n\n\n\n\n183 rows × 50 columns\n\n\n\n也可以使用向后填充（backward fill），即用一个观测值向其后面（更低索引位置）的缺失值来填充这个缺失值；或向前填充（forward fill）\n\n#pwt2019.fillna(method='ffill')\npwt2019.fillna(method='bfill')\n\nC:\\Users\\admin\\AppData\\Local\\Temp\\ipykernel_1736\\1604694572.py:2: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n  pwt2019.fillna(method='bfill')\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\n1609.068998\n1.481984\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\n1609.068998\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n1.075898\n1609.068998\n2.964992\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.793385\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\n1609.068998\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.793385\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\n1609.068998\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.793385\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n0.525546\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\n2191.363362\n1.842989\n49266.472656\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n0.525546\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\nNaN\n2.686845\n38698.402344\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 50 columns\n\n\n\n另外，.fillna()函数可以根据定义的字典，不同的列用不同的值填充。\n\nvalues = {\"pop\":0.01, 'emp':0.005, \"ctfp\": 0.1,}\npwt2019_sub.fillna(values)\n\n\n\n\n\n\n\n\ncountry\nrgdpe\nrgdpo\npop\nemp\ncgdpe\ncgdpo\nctfp\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\n3921.261230\n3467.299561\n0.106314\n0.047601\n3912.334717\n3466.241943\n0.100000\n\n\nAGO\nAngola\n228151.015625\n227855.718750\n31.825295\n16.644962\n227771.609375\n223289.312500\n0.387996\n\n\nAIA\nAnguilla\n376.634979\n225.680527\n0.014869\n0.005000\n375.136444\n241.384537\n0.100000\n\n\nALB\nAlbania\n35890.019531\n36103.042969\n2.880917\n1.075898\n35808.343750\n36288.328125\n0.100000\n\n\nARE\nUnited Arab Emirates\n681525.812500\n645956.250000\n9.770529\n5.808834\n678241.187500\n635332.812500\n0.100000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\n750726.750000\n724123.375000\n96.462106\n50.399563\n747853.750000\n723142.687500\n0.100000\n\n\nYEM\nYemen\n50052.933594\n51828.058594\n29.161922\n5.531877\n49937.042969\n51983.429688\n0.100000\n\n\nZAF\nSouth Africa\n748940.000000\n734094.375000\n58.558270\n18.642710\n748245.937500\n735067.062500\n0.547630\n\n\nZMB\nZambia\n57956.183594\n56783.714844\n17.861030\n5.225448\n57695.066406\n56811.105469\n0.261406\n\n\nZWE\nZimbabwe\n42296.062500\n40826.570312\n14.645468\n6.831017\n42325.117188\n41081.722656\n0.374524\n\n\n\n\n183 rows × 8 columns\n\n\n\n\n\n插值法（Interpolation）\n除了填充给定值以外，也有更复杂的插值法。例如线性插值法。\n\n\n\n\n\n\nFigure 1: 线性插值法\n\n\n\n假设已知两个点 \\((x_{0},y_{0})\\) 和 \\(x_{1}, y_{1}\\)，线性插值法意味着满足方程： \\[\n\\frac{y-y_{0}}{x-x_{0}} = \\frac{y_{1}-y_{0}}{x_{1}-x_{0}}\n\\]\n\ns = pd.Series([0, 1, np.nan, 3])\ns.interpolate()\n\n0    0.0\n1    1.0\n2    2.0\n3    3.0\ndtype: float64\n\n\n将其应用至数值型变量：\n\npwt2019.select_dtypes(np.number).interpolate(method=\"linear\")\n\n\n\n\n\n\n\n\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n3877.659668\n3912.334717\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n198750.421875\n227771.609375\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\n2019\n376.634979\n225.680527\n0.014869\n8.860430\nNaN\n2.223488\n438.470032\n509.044983\n375.136444\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.495372\n\n\nALB\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n40868.316406\n35808.343750\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.594710\n\n\nARE\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n515623.312500\n678241.187500\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.694047\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n758821.937500\n747853.750000\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n1.485950\n\n\nYEM\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\n2161.665797\n1.842989\n49266.472656\n67992.531250\n49937.042969\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n1.005748\n\n\nZAF\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n741675.937500\n748245.937500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nZMB\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\n2191.363362\n2.686845\n38698.402344\n56536.863281\n57695.066406\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZWE\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\n2191.363362\n2.713408\n43961.839844\n47128.785156\n42325.117188\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 43 columns\n\n\n\n\n\n应用：长期经济增长\nMaddison Project Database 2023是基于经济史学家Angus Maddison 的研究构建的长期经济增长数据库，主要包含人均GDP（gdppc）和人口（pop）数据，最早至公元1年，中间有大量的缺失值。\n我们下载并载入数据，来绘制一幅：\n\nmpd = pd.read_excel(\"datasets/mpd2023_web.xlsx\", sheet_name=\"Full data\")\ngdp_pc = mpd.set_index(['countrycode', 'year'])['gdppc'].unstack('countrycode')\ngdp_pc.tail()\n\n\n\n\n\n\n\ncountrycode\nAFG\nAGO\nALB\nARE\nARG\nARM\nAUS\nAUT\nAZE\nBDI\n...\nURY\nUSA\nUZB\nVEN\nVNM\nYEM\nYUG\nZAF\nZMB\nZWE\n\n\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2018\n1888.813928\n7180.355235\n11426.920105\n74206.484938\n18460.869009\n11490.368687\n49614.385976\n43032.216404\n16753.209691\n730.904598\n...\n19697.759966\n55454.669438\n10682.417894\n9446.187715\n6842.138813\n2281.544865\n16824.553739\n11873.299868\n3521.505006\n1900.199191\n\n\n2019\n2031.737349\n6886.954136\n11715.306318\n74396.143863\n17912.635765\n12399.231837\n49814.669956\n43488.668121\n17029.906374\n738.983078\n...\n19714.148949\n56469.263659\n11219.242900\n7061.761533\n7266.048396\n2265.343020\n17524.212183\n11739.935508\n3466.236413\n1753.024449\n\n\n2020\n1928.454683\n6279.929085\n11372.541421\n70188.272728\n15975.838773\n11546.175310\n48268.945077\n40503.040806\n16189.511047\n720.445974\n...\n18460.038349\n54379.206512\n11341.919402\n4952.529595\n7395.361527\n2031.443613\n16757.938552\n10839.133081\n3270.599223\n1585.972804\n\n\n2021\n1485.547006\n6137.003845\n12455.916554\n72460.040688\n17470.682415\n12242.477472\n50704.934853\n42184.696121\n16971.724515\n723.192074\n...\n19222.295835\n57522.704626\n12076.091577\n4896.801879\n7507.758707\n1972.210254\n18491.681774\n11273.159112\n3321.594496\n1687.253154\n\n\n2022\n1357.987823\n6118.904897\n12978.100729\n77203.670241\n18292.317825\n13837.577589\n52049.427952\n43792.856400\n17682.940199\n717.228429\n...\n20181.939663\n58487.465861\n12559.401550\n5267.175305\n8050.358831\n1959.319498\n19352.383894\n11415.886895\n3342.421325\n1703.529373\n\n\n\n\n5 rows × 169 columns\n\n\n\n由于中间有缺失值，绘制的图形出现大段的空白，因此，我们用线性插值法补充，用虚线表示：\n\ncountries = ['CHN', 'GBR', 'USA']\ncolors = ['blue','red','green']\nfig, ax = plt.subplots()\nfor country, color in zip(countries, colors):\n    ax.plot(gdp_pc[country], linewidth = 2,\n        label = country,\n        color = color)\n    ax.plot(gdp_pc[country].interpolate(),\n            linestyle = '--',\n            lw=2, color = color)\nax.set_title(\"GDP per Capita, 1000- (China, UK, USA)\")\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n更复杂的方法涉及到模型估计问题，如KNN预测等。Scikit-learn库有专门的方法，这里就不多涉及。\n\nfrom sklearn.impute import SimpleImputer\nimputer_mean = SimpleImputer(strategy='mean')\npd.DataFrame(imputer_mean.fit_transform(pwt2019.select_dtypes(np.number)), columns=pwt2019.select_dtypes(np.number).columns)\n\n\n\n\n\n\n\n\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\n\n\n0\n2019.0\n3921.261230\n3467.299561\n0.106314\n0.047601\n1849.981084\n2.709271\n3023.694824\n3877.659668\n3912.334717\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\n1\n2019.0\n228151.015625\n227855.718750\n31.825295\n16.644962\n1849.981084\n1.481984\n155943.718750\n198750.421875\n227771.609375\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\n2\n2019.0\n376.634979\n225.680527\n0.014869\n18.736708\n1849.981084\n2.709271\n438.470032\n509.044983\n375.136444\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.835094\n\n\n3\n2019.0\n35890.019531\n36103.042969\n2.880917\n1.075898\n1849.981084\n2.964992\n33399.167969\n40868.316406\n35808.343750\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.835094\n\n\n4\n2019.0\n681525.812500\n645956.250000\n9.770529\n5.808834\n1849.981084\n2.746695\n306771.156250\n515623.312500\n678241.187500\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.835094\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n178\n2019.0\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n758821.937500\n747853.750000\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n0.835094\n\n\n179\n2019.0\n50052.933594\n51828.058594\n29.161922\n5.531877\n1849.981084\n1.842989\n49266.472656\n67992.531250\n49937.042969\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n0.835094\n\n\n180\n2019.0\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n741675.937500\n748245.937500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\n181\n2019.0\n57956.183594\n56783.714844\n17.861030\n5.225448\n1849.981084\n2.686845\n38698.402344\n56536.863281\n57695.066406\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\n182\n2019.0\n42296.062500\n40826.570312\n14.645468\n6.831017\n1849.981084\n2.713408\n43961.839844\n47128.785156\n42325.117188\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 43 columns",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#异常值",
    "href": "pandas.html#异常值",
    "title": "Pandas 基础应用",
    "section": "异常值",
    "text": "异常值\n异常值的存在可能对数据运算结果产生较大的影响。\n\n异常值的检测\n可以计算统计量或图形的方法来检测是否存在异常值。这里介绍常用的Z-Score方法： \\[\nZ = \\frac{x - \\mu}{\\sigma}\n\\]\n它度量了一个数据点与均值之间以标准差为单位的距离，当数据近似正态分布的时候适合使用。将Z-Score超过某个阈值（如2或3）的数据点，视为异常值。\n如果是对数据框操作，可以应用apply()函数：\n\npd.options.display.float_format = '{:.3f}'.format\nzscore = pwt2019.select_dtypes(np.number).apply(lambda x: (x-x.mean(axis=0))/x.std(axis=0))\npwt2019[zscore['pop']&gt;3]['pop']\n\ncountrycode\nCHN   1433.784\nIND   1366.418\nName: pop, dtype: float64\n\n\n另外一种方法是根据四分位距（Interquartile Range，IQR），令 \\(IQR = Q_{3} - Q_{1}\\)，在 \\(Q_{1} - 1.5\\cdot IQR\\) 或 \\(Q_{3} + 1.5\\cdot IQR\\) 范围之外的数据点是异常值。\n\ndef iqr_outlier(ser):\n    Q1 = ser.quantile(0.25)\n    Q3 = ser.quantile(0.75)\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    outlier = (ser &lt; lower_bound) | (ser &gt; upper_bound)\n    return outlier\n\npwt2019[iqr_outlier(pwt2019['pop'])][['country', 'pop']]\n\n\n\n\n\n\n\n\ncountry\npop\n\n\ncountrycode\n\n\n\n\n\n\nBGD\nBangladesh\n163.046\n\n\nBRA\nBrazil\n211.050\n\n\nCHN\nChina\n1433.784\n\n\nCOD\nD.R. of the Congo\n86.791\n\n\nDEU\nGermany\n83.517\n\n\nEGY\nEgypt\n100.388\n\n\nETH\nEthiopia\n112.079\n\n\nIDN\nIndonesia\n270.626\n\n\nIND\nIndia\n1366.418\n\n\nIRN\nIran (Islamic Republic of)\n82.914\n\n\nJPN\nJapan\n126.860\n\n\nMEX\nMexico\n127.576\n\n\nNGA\nNigeria\n200.964\n\n\nPAK\nPakistan\n216.565\n\n\nPHL\nPhilippines\n108.117\n\n\nRUS\nRussian Federation\n145.872\n\n\nTUR\nTurkey\n83.430\n\n\nUSA\nUnited States\n329.065\n\n\nVNM\nViet Nam\n96.462\n\n\n\n\n\n\n\n通常IQR方法是采用箱形图的形式展示的，如图所示，位于 \\(Q_{3}\\) 上方1.5倍IQR的观测值，以散点的形式展现出来。\n\nfig, ax = plt.subplots()\nax.boxplot(x=pwt2019['pop'])\nplt.show()\n\n\n\n\n\n\n\n\n\n\n缩尾处理\n应用中，常需要对异常值进行一定的处理，其中一种方法是缩尾处理（Winsorize），将极端值替换为某个百分位数的值，例如，将上限设为 99 百分位数，下限设为 1 百分位数。\n可以使用df.clip()函数实现，例如全要素生产率水平ctfp：\n\nq95 = pwt2019['ctfp'].quantile(0.95)\nq05 = pwt2019['ctfp'].quantile(0.05)\n\npwt2019['ctfp'].dropna().clip(lower=q05, upper=q95, inplace=False)\n\ncountrycode\nAGO   0.388\nARG   0.829\nARM   0.838\nAUS   0.838\nAUT   0.829\n       ... \nUSA   1.000\nVEN   0.267\nZAF   0.548\nZMB   0.267\nZWE   0.375\nName: ctfp, Length: 118, dtype: float32",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#观测值排序",
    "href": "pandas.html#观测值排序",
    "title": "Pandas 基础应用",
    "section": "观测值排序",
    "text": "观测值排序\n有时候需要对数据集进行一定的排序，Pandas中可以按索引(df.sort_index)和值（df.sort_values）排序。\n\n根据索引排序\n例如，将索引按降序排序，这里的索引是国家代码，因此升序/降序是按照字母顺序：\n\npwt2019.sort_index(ascending=False)\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\nZMB\nZambia\nKwacha\n2019\n57956.184\n56783.715\n17.861\n5.225\nNaN\n2.687\n38698.402\n...\n0.215\n-0.239\n0.028\n0.373\n0.482\n0.330\n0.574\n0.532\n0.295\n0.360\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000\n734094.375\n58.558\n18.643\n2191.363\n2.908\n623669.562\n...\n0.184\n-0.198\n0.005\n0.464\n0.524\n0.448\n0.660\n0.605\n0.315\n0.526\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.934\n51828.059\n29.162\n5.532\nNaN\n1.843\n49266.473\n...\n0.001\n-0.135\n-0.173\n0.778\n0.239\n0.212\n0.633\n0.671\n0.175\nNaN\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750\n724123.375\n96.462\n50.400\n2131.968\n2.870\n582677.062\n...\n0.526\n-0.518\n-0.057\n0.348\n0.399\n0.245\n0.696\n0.677\n0.250\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812\n645956.250\n9.771\n5.809\nNaN\n2.747\n306771.156\n...\n0.890\n-0.701\n-0.000\n0.725\n0.481\n0.692\n0.689\n0.647\n0.270\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.020\n36103.043\n2.881\n1.076\nNaN\n2.965\n33399.168\n...\n0.127\n-0.314\n0.061\n0.473\n0.457\n0.236\n0.630\n0.525\n0.301\nNaN\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.635\n225.681\n0.015\nNaN\nNaN\nNaN\n438.470\n...\n1.480\n-2.446\n-0.143\n1.065\n1.029\n0.732\n0.769\n0.603\n0.898\nNaN\n\n\nAGO\nAngola\nKwanza\n2019\n228151.016\n227855.719\n31.825\n16.645\nNaN\n1.482\n155943.719\n...\n0.344\n-0.114\n-0.120\n0.438\n0.343\n0.240\n0.476\n0.612\n0.211\n0.396\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261\n3467.300\n0.106\n0.048\nNaN\nNaN\n3023.695\n...\n0.973\n-1.092\n0.000\n0.883\n0.816\n0.744\n0.707\n0.623\n0.805\n0.648\n\n\n\n\n183 rows × 50 columns\n\n\n\n\n\n根据值排序\n来看df.sort_values的例子，假设我们希望按2019年的人均GDP（PPP链式调整后）降序（令ascending=False）排列：\n\npwt2019['rgdp_per'] = pwt2019['rgdpe']/pwt2019['pop']\npwt2019.sort_values(by='rgdp_per', ascending=False) \n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\nrgdp_per\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLUX\nLuxembourg\nEuro\n2019\n69541.328\n55710.793\n0.616\n0.461\n1505.559\n3.620\n27761.588\n...\n-0.635\n0.472\n1.068\n0.746\n1.494\n0.699\n0.635\n0.680\n1.278\n112941.453\n\n\nMAC\nChina, Macao SAR\nPataca\n2019\n67463.125\n59874.164\n0.640\n0.388\nNaN\n2.962\n23970.996\n...\n-0.288\n0.705\n0.786\n0.793\n0.848\n0.709\n0.695\n0.575\n2.026\n105337.890\n\n\nQAT\nQatar\nQatari Rial\n2019\n292963.531\n323141.156\n2.832\n2.084\nNaN\n3.259\n86421.289\n...\n-0.144\n-0.101\n0.887\n0.496\n0.891\n0.527\n0.649\n0.333\n0.602\n103445.127\n\n\nIRL\nIreland\nEuro\n2019\n499741.094\n501053.594\n4.882\n2.260\n1771.978\n3.186\n149572.484\n...\n-0.339\n-0.045\n1.094\n0.648\n1.103\n0.671\n0.603\n0.557\n0.924\n102353.631\n\n\nSGP\nSingapore\nSingapore Dollar\n2019\n514376.312\n477907.875\n5.804\n3.760\n2330.166\n4.352\n229661.500\n...\n-1.117\n0.205\n0.762\n0.687\n0.709\n0.712\n0.673\n0.465\n0.947\n88619.305\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nMWI\nMalawi\nKwacha\n2019\n20362.393\n21635.066\n18.629\n7.950\nNaN\n2.039\n20989.887\n...\n-0.242\n0.078\n0.363\n0.653\n0.380\n0.620\n0.560\n0.474\nNaN\n1093.063\n\n\nCOD\nD.R. of the Congo\nFranc Congolais\n2019\n89061.672\n88673.375\n86.791\n25.140\nNaN\n1.679\n78981.922\n...\n-0.098\n-0.059\n0.460\n0.950\n0.540\n0.647\n0.657\n0.621\nNaN\n1026.168\n\n\nCAF\nCentral African Republic\nCFA Franc BEAC\n2019\n4532.561\n4642.449\n4.745\n1.844\nNaN\n1.562\n5007.588\n...\n-0.132\n-0.126\n0.496\n0.670\n0.333\n0.686\n0.632\n0.376\n0.637\n955.192\n\n\nBDI\nBurundi\nBurundi Franc\n2019\n8664.988\n9109.688\n11.531\n5.004\nNaN\n1.417\n9894.192\n...\n-0.252\n0.008\n0.330\n0.543\n0.304\n0.650\n0.476\n0.351\n0.513\n751.479\n\n\nVEN\nVenezuela (Bolivarian Republic of)\nBolivar Fuerte\n2019\n7166.572\n7160.107\n28.516\n11.694\nNaN\n2.893\n9266.067\n...\n-0.001\n-0.403\n18.144\n34.445\n14.176\n0.581\n0.646\n20.695\n12.002\n251.319\n\n\n\n\n183 rows × 51 columns",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#数据集合并",
    "href": "pandas.html#数据集合并",
    "title": "Pandas 基础应用",
    "section": "数据集合并",
    "text": "数据集合并\n在Pandas中，数据集合并是一个非常常见的操作，它允许你将多个DataFrame或Series根据某种关系组合成一个新的数据结构。Pandas提供了几个强大的函数来处理数据合并，如 Table 1 所示，它们各有侧重，适用于不同的场景，更多详细内容参见官方文档Merge, join, concatenate and compare。\n\n\n\nTable 1: 数据集的合并\n\n\n\n\n\n\n\n\n\n\n\n\n函数\n主要功能\n默认连接方式\n主要对齐方式\n典型用途\n\n\n\n\nconcat()\n按轴堆叠，合并\n按行（axis=0），outer\n索引\n拼接多个DataFrame，例如将多个文件的数据读入后合并\n\n\nmerge()\n根据键连接\ninner\n键（列名）\n根据共同的列将两个或多个DataFrame关联起来，类似于SQL JOIN\n\n\n.join()\n根据索引连接\nleft\n索引\n基于索引的快速连接，通常用于连接有相同索引的数据集\n\n\n\n\n\n\n\npd.concat()\nconcat() 函数主要用于按轴（行或列）堆叠数据，它不对数据进行智能对齐，而是简单地将两个或多个DataFrame或Series沿着指定的轴拼接起来。\n\nbricks = ['CHN', 'BRA', 'RUS', 'IND', 'ZAF']\neurope = ['GBR', 'NOR', 'SWE','ESP']\nasia = ['JPN','KOR','SGP']\nvariables = ['country', 'rgdpe', 'pop']\n\ndf1 = pwt2019.loc[bricks, variables]\ndf2 = pwt2019.loc[europe, variables]\ndf3 = pwt2019.loc[asia, variables]\n\npd.concat([df1, df2, df3])\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nCHN\nChina\n20056066.000\n1433.784\n\n\nBRA\nBrazil\n3089273.500\n211.050\n\n\nRUS\nRussian Federation\n4197222.500\n145.872\n\n\nIND\nIndia\n8945547.000\n1366.418\n\n\nZAF\nSouth Africa\n748940.000\n58.558\n\n\nGBR\nUnited Kingdom\n3118991.250\n67.530\n\n\nNOR\nNorway\n336415.406\n5.379\n\n\nSWE\nSweden\n560960.500\n10.036\n\n\nESP\nSpain\n1932678.625\n46.737\n\n\nJPN\nJapan\n5028348.000\n126.860\n\n\nKOR\nRepublic of Korea\n2090945.875\n51.225\n\n\nSGP\nSingapore\n514376.312\n5.804\n\n\n\n\n\n\n\n默认是按列堆叠，即axis=0。\n\nvariables2 = ['emp','avh']\ndf4 = pwt2019.loc[bricks, variables2]\npd.concat([df1, df4], axis=1)\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\nemp\navh\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\nCHN\nChina\n20056066.000\n1433.784\n798.808\n2168.919\n\n\nBRA\nBrazil\n3089273.500\n211.050\n93.957\n1707.795\n\n\nRUS\nRussian Federation\n4197222.500\n145.872\n71.671\n1965.000\n\n\nIND\nIndia\n8945547.000\n1366.418\n497.616\n2122.941\n\n\nZAF\nSouth Africa\n748940.000\n58.558\n18.643\n2191.363\n\n\n\n\n\n\n\n\n\nMerge\n实际应用中，数据可能来自不同的来源，经常需要合并数据集。pd.merge()函数是最常用和最强大的合并函数，用于根据一个或多个键（列或索引）将两个DataFrame连接起来。\n\nhelp(pd.merge)\n\nHelp on function merge in module pandas.core.reshape.merge:\n\nmerge(\n    left: 'DataFrame | Series',\n    right: 'DataFrame | Series',\n    how: 'MergeHow' = 'inner',\n    on: 'IndexLabel | AnyArrayLike | None' = None,\n    left_on: 'IndexLabel | AnyArrayLike | None' = None,\n    right_on: 'IndexLabel | AnyArrayLike | None' = None,\n    left_index: 'bool' = False,\n    right_index: 'bool' = False,\n    sort: 'bool' = False,\n    suffixes: 'Suffixes' = ('_x', '_y'),\n    copy: 'bool | None' = None,\n    indicator: 'str | bool' = False,\n    validate: 'str | None' = None\n) -&gt; 'DataFrame'\n    Merge DataFrame or named Series objects with a database-style join.\n\n    A named Series object is treated as a DataFrame with a single named column.\n\n    The join is done on columns or indexes. If joining columns on\n    columns, the DataFrame indexes *will be ignored*. Otherwise if joining indexes\n    on indexes or indexes on a column or columns, the index will be passed on.\n    When performing a cross merge, no column specifications to merge on are\n    allowed.\n\n    .. warning::\n\n        If both key columns contain rows where the key is a null value, those\n        rows will be matched against each other. This is different from usual SQL\n        join behaviour and can lead to unexpected results.\n\n    Parameters\n    ----------\n    left : DataFrame or named Series\n    right : DataFrame or named Series\n        Object to merge with.\n    how : {'left', 'right', 'outer', 'inner', 'cross'}, default 'inner'\n        Type of merge to be performed.\n\n        * left: use only keys from left frame, similar to a SQL left outer join;\n          preserve key order.\n        * right: use only keys from right frame, similar to a SQL right outer join;\n          preserve key order.\n        * outer: use union of keys from both frames, similar to a SQL full outer\n          join; sort keys lexicographically.\n        * inner: use intersection of keys from both frames, similar to a SQL inner\n          join; preserve the order of the left keys.\n        * cross: creates the cartesian product from both frames, preserves the order\n          of the left keys.\n    on : label or list\n        Column or index level names to join on. These must be found in both\n        DataFrames. If `on` is None and not merging on indexes then this defaults\n        to the intersection of the columns in both DataFrames.\n    left_on : label or list, or array-like\n        Column or index level names to join on in the left DataFrame. Can also\n        be an array or list of arrays of the length of the left DataFrame.\n        These arrays are treated as if they are columns.\n    right_on : label or list, or array-like\n        Column or index level names to join on in the right DataFrame. Can also\n        be an array or list of arrays of the length of the right DataFrame.\n        These arrays are treated as if they are columns.\n    left_index : bool, default False\n        Use the index from the left DataFrame as the join key(s). If it is a\n        MultiIndex, the number of keys in the other DataFrame (either the index\n        or a number of columns) must match the number of levels.\n    right_index : bool, default False\n        Use the index from the right DataFrame as the join key. Same caveats as\n        left_index.\n    sort : bool, default False\n        Sort the join keys lexicographically in the result DataFrame. If False,\n        the order of the join keys depends on the join type (how keyword).\n    suffixes : list-like, default is (\"_x\", \"_y\")\n        A length-2 sequence where each element is optionally a string\n        indicating the suffix to add to overlapping column names in\n        `left` and `right` respectively. Pass a value of `None` instead\n        of a string to indicate that the column name from `left` or\n        `right` should be left as-is, with no suffix. At least one of the\n        values must not be None.\n    copy : bool, default True\n        If False, avoid copy if possible.\n\n        .. note::\n            The `copy` keyword will change behavior in pandas 3.0.\n            `Copy-on-Write\n            &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;`__\n            will be enabled by default, which means that all methods with a\n            `copy` keyword will use a lazy copy mechanism to defer the copy and\n            ignore the `copy` keyword. The `copy` keyword will be removed in a\n            future version of pandas.\n\n            You can already get the future behavior and improvements through\n            enabling copy on write ``pd.options.mode.copy_on_write = True``\n    indicator : bool or str, default False\n        If True, adds a column to the output DataFrame called \"_merge\" with\n        information on the source of each row. The column can be given a different\n        name by providing a string argument. The column will have a Categorical\n        type with the value of \"left_only\" for observations whose merge key only\n        appears in the left DataFrame, \"right_only\" for observations\n        whose merge key only appears in the right DataFrame, and \"both\"\n        if the observation's merge key is found in both DataFrames.\n\n    validate : str, optional\n        If specified, checks if merge is of specified type.\n\n        * \"one_to_one\" or \"1:1\": check if merge keys are unique in both\n          left and right datasets.\n        * \"one_to_many\" or \"1:m\": check if merge keys are unique in left\n          dataset.\n        * \"many_to_one\" or \"m:1\": check if merge keys are unique in right\n          dataset.\n        * \"many_to_many\" or \"m:m\": allowed, but does not result in checks.\n\n    Returns\n    -------\n    DataFrame\n        A DataFrame of the two merged objects.\n\n    See Also\n    --------\n    merge_ordered : Merge with optional filling/interpolation.\n    merge_asof : Merge on nearest keys.\n    DataFrame.join : Similar method using indices.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df1 = pd.DataFrame({'lkey': ['foo', 'bar', 'baz', 'foo'],\n    ...                     'value': [1, 2, 3, 5]})\n    &gt;&gt;&gt; df2 = pd.DataFrame({'rkey': ['foo', 'bar', 'baz', 'foo'],\n    ...                     'value': [5, 6, 7, 8]})\n    &gt;&gt;&gt; df1\n        lkey value\n    0   foo      1\n    1   bar      2\n    2   baz      3\n    3   foo      5\n    &gt;&gt;&gt; df2\n        rkey value\n    0   foo      5\n    1   bar      6\n    2   baz      7\n    3   foo      8\n\n    Merge df1 and df2 on the lkey and rkey columns. The value columns have\n    the default suffixes, _x and _y, appended.\n\n    &gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey')\n      lkey  value_x rkey  value_y\n    0  foo        1  foo        5\n    1  foo        1  foo        8\n    2  bar        2  bar        6\n    3  baz        3  baz        7\n    4  foo        5  foo        5\n    5  foo        5  foo        8\n\n    Merge DataFrames df1 and df2 with specified left and right suffixes\n    appended to any overlapping columns.\n\n    &gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey',\n    ...           suffixes=('_left', '_right'))\n      lkey  value_left rkey  value_right\n    0  foo           1  foo            5\n    1  foo           1  foo            8\n    2  bar           2  bar            6\n    3  baz           3  baz            7\n    4  foo           5  foo            5\n    5  foo           5  foo            8\n\n    Merge DataFrames df1 and df2, but raise an exception if the DataFrames have\n    any overlapping columns.\n\n    &gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey', suffixes=(False, False))\n    Traceback (most recent call last):\n    ...\n    ValueError: columns overlap but no suffix specified:\n        Index(['value'], dtype='object')\n\n    &gt;&gt;&gt; df1 = pd.DataFrame({'a': ['foo', 'bar'], 'b': [1, 2]})\n    &gt;&gt;&gt; df2 = pd.DataFrame({'a': ['foo', 'baz'], 'c': [3, 4]})\n    &gt;&gt;&gt; df1\n          a  b\n    0   foo  1\n    1   bar  2\n    &gt;&gt;&gt; df2\n          a  c\n    0   foo  3\n    1   baz  4\n\n    &gt;&gt;&gt; df1.merge(df2, how='inner', on='a')\n          a  b  c\n    0   foo  1  3\n\n    &gt;&gt;&gt; df1.merge(df2, how='left', on='a')\n          a  b  c\n    0   foo  1  3.0\n    1   bar  2  NaN\n\n    &gt;&gt;&gt; df1 = pd.DataFrame({'left': ['foo', 'bar']})\n    &gt;&gt;&gt; df2 = pd.DataFrame({'right': [7, 8]})\n    &gt;&gt;&gt; df1\n        left\n    0   foo\n    1   bar\n    &gt;&gt;&gt; df2\n        right\n    0   7\n    1   8\n\n    &gt;&gt;&gt; df1.merge(df2, how='cross')\n       left  right\n    0   foo      7\n    1   foo      8\n    2   bar      7\n    3   bar      8\n\n\n\n其典型语法：\npd.merge(left, right, on=None, how='inner')\n\nleft, right: 要合并的两个DataFrame。\non: 用于合并的键，可以是列名或列名列表。如果未指定，merge 会自动寻找两个DataFrame中同名的列作为键。如果合并的键不同，可以设定:\n\nleft_on：左DataFrame合并的键；\nright_on：右DataFrame合并的键；\nleft_index:使用左DataFrame的索引为合并的键；\nright_index：使用右DataFrame的索引为合并的键\n\nhow: 指定合并类型，如图 Figure 2 所示：\n\n‘inner’（默认）：内连接，只保留两个DataFrame中键都存在的数据。\n‘outer’: 外连接，保留所有键，缺失值用NaN填充。\n‘left’: 左连接，保留左DataFrame的所有键，右DataFrame中没有对应键的数据用NaN填充。\n‘right’: 右连接，保留右DataFrame的所有键，左DataFrame中没有对应键的数据用NaN填充。\n\n\n\n\n\n\n\n\nFigure 2: Merge 方法示意图\n\n\n\nPWT数据是经过购买力平价调整后的数据，假如我们还需要其他的跨国数据，如通货膨胀率、霍比增长速度等，我们就需要与其他数据集合并。\n首先我们从世界银行数据库下载 Inflation, GDP deflator (annual %)、Broad money growth (annual %)， 两个变量：\n\n# import wbgapi as wb\n# df_wb = wb.data.DataFrame(series=['NY.GDP.DEFL.KD.ZG', 'FM.LBL.BMNY.ZG'], time='2019')\n#df_wb.to_csv(\"datasets/Inf_M2.csv\")\ndf_wb = pd.read_csv(\"datasets/Inf_M2.csv\", index_col=0)\ndf_wb\n\n\n\n\n\n\n\n\nFM.LBL.BMNY.ZG\nNY.GDP.DEFL.KD.ZG\n\n\neconomy\n\n\n\n\n\n\nABW\n4.398\n6.018\n\n\nAFE\nNaN\n4.444\n\n\nAFG\n5.704\n6.521\n\n\nAFW\nNaN\n1.359\n\n\nAGO\n30.114\n19.187\n\n\n...\n...\n...\n\n\nXKX\n12.571\n0.963\n\n\nYEM\nNaN\nNaN\n\n\nZAF\n6.110\n4.614\n\n\nZMB\n12.545\n7.633\n\n\nZWE\n249.835\n225.395\n\n\n\n\n266 rows × 2 columns\n\n\n\n我们发现数据集索引变量economy使用的同样是ISO国家代码，作为练习，我们希望获得国家名称、收入水平等级、首都等信息，可以使用wb.economy.DataFrame()获取一个包含所有国家/地区信息的数据框：\n\ncountry_info = wb.economy.DataFrame(skipAggs=True)[['name', 'incomeLevel','capitalCity']]\n\n现在我们有3个数据集，pwt2019、df_wb、country_info，要合并在一起，我们可以：\n\ndf_wb和country_info数据集索引相同，根据索引首先进行合并；\n合并后的数据有变量name，表示国家名称，然后用变量作为合并的键进行合并\n\n\nmerged_df1 =pd.merge(pwt2019_sub, \n            pd.merge(df_wb, country_info, left_index=True, right_index=True),\n            left_on=\"country\", right_on=\"name\")\nmerged_df1.shape\n\n(156, 13)\n\n\n默认的是 how='inner'，不能合并的数据将被删除。我们发现，合并后观测值有156个，这是因为两个数据集中国家名称并不完全一致。推荐使用索引进行合并:\n\nmerged_df2 = pd.merge(pwt2019_sub,\n            pd.merge(df_wb, country_info, left_index=True, right_index=True),\n            left_index=True, right_index=True, how=\"left\")\nmerged_df2.shape\n\n(183, 13)",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#多级索引",
    "href": "pandas.html#多级索引",
    "title": "Pandas 基础应用",
    "section": "多级索引",
    "text": "多级索引\n数据集Penn World Table是一个面板数据，“国家-年”对应一个观测值，每个国家都有多个观测值。可以利用Pandas的多级索引功能，详见Pandas文档MultiIndex / advanced indexing。\n\npwt = pd.read_excel(io = \"datasets/pwt1001.xlsx\",\n                header=0,                \n                sheet_name=\"Data\")\npwt.set_index(['countrycode','year'], inplace=True)\npwt.tail()\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.140\n-0.288\n-0.052\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203\n40963.191\n14.030\n6.504\nNaN\n2.616\n43291.566\n46404.160\n...\n0.132\n-0.251\n-0.016\n0.471\n0.651\n0.540\n0.620\n0.520\n0.419\n1.729\n\n\n2017\nZimbabwe\nUS Dollar\n44672.176\n44316.742\n14.237\n6.612\nNaN\n2.648\n46113.945\n49457.570\n...\n0.127\n-0.203\n-0.040\n0.474\n0.640\n0.520\n0.620\n0.552\n0.419\n1.756\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109\n43420.898\n14.439\n6.715\nNaN\n2.681\n46198.441\n49665.387\n...\n0.144\n-0.264\n-0.021\n0.544\n0.655\n0.530\n0.641\n0.562\n0.427\n1.830\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\n\n\n5 rows × 50 columns\n\n\n\n多重索引是由多个级别的标签构成的，在Pandas内部以元组的形式表示和管理：\n\npwt.index[:3]\n\nMultiIndex([('ABW', 1950),\n            ('ABW', 1951),\n            ('ABW', 1952)],\n           names=['countrycode', 'year'])\n\n\n\n选择数据\n同样，我们可以使用.loc()标签（labels）方法选择需要的数据，例如：\n\npwt.loc[['CHN', 'USA'], ['rgdpe','pop']]\n\n\n\n\n\n\n\n\n\nrgdpe\npop\n\n\ncountrycode\nyear\n\n\n\n\n\n\nCHN\n1950\nNaN\nNaN\n\n\n1951\nNaN\nNaN\n\n\n1952\n554906.438\n579.577\n\n\n1953\n626291.125\n589.317\n\n\n1954\n584967.125\n599.943\n\n\n...\n...\n...\n...\n\n\nUSA\n2015\n18905122.000\n320.878\n\n\n2016\n19285252.000\n323.016\n\n\n2017\n19754754.000\n325.085\n\n\n2018\n20369440.000\n327.096\n\n\n2019\n20860506.000\n329.065\n\n\n\n\n140 rows × 2 columns\n\n\n\n如果需要选择某一年的截面数据，由于有多级索引，可以用一个元组来为每一级索引提供一个选择器：\n\npwt.loc[(slice(None), 2015), :]\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n2015\nAruba\nAruban Guilder\n3959.593\n3921.183\n0.104\n0.047\nNaN\nNaN\n3029.996\n3972.749\n...\n0.923\n-0.926\n0.000\n0.795\n0.668\n0.661\n0.586\n0.590\n0.586\n0.514\n\n\nAGO\n2015\nAngola\nKwanza\n216207.094\n224712.609\n27.884\n14.529\nNaN\n1.453\n153591.031\n222846.484\n...\n0.304\n-0.157\n-0.140\n0.574\n0.574\n0.407\n0.498\n0.613\n0.352\n0.545\n\n\nAIA\n2015\nAnguilla\nEast Caribbean Dollar\n408.109\n249.571\n0.014\nNaN\nNaN\nNaN\n387.717\n490.294\n...\n1.337\n-2.373\n0.000\n0.860\n0.812\n0.650\n0.645\n0.483\n0.628\nNaN\n\n\nALB\n2015\nAlbania\nLek\n32037.936\n33659.422\n2.891\n0.926\nNaN\n2.938\n30027.896\n37551.594\n...\n0.099\n-0.254\n0.034\n0.393\n0.391\n0.191\n0.584\n0.507\n0.260\nNaN\n\n\nARE\n2015\nUnited Arab Emirates\nUAE Dirham\n632701.188\n693186.188\n9.263\n5.631\nNaN\n2.734\n247580.266\n465946.500\n...\n0.770\n-0.666\n0.228\n0.721\n0.420\n0.621\n0.559\n0.618\n0.279\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2015\nViet Nam\nDong\n561821.188\n572777.500\n92.677\n52.840\n2191.370\n2.669\n443934.562\n574238.562\n...\n0.442\n-0.439\n-0.000\n0.337\n0.410\n0.227\n0.636\n0.655\n0.257\nNaN\n\n\nYEM\n2015\nYemen\nYemeni Rial\n62905.148\n67143.297\n26.498\n4.775\nNaN\n1.627\n69915.164\n75506.180\n...\n0.015\n-0.168\n0.011\n0.508\n0.599\n0.218\n0.531\n0.591\n0.468\nNaN\n\n\nZAF\n2015\nSouth Africa\nRand\n717051.875\n716283.250\n55.386\n17.784\nNaN\n2.719\n578029.562\n721576.188\n...\n0.178\n-0.197\n0.005\n0.438\n0.463\n0.449\n0.635\n0.610\n0.295\n0.542\n\n\nZMB\n2015\nZambia\nKwacha\n51722.648\n52037.516\n15.879\n4.598\nNaN\n2.502\n37000.527\n57027.535\n...\n0.200\n-0.262\n-0.039\n0.376\n0.454\n0.375\n0.636\n0.584\n0.277\n0.440\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.140\n-0.288\n-0.052\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\n\n\n\n\n183 rows × 50 columns\n\n\n\n注意， - 这里使用了 slice(None)，是 Python 中表示**“所有”的一种方式，表示：“在第一级索引（例如，国家代码）上，选择所有标签。” - 2015表示：“在第二级索引（例如，年份）上，只选择标签为 2015 的行。” - 如果想选择多年数据可以列表形式，如[2001,2015]。\n如果是选择1992年以后的数据，可以在第二级索引上同样应用 slice()： 年之后的数据\n\npwt.loc[(slice(None), slice(1992, None)), :]\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1992\nAruba\nAruban Guilder\n2944.516\n3370.538\n0.068\n0.031\nNaN\nNaN\n1722.105\n2955.296\n...\n0.778\n-0.478\n-0.035\n0.413\n0.260\n0.432\n0.320\n0.483\n0.269\n0.904\n\n\n1993\nAruba\nAruban Guilder\n3131.371\n3698.532\n0.073\n0.033\nNaN\nNaN\n1860.498\n3167.873\n...\n0.825\n-0.602\n-0.035\n0.437\n0.273\n0.471\n0.355\n0.455\n0.281\n0.898\n\n\n1994\nAruba\nAruban Guilder\n3537.953\n4172.824\n0.077\n0.035\nNaN\nNaN\n2015.999\n3393.727\n...\n0.764\n-0.501\n-0.040\n0.448\n0.297\n0.428\n0.377\n0.508\n0.310\n0.939\n\n\n1995\nAruba\nAruban Guilder\n3412.875\n4184.156\n0.080\n0.037\nNaN\nNaN\n2034.535\n3435.051\n...\n0.766\n-0.543\n-0.031\n0.452\n0.304\n0.525\n0.405\n0.547\n0.283\n0.821\n\n\n1996\nAruba\nAruban Guilder\n3428.601\n3977.093\n0.083\n0.038\nNaN\nNaN\n2167.171\n3444.941\n...\n0.840\n-0.669\n-0.034\n0.462\n0.318\n0.559\n0.419\n0.507\n0.291\n0.804\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.140\n-0.288\n-0.052\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203\n40963.191\n14.030\n6.504\nNaN\n2.616\n43291.566\n46404.160\n...\n0.132\n-0.251\n-0.016\n0.471\n0.651\n0.540\n0.620\n0.520\n0.419\n1.729\n\n\n2017\nZimbabwe\nUS Dollar\n44672.176\n44316.742\n14.237\n6.612\nNaN\n2.648\n46113.945\n49457.570\n...\n0.127\n-0.203\n-0.040\n0.474\n0.640\n0.520\n0.620\n0.552\n0.419\n1.756\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109\n43420.898\n14.439\n6.715\nNaN\n2.681\n46198.441\n49665.387\n...\n0.144\n-0.264\n-0.021\n0.544\n0.655\n0.530\n0.641\n0.562\n0.427\n1.830\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\n\n\n5124 rows × 50 columns\n\n\n\n上面的例子使用slice函数不是那么直观，也可以使用df.index.get_level_values('year')提取索引year的值，形成一个序列（可以另存为一个变量），然后利用条件表达式生成一个布尔序列，对数据框进行筛选：\n\nsec_index = pwt.index.get_level_values('year')\npwt[sec_index &gt; 1992]\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1993\nAruba\nAruban Guilder\n3131.371\n3698.532\n0.073\n0.033\nNaN\nNaN\n1860.498\n3167.873\n...\n0.825\n-0.602\n-0.035\n0.437\n0.273\n0.471\n0.355\n0.455\n0.281\n0.898\n\n\n1994\nAruba\nAruban Guilder\n3537.953\n4172.824\n0.077\n0.035\nNaN\nNaN\n2015.999\n3393.727\n...\n0.764\n-0.501\n-0.040\n0.448\n0.297\n0.428\n0.377\n0.508\n0.310\n0.939\n\n\n1995\nAruba\nAruban Guilder\n3412.875\n4184.156\n0.080\n0.037\nNaN\nNaN\n2034.535\n3435.051\n...\n0.766\n-0.543\n-0.031\n0.452\n0.304\n0.525\n0.405\n0.547\n0.283\n0.821\n\n\n1996\nAruba\nAruban Guilder\n3428.601\n3977.093\n0.083\n0.038\nNaN\nNaN\n2167.171\n3444.941\n...\n0.840\n-0.669\n-0.034\n0.462\n0.318\n0.559\n0.419\n0.507\n0.291\n0.804\n\n\n1997\nAruba\nAruban Guilder\n3718.441\n4282.010\n0.085\n0.039\nNaN\nNaN\n2264.614\n3740.266\n...\n0.849\n-0.724\n-0.018\n0.481\n0.325\n0.564\n0.417\n0.481\n0.299\n0.821\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.140\n-0.288\n-0.052\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203\n40963.191\n14.030\n6.504\nNaN\n2.616\n43291.566\n46404.160\n...\n0.132\n-0.251\n-0.016\n0.471\n0.651\n0.540\n0.620\n0.520\n0.419\n1.729\n\n\n2017\nZimbabwe\nUS Dollar\n44672.176\n44316.742\n14.237\n6.612\nNaN\n2.648\n46113.945\n49457.570\n...\n0.127\n-0.203\n-0.040\n0.474\n0.640\n0.520\n0.620\n0.552\n0.419\n1.756\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109\n43420.898\n14.439\n6.715\nNaN\n2.681\n46198.441\n49665.387\n...\n0.144\n-0.264\n-0.021\n0.544\n0.655\n0.530\n0.641\n0.562\n0.427\n1.830\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\n\n\n4941 rows × 50 columns\n\n\n\n当然，可以同时选择指定的变量和年份，例如：\n\npwt.loc[(slice(None), [2016,2019]), ['rgdpe','rgdpo']]\n#\npwt.loc[(([\"CHN\", \"USA\"], [2016,2019])), ['rgdpe','rgdpo']]\n\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\n\n\ncountrycode\nyear\n\n\n\n\n\n\nCHN\n2016\n18611202.000\n18591710.000\n\n\n2019\n20056066.000\n20257660.000\n\n\nUSA\n2016\n19285252.000\n19095196.000\n\n\n2019\n20860506.000\n20595844.000\n\n\n\n\n\n\n\n\n\n按索引排序\n除了通常的排序以外，由于有了二级索引，如果按索引排序，两级索引变量是同时排序的：\n\npwt.sort_index(ascending=False)\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZWE\n2019\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109\n43420.898\n14.439\n6.715\nNaN\n2.681\n46198.441\n49665.387\n...\n0.144\n-0.264\n-0.021\n0.544\n0.655\n0.530\n0.641\n0.562\n0.427\n1.830\n\n\n2017\nZimbabwe\nUS Dollar\n44672.176\n44316.742\n14.237\n6.612\nNaN\n2.648\n46113.945\n49457.570\n...\n0.127\n-0.203\n-0.040\n0.474\n0.640\n0.520\n0.620\n0.552\n0.419\n1.756\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203\n40963.191\n14.030\n6.504\nNaN\n2.616\n43291.566\n46404.160\n...\n0.132\n-0.251\n-0.016\n0.471\n0.651\n0.540\n0.620\n0.520\n0.419\n1.729\n\n\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.140\n-0.288\n-0.052\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nABW\n1954\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1950\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n12810 rows × 50 columns\n\n\n\n可以对两级索引以列表的形式分别设定排序的顺序。例如，先将国家代码按字母升序，然后将年降序：\n\npwt.sort_index(ascending=[True, False])\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n2019\nAruba\nAruban Guilder\n3921.261\n3467.300\n0.106\n0.048\nNaN\nNaN\n3023.695\n3877.660\n...\n0.973\n-1.092\n0.000\n0.883\n0.816\n0.744\n0.707\n0.623\n0.805\n0.648\n\n\n2018\nAruba\nAruban Guilder\n3927.567\n3444.659\n0.106\n0.047\nNaN\nNaN\n3040.981\n3903.105\n...\n1.016\n-1.142\n0.000\n0.857\n0.790\n0.723\n0.661\n0.584\n0.789\n0.642\n\n\n2017\nAruba\nAruban Guilder\n3979.910\n3062.581\n0.105\n0.047\nNaN\nNaN\n3044.066\n3912.318\n...\n1.118\n-1.395\n-0.000\n0.809\n0.732\n0.682\n0.655\n0.512\n0.740\n0.649\n\n\n2016\nAruba\nAruban Guilder\n3953.522\n3320.977\n0.105\n0.047\nNaN\nNaN\n3025.954\n3915.882\n...\n1.028\n-1.184\n0.000\n0.798\n0.713\n0.668\n0.607\n0.524\n0.658\n0.583\n\n\n2015\nAruba\nAruban Guilder\n3959.593\n3921.183\n0.104\n0.047\nNaN\nNaN\n3029.996\n3972.749\n...\n0.923\n-0.926\n0.000\n0.795\n0.668\n0.661\n0.586\n0.590\n0.586\n0.514\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n1954\nZimbabwe\nUS Dollar\n6373.737\n6277.434\n3.172\n1.481\nNaN\n1.180\n5446.247\n6939.839\n...\n0.000\n-0.000\n-0.118\n0.124\n0.119\n0.106\n0.093\n0.078\n0.102\nNaN\n\n\n1953\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1950\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n12810 rows × 50 columns\n\n\n\n\n\npd.merge\n假如我们想要把国家有关信息country_info数据与pwt合并，由于后者是面板数据，需要使用参数validate = \"m:1\"。下面的例子在合并之前先将索引名称重命名保持一致，否则会报错：\n\ncountry_info = country_info.rename_axis('countrycode', axis=0)\npd.merge(pwt, country_info, left_index=True, right_index=True,validate= \"m:1\")\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\nname\nincomeLevel\ncapitalCity\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1950\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAruba\nHIC\nOranjestad\n\n\n1951\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAruba\nHIC\nOranjestad\n\n\n1952\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAruba\nHIC\nOranjestad\n\n\n1953\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAruba\nHIC\nOranjestad\n\n\n1954\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAruba\nHIC\nOranjestad\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617\n39798.645\n13.815\n6.394\nNaN\n2.585\n44249.355\n47325.461\n...\n0.479\n0.651\n0.541\n0.617\n0.533\n0.426\n1.778\nZimbabwe\nLMC\nHarare\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203\n40963.191\n14.030\n6.504\nNaN\n2.616\n43291.566\n46404.160\n...\n0.471\n0.651\n0.540\n0.620\n0.520\n0.419\n1.729\nZimbabwe\nLMC\nHarare\n\n\n2017\nZimbabwe\nUS Dollar\n44672.176\n44316.742\n14.237\n6.612\nNaN\n2.648\n46113.945\n49457.570\n...\n0.474\n0.640\n0.520\n0.620\n0.552\n0.419\n1.756\nZimbabwe\nLMC\nHarare\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109\n43420.898\n14.439\n6.715\nNaN\n2.681\n46198.441\n49665.387\n...\n0.544\n0.655\n0.530\n0.641\n0.562\n0.427\n1.830\nZimbabwe\nLMC\nHarare\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n...\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\nZimbabwe\nLMC\nHarare\n\n\n\n\n12600 rows × 53 columns\n\n\n\n\n\nstack 和 unstack\n数据有“长（long）”和“宽（wide）”两种组织方式，Penn World Table 是以“长”的形式保存的。有时候需要在两种数据格式之间进行转换，就需要用到df.stack()和df.unstack()函数。\n注意，df.unstack()函数的参数level=，设置为哪一级索引，便生成为列。默认在最后一级索引上转换，即年，因此列便为年，行为国家，反之，列为国家，行为年。如下面例子所示，为了简便只保留了三个国家5年的数据：\n\npwt_sub = pwt.loc[([\"CHN\", \"KOR\", \"USA\"], slice(2015, None)), [\"rgdpe\", \"pop\"]]\n# \npwt_sub_wide = pwt_sub.unstack(level=-1)\n# pwt_sub.unstack(level=0)\n\n要获得长格式的数据，使用df.stack()即可：\n\npwt_sub_wide.stack(future_stack=True)\n\n\n\n\n\n\n\n\n\nrgdpe\npop\n\n\ncountrycode\nyear\n\n\n\n\n\n\nCHN\n2015\n17866282.000\n1406.848\n\n\n2016\n18611202.000\n1414.049\n\n\n2017\n19501140.000\n1421.022\n\n\n2018\n19508708.000\n1427.648\n\n\n2019\n20056066.000\n1433.784\n\n\nKOR\n2015\n1928056.875\n50.823\n\n\n2016\n1999699.625\n50.983\n\n\n2017\n2070935.625\n51.096\n\n\n2018\n2102051.500\n51.172\n\n\n2019\n2090945.875\n51.225\n\n\nUSA\n2015\n18905122.000\n320.878\n\n\n2016\n19285252.000\n323.016\n\n\n2017\n19754754.000\n325.085\n\n\n2018\n20369440.000\n327.096\n\n\n2019\n20860506.000\n329.065\n\n\n\n\n\n\n\n当我们从一些数据库下载数据时，常见形式为列为不同时期相同变量的值。例如，从世界银行下载人均GDP和人口数据：\n\nimport wbgapi as wb\ndf = wb.data.DataFrame(series=['NY.GDP.PCAP.CD', \"SP.POP.TOTL\"], \n                                #time=range(2017,2020),\n                                time=['YR2017','YR2018','YR2019'],\n                                 numericTimeKeys=True)\ndf.head()\n\n\n\n\n\n\n\n\n\n2017\n2018\n2019\n\n\neconomy\nseries\n\n\n\n\n\n\n\nABW\nNY.GDP.PCAP.CD\n28440.052\n30082.128\n31096.205\n\n\nSP.POP.TOTL\n108735.000\n108908.000\n109203.000\n\n\nAFE\nNY.GDP.PCAP.CD\n1520.212\n1538.902\n1493.818\n\n\nSP.POP.TOTL\n640058741.000\n657801085.000\n675950189.000\n\n\nAFG\nNY.GDP.PCAP.CD\n525.470\n491.337\n496.603\n\n\n\n\n\n\n\n下载的数据df索引是“economy - series”，每一年数据一列。我们希望序列成为列变量，时间成为索引。我们可以先对数据进行转置成宽格式的数据，然后再在国家层面堆叠，使其成为索引，再交换索引排序得到通常的情况：\n\ndf.T.stack(level=0, future_stack=True).swaplevel().sort_index()\n\n\n\n\n\n\n\n\nseries\nNY.GDP.PCAP.CD\nSP.POP.TOTL\n\n\neconomy\n\n\n\n\n\n\n\nABW\n2017\n28440.052\n108735.000\n\n\n2018\n30082.128\n108908.000\n\n\n2019\n31096.205\n109203.000\n\n\nAFE\n2017\n1520.212\n640058741.000\n\n\n2018\n1538.902\n657801085.000\n\n\n...\n...\n...\n...\n\n\nZMB\n2018\n1463.900\n17973569.000\n\n\n2019\n1258.986\n18513839.000\n\n\nZWE\n2017\n3448.087\n14812482.000\n\n\n2018\n2271.853\n15034452.000\n\n\n2019\n1683.913\n15271368.000\n\n\n\n\n798 rows × 2 columns\n\n\n\n另外，stack不是唯一的方法，也可以使用df.melt()结合df.pivot_table()函数来实现：\n\ndf_reset = df.reset_index()\ndf_long = df_reset.melt(id_vars=['economy', 'series'], var_name='year', value_name='value')\ndf_long.pivot_table(index=['economy', 'year'], columns='series', values='value')\n\n\n\n\n\n\n\n\nseries\nNY.GDP.PCAP.CD\nSP.POP.TOTL\n\n\neconomy\nyear\n\n\n\n\n\n\nABW\n2017\n28440.052\n108735.000\n\n\n2018\n30082.128\n108908.000\n\n\n2019\n31096.205\n109203.000\n\n\nAFE\n2017\n1520.212\n640058741.000\n\n\n2018\n1538.902\n657801085.000\n\n\n...\n...\n...\n...\n\n\nZMB\n2018\n1463.900\n17973569.000\n\n\n2019\n1258.986\n18513839.000\n\n\nZWE\n2017\n3448.087\n14812482.000\n\n\n2018\n2271.853\n15034452.000\n\n\n2019\n1683.913\n15271368.000\n\n\n\n\n795 rows × 2 columns",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "pandas.html#pandas中的分组计算groupby",
    "href": "pandas.html#pandas中的分组计算groupby",
    "title": "Pandas 基础应用",
    "section": "Pandas中的分组计算（groupby）",
    "text": "Pandas中的分组计算（groupby）\nPandas 的分组（groupby()）方法按照“分割-应用-组合（split-apply-combine）”的原理，创建一个 groupby 对象，可以应用各种方法来聚合、转换或过滤数据。更多介绍参见Pandas官方文档Group by: split-apply-combine。\n选择合适的方法：\n\n如果你的操作只是简单的统计（如求和、平均值），优先使用聚合方法，它们通常效率最高。\n如果需要返回与原始 DataFrame 相同长度的结果，例如进行组内标准化，使用转换方法。\n如果需要根据组的属性来决定保留或丢弃整个组，使用过滤方法。\n当以上方法都无法满足需求时，或者需要执行更复杂的自定义逻辑时，使用apply()方法。\n\n\n聚合方法（Aggregation Methods）\n聚合方法将每个组的数据压缩成一个单一的值，是最常用的groupby操作，例如mean(),sum(),count(),size(),min(),max(),std(),var(),median()等常见的统计量，或者first(),last(),nth(n)等获取第一个、最好一个或第n个值：\n索引\n例如，根据索引计算世界人口，先在索引上分组，然后使用.sum()函数：\n\npwt.groupby(level=1)['pop'].sum()\n\nyear\n1950   1297.363\n1951   1345.649\n1952   1948.874\n1953   2005.092\n1954   2048.591\n         ...   \n2015   7254.660\n2016   7336.956\n2017   7418.961\n2018   7500.383\n2019   7580.897\nName: pop, Length: 70, dtype: float64\n\n\navh变量度量了“Average annual hours worked by persons engaged”,让我们分组计算平均，得到按年和按国家平均\n\navh = pwt[pwt['avh'].notna()]\nfig, ax = plt.subplots(2, 1, figsize=(12, 12))\navh.groupby(level=1)['avh'].mean().sort_values(ascending=False).plot(kind='line', ax=ax[0])\nax[0].set_xlabel(\"\")\nax[0].set_ylabel(\"Average annual hours worked by persons engaged\")\navh.groupby(level=0)['avh'].mean().sort_values(ascending=False)[:25].plot(kind='bar', ax=ax[1])\nax[1].set_xlabel(\"\")\nax[1].set_ylabel(\"Average annual hours worked by persons engaged\")\nplt.show()\n\n\n\n\n\n\n\n\n最常见的是按变量进行分组，例如，按国家名country分组，最后一个观测值：\n\npwt.groupby(by=['country']).last()\n\n\n\n\n\n\n\n\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlbania\nLek\n35890.020\n36103.043\n2.881\n1.076\nNaN\n2.965\n33399.168\n40868.316\n35808.344\n...\n0.127\n-0.314\n0.061\n0.473\n0.457\n0.236\n0.630\n0.525\n0.301\nNaN\n\n\nAlgeria\nAlgerian Dinar\n488952.375\n507487.562\n43.053\n11.273\nNaN\n2.384\n365349.094\n518958.812\n487570.812\n...\n0.136\n-0.136\n-0.031\n0.331\n0.512\n0.206\n0.519\n0.606\n0.327\nNaN\n\n\nAngola\nKwanza\n228151.016\n227855.719\n31.825\n16.645\nNaN\n1.482\n155943.719\n198750.422\n227771.609\n...\n0.344\n-0.114\n-0.120\n0.438\n0.343\n0.240\n0.476\n0.612\n0.211\n0.396\n\n\nAnguilla\nEast Caribbean Dollar\n376.635\n225.681\n0.015\n0.005\nNaN\nNaN\n438.470\n509.045\n375.136\n...\n1.480\n-2.446\n-0.143\n1.065\n1.029\n0.732\n0.769\n0.603\n0.898\nNaN\n\n\nAntigua and Barbuda\nEast Caribbean Dollar\n1986.163\n1603.854\n0.097\n0.038\nNaN\nNaN\n1787.817\n2415.362\n1979.578\n...\n0.030\n-0.610\n0.099\n0.900\n0.951\n0.519\n0.767\n0.571\n0.668\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVenezuela (Bolivarian Republic of)\nBolivar Fuerte\n7166.572\n7160.107\n28.516\n11.694\n1903.852\n2.893\n9266.067\n10055.498\n7167.786\n...\n0.000\n-0.001\n-0.403\n18.144\n34.445\n14.176\n0.581\n0.646\n20.695\n12.002\n\n\nViet Nam\nDong\n750726.750\n724123.375\n96.462\n50.400\n2131.968\n2.870\n582677.062\n758821.938\n747853.750\n...\n0.526\n-0.518\n-0.057\n0.348\n0.399\n0.245\n0.696\n0.677\n0.250\nNaN\n\n\nYemen\nYemeni Rial\n50052.934\n51828.059\n29.162\n5.532\nNaN\n1.843\n49266.473\n67992.531\n49937.043\n...\n0.001\n-0.135\n-0.173\n0.778\n0.239\n0.212\n0.633\n0.671\n0.175\nNaN\n\n\nZambia\nKwacha\n57956.184\n56783.715\n17.861\n5.225\nNaN\n2.687\n38698.402\n56536.863\n57695.066\n...\n0.215\n-0.239\n0.028\n0.373\n0.482\n0.330\n0.574\n0.532\n0.295\n0.360\n\n\nZimbabwe\nUS Dollar\n42296.062\n40826.570\n14.645\n6.831\nNaN\n2.713\n43961.840\n47128.785\n42325.117\n...\n0.214\n-0.271\n-0.090\n0.495\n0.652\n0.501\n0.488\n0.430\n0.420\n1.581\n\n\n\n\n183 rows × 49 columns\n\n\n\n\n\n转换方法（Transformation Methods）\n\ntransform(func): 对每个组应用函数，并将结果广播回原始 DataFrame 的形状。\nrank(method='average'): 计算组内排名。\nfillna(value): 在组内填充缺失值。\n\n\navh.groupby(level=1)['avh'].transform('mean')\navh.groupby(level=1)['avh'].mean()\n\nyear\n1950   2171.439\n1951   2190.832\n1952   2181.242\n1953   2183.205\n1954   2179.604\n         ...   \n2015   1865.221\n2016   1871.138\n2017   1858.543\n2018   1854.066\n2019   1849.981\nName: avh, Length: 70, dtype: float64\n\n\n注意，转换与聚合的区别,转换将生成的值与原数据观测值一样多，这里是3492个，而聚合只有70个。\n.transform()方法可以与lambda函数相结合，例如：\n\npwt.select_dtypes(np.number).groupby(level=0).transform(lambda x: (x - x.mean())/x.std())\n\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\ncgdpo\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1950\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1954\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\n0.558\n0.539\n1.363\n1.482\nNaN\n1.685\n1.065\n0.879\n0.568\n0.518\n...\n0.573\n-1.555\n-0.255\n0.530\n1.749\n2.268\n1.208\n0.981\n1.695\n-0.574\n\n\n2016\n0.654\n0.603\n1.423\n1.548\nNaN\n1.752\n1.007\n0.829\n0.664\n0.595\n...\n0.495\n-1.255\n0.077\n0.502\n1.748\n2.255\n1.223\n0.905\n1.640\n-0.603\n\n\n2017\n0.809\n0.787\n1.479\n1.612\nNaN\n1.821\n1.177\n0.994\n0.831\n0.783\n...\n0.445\n-0.857\n-0.143\n0.512\n1.690\n2.108\n1.223\n1.086\n1.634\n-0.587\n\n\n2018\n0.790\n0.738\n1.535\n1.674\nNaN\n1.890\n1.182\n1.005\n0.812\n0.742\n...\n0.614\n-1.357\n0.035\n0.736\n1.770\n2.182\n1.332\n1.139\n1.702\n-0.543\n\n\n2019\n0.677\n0.595\n1.592\n1.744\nNaN\n1.961\n1.048\n0.868\n0.700\n0.607\n...\n1.271\n-1.417\n-0.607\n0.579\n1.755\n1.965\n0.558\n0.405\n1.644\n-0.691\n\n\n\n\n12810 rows × 43 columns\n\n\n\n\n\n过滤方法（Filtration Methods）\n过滤方法会根据每个组的某个条件来排除整个组。\n\nfilter(func): 根据一个返回布尔值的函数来过滤组。如果函数对一个组返回 True，则保留该组；否则，删除该组。\n\n\npwt.groupby(level=0).filter(lambda x: x['pop'].mean() &gt; 50)\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBGD\n1950\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1954\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2015\nViet Nam\nDong\n561821.188\n572777.500\n92.677\n52.840\n2191.370\n2.669\n443934.562\n574238.562\n...\n0.442\n-0.439\n-0.000\n0.337\n0.410\n0.227\n0.636\n0.655\n0.257\nNaN\n\n\n2016\nViet Nam\nDong\n601767.562\n596363.125\n93.640\n53.303\n2169.552\n2.716\n473113.406\n610603.438\n...\n0.463\n-0.451\n-0.024\n0.338\n0.397\n0.237\n0.633\n0.643\n0.245\nNaN\n\n\n2017\nViet Nam\nDong\n653410.812\n647224.938\n94.601\n53.703\n2131.968\n2.765\n507151.375\n660755.875\n...\n0.516\n-0.517\n-0.020\n0.341\n0.387\n0.240\n0.644\n0.637\n0.243\nNaN\n\n\n2018\nViet Nam\nDong\n705553.375\n689643.438\n95.546\n54.069\n2131.968\n2.816\n543525.250\n708143.188\n...\n0.522\n-0.519\n-0.034\n0.346\n0.395\n0.244\n0.679\n0.664\n0.246\nNaN\n\n\n2019\nViet Nam\nDong\n750726.750\n724123.375\n96.462\n50.400\n2131.968\n2.870\n582677.062\n758821.938\n...\n0.526\n-0.518\n-0.057\n0.348\n0.399\n0.245\n0.696\n0.677\n0.250\nNaN\n\n\n\n\n1260 rows × 50 columns\n\n\n\n\n\n应用方法（Application Methods）\napply() 方法是最通用的方法，它允许你对每个组应用任何自定义函数。这个函数可以执行聚合、转换或过滤操作，或者任何更复杂的逻辑。\n\napply(func): 将一个自定义函数应用于每个组。函数的返回值可以是 Series、DataFrame 或标量。",
    "crumbs": [
      "数据分析",
      "Pandas及应用"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "参考文献\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "参考文献"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "后记",
    "section": "",
    "text": "后记\nIn summary, this book has no content whatsoever.\n\n\n\n\n Back to top",
    "crumbs": [
      "总结"
    ]
  }
]