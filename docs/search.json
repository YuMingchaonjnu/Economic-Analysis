[
  {
    "objectID": "regression.html",
    "href": "regression.html",
    "title": "回归分析",
    "section": "",
    "text": "作者认为，一个国家的生活水平取决于该国与其他国家的国际贸易、该国的国内贸易以及其他因素。从一个简单的计量模型出发： \\[\n\\ln Y_{i} = \\alpha + \\beta T_{i} + \\gamma W_{i} + \\epsilon_{i}\n\\]\n其中，被解释变量是人均收入 \\(Y_{i}\\) 的对数；解释变量 \\(T_{i}\\) 表示国际贸易，\\(W_{i}\\) 表示国内贸易，\\(\\epsilon_{i}\\) 为误差项，表示其他对收入影响的因素。\n预期国际贸易和\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.rcParams['font.family']='SimHei'\nplt.rcParams['axes.unicode_minus'] = False\nimport statsmodels.api as sm"
  },
  {
    "objectID": "regression.html#建立计量模型",
    "href": "regression.html#建立计量模型",
    "title": "回归分析",
    "section": "",
    "text": "作者认为，一个国家的生活水平取决于该国与其他国家的国际贸易、该国的国内贸易以及其他因素。从一个简单的计量模型出发： \\[\n\\ln Y_{i} = \\alpha + \\beta T_{i} + \\gamma W_{i} + \\epsilon_{i}\n\\]\n其中，被解释变量是人均收入 \\(Y_{i}\\) 的对数；解释变量 \\(T_{i}\\) 表示国际贸易，\\(W_{i}\\) 表示国内贸易，\\(\\epsilon_{i}\\) 为误差项，表示其他对收入影响的因素。\n预期国际贸易和\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.rcParams['font.family']='SimHei'\nplt.rcParams['axes.unicode_minus'] = False\nimport statsmodels.api as sm"
  },
  {
    "objectID": "regression.html#ols-估计量",
    "href": "regression.html#ols-估计量",
    "title": "回归分析",
    "section": "2 OLS 估计量",
    "text": "2 OLS 估计量\n\n# Generate random data\nnp.random.seed(0)\nx = np.random.rand(20)\ny = 2 * x + np.random.randn(20)\n\n# Fit a line using OLS\ncoefficients = np.polyfit(x, y, 1)\npoly = np.poly1d(coefficients)\nx_fit = np.linspace(0, 1, 100)\ny_fit = poly(x_fit)\n\n# Calculate residuals\nresiduals = y - poly(x)\n# Plot scatter plot and fitted line\nplt.scatter(x, y, label='Data')\nplt.plot(x_fit, y_fit, color='red', label='Fitted Line')\nplt.scatter(x[4], y[4], color='red', label='Selected Residual')\nplt.plot([x[4], x[4]], [y[4], poly(x[4])], color='red', linestyle='--')\n\n# Add annotation of the residual\nplt.annotate(f'$e_i $ ', \n             xy=(x[4], -1), \n             xytext=(x[4]+0.1, y[4]+0.5),\n             arrowprops=dict(facecolor='black', arrowstyle='-&gt;'))\n\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n\n\n\n\n\n\n\n\n\n2.1 Okun’s law\n\nimport pandas_datareader.data as web\nstart_date = '1947-01-01'\nend_date = '2019-12-31'\n\ndata = web.DataReader(['UNRATE','GDPC1'], 'fred', start_date, end_date)\ndf = data.resample('Q').mean()\ndf['gdp_growth_rate'] = np.log(df['GDPC1']/df['GDPC1'].shift(1))*100\ndf['unemp_changed'] = df['UNRATE'].diff()\ndf.dropna(inplace=True)\nfig,ax=plt.subplots(figsize=(10,6))\nsns.regplot(df, y='gdp_growth_rate',x='unemp_changed',ax=ax,marker='+')\nax.set_xlabel('Quarterly change in unemployment rate')\nax.set_ylabel('Quarterly change in Real GDP')\nax.grid()\nmodel = sm.OLS(df['gdp_growth_rate'], sm.add_constant(df['unemp_changed'])).fit()\nprint(model.summary())\n\nC:\\Users\\admin\\AppData\\Local\\Temp\\ipykernel_61632\\1037386578.py:6: FutureWarning: 'Q' is deprecated and will be removed in a future version, please use 'QE' instead.\n  df = data.resample('Q').mean()\n\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:        gdp_growth_rate   R-squared:                       0.466\nModel:                            OLS   Adj. R-squared:                  0.464\nMethod:                 Least Squares   F-statistic:                     248.4\nDate:                Wed, 13 Aug 2025   Prob (F-statistic):           1.11e-40\nTime:                        18:49:00   Log-Likelihood:                -295.55\nNo. Observations:                 287   AIC:                             595.1\nDf Residuals:                     285   BIC:                             602.4\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n=================================================================================\n                    coef    std err          t      P&gt;|t|      [0.025      0.975]\n---------------------------------------------------------------------------------\nconst             0.7788      0.040     19.403      0.000       0.700       0.858\nunemp_changed    -1.6609      0.105    -15.762      0.000      -1.868      -1.453\n==============================================================================\nOmnibus:                       11.629   Durbin-Watson:                   1.912\nProb(Omnibus):                  0.003   Jarque-Bera (JB):               13.361\nSkew:                           0.383   Prob(JB):                      0.00125\nKurtosis:                       3.729   Cond. No.                         2.63\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\n\n\n\n\n\n\n\n\n\n2.2 无偏性\n\nnp.random.seed(12345)\ntrue_intercept = 2.0\ntrue_slope = 3.0\nsample_size = 100\nnum_simulations = 10000\n\nestimated_slopes = np.zeros(num_simulations)\nfor i in range(num_simulations):\n    x = np.random.randn(sample_size)\n    y = true_intercept + true_slope * x + np.random.randn(sample_size)\n    X = sm.add_constant(x)\n    model = sm.OLS(y, X).fit()\n    estimated_slopes[i] = model.params[1]\naverage_slope = np.mean(estimated_slopes)\n\nprint(f\"斜率真实值: {true_slope}\")\nprint(f\"斜率估计值的平均值: {average_slope}\")\n\nfig, ax = plt.subplots(figsize=(10,6))\nax.hist(estimated_slopes, bins=50, color='steelblue', alpha=0.7)\nax.axvline(x=3.0, color='red', linestyle='--') \nax.set_xlabel('斜率估计值')\nax.set_ylabel('频率')\nax.set_title('斜率估计值的直方图')\nplt.show()\n\n斜率真实值: 3.0\n斜率估计值的平均值: 2.9993457145927493\n\n\n\n\n\n\n\n\n\n\n\n2.3 置信区间\n\n### ci\nlower, upper = (1.0941-1.96*0.029, 1.0941+1.96*0.029)\nnp.round((lower, upper),3)\n\narray([1.037, 1.151])\n\n\n\n\n2.4 联合显著性检验\n\n\n2.5 解释回归结果\n\n\n2.6 函数形式变化\n\n\n2.7 回归诊断分析\n\n\n2.8 应用：Mankiw, Romer, Weil (1992)\n这一部分以@mankiw1992contribution 为例，阐释最小二乘法的应用。\n\nimport pandas as pd\nimport numpy as np\n\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nimport matplotlib.pyplot as plt\n\n# Load data\ndata = pd.read_csv(\"datasets/mrw.csv\")\n\n# Generate variables\ndata['lnY85'] = np.log(data['rgdpw85'])\ndata['lnY60'] = np.log(data['rgdpw60'])\ndata['lns'] = np.log(data['i_y'] / 100)\ndata['lnngd'] = np.log(data['popgrowth'] / 100 + 0.05)\ndata['lnschool'] = np.log(data['school'] / 100)\ndata['growth'] = data['lnY85'] - data['lnY60']\ndata['growth_annu'] = 100 * data['growth'] / 25\ndata['lns_lnngd'] = data['lns'] - data['lnngd']\ndata['lnschool_lnngd'] = data['lnschool'] - data['lnngd']\n\n# Table I\nsamples = {'n': data['n'] == 1, 'i': data['i'] == 1, 'o': data['o'] == 1}\nresults_table1 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns + lnngd', data=data[condition]).fit()\n    results_table1[sample] = model.summary()\n\n# Estimate alpha\nmodel_i = smf.ols('lnY85 ~ lns + lnngd', data=data[data['i'] == 1]).fit()\nalpha = model_i.params['lns'] / (1 + model_i.params['lns'])\n\n# Restricted regression\nresults_restricted = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns_lnngd', data=data[condition]).fit()\n    results_restricted[sample] = model.summary()\n\n# Table II\ncorrelation = data.loc[data['i'] == 1, ['school', 'i_y', 'popgrowth']].corr()\nresults_table2 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns + lnngd + lnschool', data=data[condition]).fit()\n    results_table2[sample] = model.summary()\n\n# Test coefficients\ntest_model = smf.ols('lnY85 ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ntest1 = test_model.t_test('lns + lnngd + lnschool = 0')\ntest2 = test_model.t_test('lns = lnschool')\n\n# Implicit alpha\nalpha_lns = test_model.params['lns'] / (1 + test_model.params['lns'] + test_model.params['lnschool'])\nalpha_lnschool = test_model.params['lnschool'] / (1 + test_model.params['lns'] + test_model.params['lnschool'])\n\n# Restricted regression with school\nresults_restricted_school = {}\nfor sample, condition in samples.items():\n    model = smf.ols('lnY85 ~ lns_lnngd + lnschool_lnngd', data=data[condition]).fit()\n    results_restricted_school[sample] = model.summary()\n\n# Table III\nresults_table3 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60', data=data[condition]).fit()\n    results_table3[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Table IV\nresults_table4 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60 + lns + lnngd', data=data[condition]).fit()\n    results_table4[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Table V\nresults_table5 = {}\nfor sample, condition in samples.items():\n    model = smf.ols('growth ~ lnY60 + lns + lnngd + lnschool', data=data[condition]).fit()\n    results_table5[sample] = model.summary()\n    implied_lambda = -np.log(1 + model.params['lnY60']) / (85 - 60)\n\n# Figure I\nplt.figure(figsize=(15, 5))\n\n# Unconditional scatter plot\nplt.subplot(1, 3, 1)\nplt.scatter(data.loc[data['i'] == 1, 'lnY60'], data.loc[data['i'] == 1, 'growth_annu'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Unconditional\")\n\n# Partial out lns and lnngd\nresidual_model1 = smf.ols('lnY60 ~ lns + lnngd', data=data[data['i'] == 1]).fit()\ndata['lnY60_residual1'] = residual_model1.resid + residual_model1.params['Intercept']\nresidual_model2 = smf.ols('growth_annu ~ lns + lnngd', data=data[data['i'] == 1]).fit()\ndata['growth_annu_residual1'] = residual_model2.resid\nplt.subplot(1, 3, 2)\nplt.scatter(data['lnY60_residual1'], data['growth_annu_residual1'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Conditional on lns and lnngd\")\n\n# Partial out lns, lnngd, and lnschool\nresidual_model3 = smf.ols('lnY60 ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ndata['lnY60_residual2'] = residual_model3.resid + residual_model3.params['Intercept']\nresidual_model4 = smf.ols('growth_annu ~ lns + lnngd + lnschool', data=data[data['i'] == 1]).fit()\ndata['growth_annu_residual2'] = residual_model4.resid\nplt.subplot(1, 3, 3)\nplt.scatter(data['lnY60_residual2'], data['growth_annu_residual2'])\nplt.xlabel(\"Log output per working age adult: 1960\")\nplt.ylabel(\"Growth rate: 1960-85\")\nplt.title(\"Conditional on lns, lnngd, and lnschool\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "regression.html#iv-估计",
    "href": "regression.html#iv-估计",
    "title": "回归分析",
    "section": "3 IV 估计",
    "text": "3 IV 估计\n\n3.1 应用：开放与增长\n这一部分中，用 Frankel and Romer (1999) 的经典论文，阐释OLS和IV估计的方法，包括：\n\n如何从理论观点中确定一个统计模型；\n如何理解回归分析的逻辑；\n如何为统计模型中的变量准备数据；\n如何估计统计模型；\n如何解释模型估计的结果；\n如何根据模型估计值进行统计推断；\n如何解释模型整体拟合度。"
  },
  {
    "objectID": "python_basics.html",
    "href": "python_basics.html",
    "title": "Python 语言基础",
    "section": "",
    "text": "这一部分简要介绍Python语言的基本内容，包括变量的类型、条件语句、循环、自定义函数和类等内容。",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#变量与数据类型",
    "href": "python_basics.html#变量与数据类型",
    "title": "Python 语言基础",
    "section": "1 变量与数据类型",
    "text": "1 变量与数据类型\n变量是用来存储数据的“容器”，可以赋不同类型的值。Python常见数据类型有：整数(int)、浮点数(float)、字符串(str)、布尔(bool)等。\n\n1.1 变量赋值\n变量赋值把一个具体的值存储到一个变量中，方便后续使用和操作。要注意变量命名的规则：\n\n变量名只能包含字母、数字和下划线，且不能以数字开头\n区分大小写（如：age 和 Age 是不同变量）\n不可使用Python关键字作为变量名（如：if, for, class 等）\n建议使用有意义的英文单词，遵循小写加下划线的风格。\n\n例如\n\nschool = \"Nanjing Normal University\"\nprice = 12.5\nquantity = 20\ntotal_sales = price * quantity\ntotal_sales\n\n250.0\n\n\n如果命名方式不符合要求，软件将返回错误。将下面例子中表示注释的#去掉，再试运行命令，看提示的错误类型是什么？\n\n#1student = \"Bob\"      \n# class = \"Math\"       \n# student-name = \"Tom\" \n# t&2 = 30             \n\n上面的class，属于软件内部保留的33个关键词之一，注意在命名时应避免与关键词冲突：\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\n1.2 Python基本数据类型\n下面是几种常用的基本数据类型，可以通过type()函数查看一个对象的类型。\n整数（int）：用于表示整数类型的数据。\n\na = 5\nprint(type(a))  \n#\nb = 10\nc = b/a\nprint(c)\n\n&lt;class 'int'&gt;\n2.0\n\n\n注意两个整数的比值为浮点数。\n整数int是类（class）的一种。在Python中，所有的数据类型，包括数字、字符串、列表等，都是通过类来定义的。如果我们输入变量的名字和一个点，a.，Python会出现提示可能的属性（attributes）或方法（methods）。\n\n\n\n\n\n\nFigure 1: 整数的属性和方法\n\n\n\n例如，.is_integer()判断数值是否为整数，.as_integer_ratio()返回一对整数，其比率与原始整数完全相等，且具有正数分母:\n\na.is_integer()\na.as_integer_ratio()\n\n(5, 1)\n\n\n浮点数（float）：用于表示带小数点的数值\n\npi = 3.14159\nradius = 1.75\narea = pi * radius **2\nprint(type(pi))    \nprint(area)\n\n&lt;class 'float'&gt;\n9.621119375\n\n\n字符串（str）：用于表示文本数据\n可以用双引号或者 单引号定义字符串。当字符串较长时，可以用三引号进行定义。例如：\n\nsentence = \"Python's syntax is easy to learn.\"\nmultiline = \"\"\"这个句子\n被我\n分成了几行。这样\n看起来，像诗一样。\n\"\"\"\n\n字符串有许多属性和方法，在进行文本分析时会经常用到。如 Table 1 所示：\n\n\n\nTable 1: 常见的字符串方法\n\n\n\n\n\n\n\n\n\n\n方法\n功能说明\n示例\n\n\n\n\ns.lower()\n转换为小写\n\"Hello\".lower() → \"hello\"\n\n\ns.upper()\n转换为大写\n\"hello\".upper() → \"HELLO\"\n\n\ns.capitalize()\n首字母大写，其余小写\n\"hello world\".capitalize() → \"Hello world\"\n\n\ns.title()\n每个单词首字母大写\n\"hello world\".title() → \"Hello World\"\n\n\ns.strip()\n去除字符串首尾空白字符\n\"  hello  \".strip() → \"hello\"\n\n\ns.lstrip()\n去除左侧空白\n\"  hello\".lstrip() → \"hello\"\n\n\ns.rstrip()\n去除右侧空白\n\"hello  \".rstrip() → \"hello\"\n\n\ns.replace(old, new)\n替换子串\n\"banana\".replace(\"a\", \"o\") → \"bonono\"\n\n\ns.find(sub)\n查找子串位置，找不到返回 -1\n\"hello\".find(\"l\") → 2\n\n\ns.count(sub)\n统计子串出现次数\n\"banana\".count(\"a\") → 3\n\n\ns.startswith(prefix)\n是否以指定前缀开头\n\"hello\".startswith(\"he\") → True\n\n\ns.endswith(suffix)\n是否以指定后缀结尾\n\"hello\".endswith(\"lo\") → True\n\n\ns.split(sep)\n按分隔符拆分字符串\n\"a,b,c\".split(\",\") → [\"a\", \"b\", \"c\"]\n\n\nsep.join(iterable)\n使用分隔符连接字符串序列\n\",\".join([\"a\", \"b\", \"c\"]) → \"a,b,c\"\n\n\n\n\n\n\n注意，当对字符串使用某一方法时，虽然结果显示了变化，并没有改变原本对字符串。如果要保存结果可以赋值。\n\n# 例：将日期字符串按“-”分割成年、月、日\ndate_str = \"2024-06-01\"\nparts = date_str.split(\"-\")\nyear, month, day = parts\nprint(f\"年份：{year}，月份：{month}，日期：{day}\")\n\n# 例：用join方法将列表中的单词拼接成一句话\nwords = [\"Python\", \"is\", \"fun\"]\nsentence = \"$#$_\".join(words)\nprint(sentence) \n\n年份：2024，月份：06，日期：01\nPython$#$_is$#$_fun\n\n\n布林类型（bool）：只有True和False两个值，常用于条件判断\n\nname = \"Jane\"\nage = 20\nscore = 57\nis_adult = age &gt;= 18\nhas_passed = score &gt;= 60\n\nprint(type(is_adult))  # &lt;class 'bool'&gt;\nprint(f\"是否成年：{is_adult}\")\nprint(f\"是否及格：{has_passed}\")\n\n&lt;class 'bool'&gt;\n是否成年：True\n是否及格：False",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#print与-f-string",
    "href": "python_basics.html#print与-f-string",
    "title": "Python 语言基础",
    "section": "2 print与 f-string",
    "text": "2 print与 f-string\n经常需要将运算结果或字符串显示出来，主要的函数是上面已经出现多次的print()函数，它可以输出字符串、变量、表达式等，并支持格式化输出。\n\nprint(multiline)\n\n这个句子\n被我\n分成了几行。这样\n看起来，像诗一样。\n\n\n\n\n2.1 带引号的字符\n在Python语言中，字符可以使用单引号或者双引号表示，在输出带引号的字符串时，可以利用该特点。例如\n\nprint('She said, \"Hello!\"')      # 外单内双\nprint(\"It's a nice day.\")        # 外双内单\n\nShe said, \"Hello!\"\nIt's a nice day.\n\n\n如果字符串本身包含同样的引号，可以用转义符”\\“避免冲突\n\nprint('It\\'s a nice day.') \nprint(\"She said, \\\"Hello!\\\"\")\n\nIt's a nice day.\nShe said, \"Hello!\"\n\n\n三引号可以包含单双引号和多行内容\n\nprint(\"\"\"他说：\"It's OK!\" \"\"\")\n\n他说：\"It's OK!\" \n\n\n\n\n2.2 格式化输出\n格式化输出常用的有`.format()方法和f-string方法。\nformat方法\n.format()方法的基本用法如下：\n\nprint('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n\nWe are the knights who say \"Ni!\"\n\n\n也可以使用关键字参数：\n\nprint('This {food} is {adjective}.'.format(\n      food='spam', adjective='absolutely horrible'))\n\nThis spam is absolutely horrible.\n\n\nf-string\nf-string（格式化字符串字面量）是 Python 3.6 及以上版本提供的一种字符串格式化方式，它让我们可以在字符串中直接嵌入变量或表达式。\n\nimport math\nprint(f'The value of pi is approximately {math.pi:.3f}.')\n\nThe value of pi is approximately 3.142.\n\n\n其中，.3f表示小数点3位；\n输出结果时也可以进行数学运算：\n\nyear = 2024\nGDP_per_capita = 95749\ngrowth = 0.051\n\nmy_string = f\"{year}年，人均国内生产总值为{GDP_per_capita/10000:.3f}万元，比去年增长{growth:.3%}\"\nprint(my_string)\n\n2024年，人均国内生产总值为9.575万元，比去年增长5.100%\n\n\n注意 %将浮点数转换位百分数显示。",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#运算符与表达式",
    "href": "python_basics.html#运算符与表达式",
    "title": "Python 语言基础",
    "section": "3 运算符与表达式",
    "text": "3 运算符与表达式\n运算符用于对数据进行各种操作，主要包括：\n\n算术运算符：+（加），-（减），*（乘），/（除），//（整除），%（取余），**（幂）\n比较运算符：==（等于），!=（不等于），&gt;（大于），&lt;（小于），&gt;=（大于等于），&lt;=（小于等于）\n逻辑运算符：and（与），or（或），not（非）\n赋值运算符：=（赋值），+=，-=，*=，/= 等\n成员运算符：in，not in（判断元素是否属于序列）\n身份运算符：is，is not（判断两个对象是否为同一对象）\n\n下面分别介绍常用的运算符及其用法。\n\n3.1 算术运算符\n加减乘除等算术运算符与通常的表示方法类似，例如，将华氏度转换位摄氏度的公式为：\n例如，华氏温度和摄氏温度的转换公式：\n\\[\n{}^{\\circ}C = \\frac{5}{9}({}^{\\circ}F - 32)\n\\]\n\nF = 92\nC = 5/9 * (F - 32)\nprint(f\"F = {F}, C = {C:.2f}\")\n\nF = 92, C = 33.33\n\n\n值得注意的是//（整除），%（取余），**（幂）：\n\na = 15\nb = 4\nprint(a/b)\nprint(\"a // b =\", a // b)  \nprint(\"a % b =\", a % b)    \nprint(\"a ** b =\", a ** b)  \n\n3.75\na // b = 3\na % b = 3\na ** b = 50625\n\n\n\n\n3.2 比较运算符\n比较运算符用于比较两个值，结果为布尔类型（True或 False ）。\n\nprint(\"a &gt; b:\", a &gt; b)\nprint(\"a == b:\", a == b)   \nprint(\"a != b:\", a != b)   \n\na &gt; b: True\na == b: False\na != b: True\n\n\n\n\n3.3 逻辑运算符\n逻辑运算符用于连接多个条件表达式，常用于复合条件判断。\n\nx = 8\ny = 3\n#\nprint((x &gt; 5) and (y &lt; 5))  \nprint((x &lt; 5) or (y &lt; 5))   \nprint(not (x &gt; y))          \n\nTrue\nTrue\nFalse\n\n\n要注意and 和or组合的结果。\n\nprint(True and False)\nprint(True or False)\n\nFalse\nTrue\n\n\n\n\n3.4 赋值运算符\n赋值运算符用于给变量赋值或在原有基础上进行运算后赋值:\n\nx = 10      \nx += 5   \nx -= 3   \nx *= 2   \nx /= 4   \nx //= 2  \nx %= 2   \nx **= 3  \n#\nprint(x)\n\n1.0\n\n\n\n\n3.5 成员运算符\n成员运算符用于判断某个元素是否属于某个序列，如列表、元组、字符串等。例如：\n\nprint('is' in 'this')\n\nfor i in range(5):\n  print(i)\n\nTrue\n0\n1\n2\n3\n4",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#控制结构条件与循环",
    "href": "python_basics.html#控制结构条件与循环",
    "title": "Python 语言基础",
    "section": "4 控制结构：条件与循环",
    "text": "4 控制结构：条件与循环\n\n4.1 条件语句\n条件语句（if语句）用于根据条件判断执行不同的代码块，基本结构：\n\n# if 条件:\n#     代码块1\n# elif 其他条件:\n#     代码块2\n# else:\n#     代码块3\n\n例如，使用if-esle判断是奇数还是偶数。注意缩进：\n\nnum = 8\nif num%2 == 0:\n    print(f\"{num} is even.\")\nelse:\n    print(f\"{num} is odd.\")\n\n8 is even.\n\n\n以世界银行经济体收入分组标准为例：\n世界银行按照人均国民收入把世界各经济体分成四组，如 Table 2 所示，中、低收入国家被称为发展中国家，高收入国家被称为发达国家。\n\n\n\nTable 2: 世界银行经济体收入分组标准\n\n\n\n\n\n经济体分组\n划分标准（人均国民总收入）\n\n\n\n\n低收入经济体\n1145 美元以下\n\n\n中等偏下收入经济体\n1146—4515 美元\n\n\n中等偏上收入经济体\n4516—14005 美元\n\n\n高收入经济体\n14005 美元以上\n\n\n\n\n\n\n可以使用嵌套条件语句if-elif-else来进行判别：\n\ngni = 13660\n\nif gni &lt;= 1135:\n    economy = \"低收入经济体\"\nelif gni &lt;= 4465:\n    economy =  \"中等偏下收入经济体\"\nelif gni &lt;= 13845:\n    economy = \"中等偏上收入经济体\"\nelse:\n    economy = \"高收入经济体\"\n\nprint(f\"人均国民总收入为 {gni} 美元，属于：{economy}\")\n\n人均国民总收入为 13660 美元，属于：中等偏上收入经济体\n\n\n再来看一个计算BMI（Body Mass Index）指数的例子： \\[\nBMI = \\frac{weight(kg)}{height(m)^{2}}\n\\]\n\nheight = 1.75 \nweight = 75 \n\n# 计算BMI\nbmi = weight / (height ** 2)\n\nif bmi &lt; 18.5:\n    status = \"偏瘦\"\nelif bmi &lt; 24:\n    status = \"正常\"\nelif bmi &lt; 28:\n    status = \"超重\"\nelse:\n    status = \"肥胖\"\nprint(f\"BMI = {bmi:.2f}，{status}\")\n\nBMI = 24.49，超重\n\n\n\n\n4.2 循环\nPython 中主要有两种循环结构：for 循环和 while 循环。 for 循环用于遍历序列（如列表、字符串、元组等）或可迭代对象中的元素，而 while 循环则在给定条件为真时重复执行一段代码。\n例如，对列表中的元素循环：\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n    print(fruit)\n\napple\nbanana\ncherry\n\n\n下面的例子计算从1到100之和，注意range()函数的用法：\n\ntotal = 0\nfor i in range(1, 101):\n    total += i\nprint(\"1到100的和为：\", total)\n\n1到100的和为： 5050\n\n\nwhile循环是一种基于条件判断的循环结构，当条件为True时，循环体会反复执行，直到条件变为False为止。另外， while循环要注意循环变量的更新，否则可能会造成死循环。\n例如，同样计算1到100的和\n\ntotal = 0\nn = 1\nwhile n &lt;= 100:\n    total += n\n    n += 1\nprint(\"1到100的和为：\", total)\n\n1到100的和为： 5050",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#容器类型列表字典元组集合",
    "href": "python_basics.html#容器类型列表字典元组集合",
    "title": "Python 语言基础",
    "section": "5 容器类型：列表、字典、元组、集合",
    "text": "5 容器类型：列表、字典、元组、集合\n列表（list）、字典（dict）、元组（tuple）、集合（set）是Python中常用的容器类型。\n\n字典：用{}定义，键值对结构\n元组：用()定义，有序不可变\n集合：用set()或{}定义，无序不重复\n\n\n5.1 列表\n列表是最常用的数据类型之一，新建列表用[]进行定义。可以用索引（从0开始）访问列表的元素。\n\nnumbers = [10, 20, 30, 40]\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nprint(numbers[0])\nprint(fruits[-1])\n\n10\ncherry\n\n\n可以根据索引使用:对列表进行切片（slicing）。\n\nprint(numbers[1:3])     \nprint(numbers[::-1])\n\n[20, 30]\n[40, 30, 20, 10]\n\n\n列表是可变的（mutatable），元素可以更改。例如，将numbers的第2个元素（索引1）的值替换为25：\n\nnumbers[1] = 25\nprint(numbers)         \n\n[10, 25, 30, 40]\n\n\n可以使用.append()、.insert()方法往列表添加元素:\n\nfruits.append(\"orange\")  \nfruits.insert(1, \"pear\") \nprint(fruits)                 \n\n['apple', 'pear', 'banana', 'cherry', 'orange']\n\n\ndel .remove()和.pop()都可以用来删除元素：\n\ndel numbers[2]                 # 按索引删除\nfruits.remove(\"banana\")        # 按值删除\nprint(numbers)                 \nprint(fruits)                  \nfruit = fruits.pop()\nprint(fruit)\n\n[10, 25, 40]\n['apple', 'pear', 'cherry', 'orange']\norange\n\n\n经常涉及遍历列表的操作，尤其是for循环：\n\nfor fruit in fruits:\n    print(fruit)\n\napple\npear\ncherry\n\n\n例：计算净现值\n如果某项资产在多个时间周期内支付一系列收益流，那么我们可以使用贴现率来计算这整个收益序列对消费者的当前价值。 用 \\(y_t\\) 表示第 \\(t\\) 期的收益，并假设这些收益现在是已知的，贴现率 \\(r\\ge 0\\)。用一个求和表达式来表示整条收益序列的净现值总价值：\n\\[\nP_{0} = \\sum_{t=0}^{T} (\\frac{1}{1+r})^{t}y_{t}\n\\]\n将假设的收益序列保存为列表： y = [-100, 30, 60, 50, 40]，贴现率假设为0.05。我们用遍历列表的方法求和：\n\ny = [-100, 30, 60, 50, 40]\nr = 0.05\nP0 = 0\nfor t in range(len(y)):\n    P0 = P0 + y[t] / (1 + r) ** t\nprint(f\"The Total Present Value = ：{P0:.2f}\")\n\nThe Total Present Value = ：59.09\n\n\n\n\n5.2 元组\n元组（tuple）是有序、不可变的元素集合，用()表示。\n\npoint = (3, 4)\ncolors = (\"red\", \"green\", \"blue\")\n\n# 访问元素\nprint(point[0])                # 3\nprint(colors[-1])              # blue\n\n# 元组不可修改\n# point[1] = 5  # 会报错\n\n# 单元素元组要加逗号\nsingle = (5,)\nprint(type(single))            # &lt;class 'tuple'&gt;\n\n3\nblue\n&lt;class 'tuple'&gt;\n\n\n元组可以用于多变量赋值，许多函数返回的结果是元组的形式。\n\nx, y = point\nprint(x, y) \n\n3 4\n\n\n例：Jarque-Bera 正态性检验\n给定 \\(n\\)个观测值的样本，样本偏度为： \\[\nS = \\frac{\\hat{\\mu}_{3}}{\\hat{\\sigma}^{3}} = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{3}}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2})^{3/2}}\n\\]\n样本峰度为： \\[\nK = \\frac{\\hat{\\mu}_{4}}{\\hat{\\sigma}^{4}} = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{4}}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2})^{2}}\n\\]\nJarque-Bera正态性检验的核心思想是，如果一个数据集服从正态分布，那么它的偏度和峰度应该分别接近于0和3。统计量定义为： \\[\nJarque-Bera = \\frac{n}{6}\\left(S^{2} + \\frac{1}{4}(K - 3)^{2}\\right)\n\\]\n我们用Scipy库的stats.jarque_bera()函数为例:\n\nimport scipy.stats as sc\nimport numpy as np\nnp.random.seed(123)\nx = np.random.normal(loc=0, scale=1, size=100)\n\ns, p = sc.jarque_bera(x=x)\nprint(f\"Jarque-Berat Statistics = {s:.3f}, p-value = {p:.3f}\")\n\nJarque-Berat Statistics = 1.734, p-value = 0.420\n\n\n\n\n5.3 字典\n字典（dict）是一种用于存储键值对的数据结构。每个元素由“键”（key）和“值”（value）组成，键必须唯一且不可变，值可以是任意类型。 字典用大括号{}表示，键和值之间用冒号:分隔，多个键值对之间用逗号，分隔。\n例如，下面是江苏省2023年的一些社会经济指标：\n\njiangsu = {\"population\": 8526,\n           \"employment\": 4840,\n           \"GDP\": 128222.16}\nprint(jiangsu)\nprint(jiangsu[\"population\"])   \n\n{'population': 8526, 'employment': 4840, 'GDP': 128222.16}\n8526\n\n\n可以很方便地往字典中添加或修改元素\n\njiangsu['capital city'] = \"Nan jing\"\nprint(jiangsu)\n\n{'population': 8526, 'employment': 4840, 'GDP': 128222.16, 'capital city': 'Nan jing'}\n\n\n可以使用for循环 遍历字典，\n\nfor key, value in jiangsu.items():\n    print(key, value)\n\npopulation 8526\nemployment 4840\nGDP 128222.16\ncapital city Nan jing\n\n\n应用：利用字典进行词频统计\n统计一段文本中每个单词出现的次数，例如统计下面英文歌词代词出现的次数。首先将字母转化为小写字母，然后利用字符的切分方法.split()，将结果保存在字典freq之中，然后按词频排序，注意使用了lambda函数的方法。\n\ntext = \"\"\"Generals gathered in their masses\nJust like witches at black masses\nEvil minds that plot destruction\nSorcerer of death's construction\nIn the fields, the bodies burning\nAs the war machine keeps turning\nDeath and hatred to mankind\nPoisoning their brainwashed minds\nOh, Lord, yeah\nPoliticians hide themselves away\nThey only started the war\nWhy should they go out to fight?\nThey leave that role to the poor, yeah\nTime will tell on their power minds\nMaking war just for fun\nTreating people just like pawns in chess\nWait 'til their judgement day comes, yeah\nNow in darkness, world stops turning\nAshes where their bodies burning\nNo more war pigs have the power\nHand of God has struck the hour\nDay of judgement, God is calling\nOn their knees, the war pigs crawling\nBegging mercy for their sins\nSatan laughing, spreads his wings\nOh, Lord, yeah\n\"\"\"\n\nwords = text.lower().split()\nfreq = {}\n\nfor word in words:\n    if word in freq:         # 判断单词是否已在字典中\n        freq[word] += 1\n    else:\n        freq[word] = 1\n\nsorted_freq = sorted(freq.items(), \n                      key=lambda item: item[1], \n                      reverse=True)\n\nfor word, count in sorted_freq[:10]:\n    print(f\"{word}: {count}\")\n\nthe: 8\ntheir: 7\nwar: 5\nin: 4\nyeah: 4\njust: 3\nminds: 3\nof: 3\nto: 3\nthey: 3",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#函数与模块",
    "href": "python_basics.html#函数与模块",
    "title": "Python 语言基础",
    "section": "6 函数与模块",
    "text": "6 函数与模块\n\n6.1 内置函数的调用\nPython内置函数是系统自带的、可以直接使用的函数，无需导入模块。常见内置函数有：abs(), len(),max(), min(), sum(), type(), int(), float(), str(), list(), dict(), range() 等。\n\nprint(abs(-10))\nlst = [1, 2, 3, 4]\nprint(len(lst))\nprint(max(5, 8, 2))\nprint(min([7, 3, 9]))\n\nprint(sum([1, 2, 3]))    \n\n10\n4\n8\n3\n6\n\n\n\n\n6.2 自定义函数\n自定义函数使用def关键字，指定函数名、参数列表和函数体。下面是几个简单的自定义函数的例子。\n例如，定义一个不包含参数的函数print_hello()，其唯一作用是显示Hello World!：\n\ndef print_hello():\n    print(\"Hello World!\")\n\nprint_hello()\n\nHello World!\n\n\n函数通常带有参数，下面的例子定义了一个计算圆的面积的例子，需要输入参数半径radius的值：\n\nimport math\ndef area(radius):\n    res = math.pi * radius ** 2\n    print(f\"半径为 {radius} 的圆的面积为 {res:.2f}!\")\narea(radius=2)\n\n半径为 2 的圆的面积为 12.57!\n\n\n这个函数运行的结果是在屏幕上显示一行字。如果将运行结果赋值给变量，结果如何？\n\nres = area(radius=2)\nprint(res)\n\n半径为 2 的圆的面积为 12.57!\nNone\n\n\n看到结果显示的是None。原因在于函数定义时并没有返回结果，这就需要return结果：\n\nimport math\ndef area(radius):\n    return math.pi * radius ** 2\n\nradius = 2\nres = area(radius)\nprint(f\"半径为 {radius} 的圆的面积为 {res:.2f}!\")\n\n半径为 2 的圆的面积为 12.57!\n\n\n再例如，给定列表中都是数值，计算其平均数：\n\ndef mean(numbers):\n    total = sum(numbers)\n    N = len(numbers)\n    avg = total / N\n\n    return avg\nnums = [3, 8, 1, 6]\nprint(mean(nums))\n\n4.5\n\n\n定义的函数经常会带有默认参数值，在调用函数时可以省略输入参数。例如下面的Cobb-Douglas生产函数的例子。\n例：定义Cobb-Douglas函数\nCobb-Douglas生产函数是经济学中最常见的函数设定，例如一个规模报酬不变的CD函数表示为： \\[\nY = AK^{\\alpha}L^{1-\\alpha}\n\\]\n其中，\\(\\alpha\\) 表示资本的产出弹性，\\(A\\) 表示全要素生产率。下面定义一个CD函数，默认参数值 \\(\\alpha = 1/3, A = 1\\)。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef cobb_douglas(K, L, alpha = 1/3, A = 1):\n    output = A * K**alpha * L**(1 - alpha)\n    return output\ncobb_douglas(K=1, L=0.5)\n\n0.6299605249474366\n\n\n从微观经济学内容我们知道，等产量曲线是带来相同产出的要素组合 \\((K, L)\\) 形成的曲线，可以应用matplotlib中的contour函数绘制上面函数定义的等产量曲线：\n\n# 生成K和L的网格\nK = np.linspace(0.1, 2, 100)\nL = np.linspace(0.1, 2, 100)\nK_grid, L_grid = np.meshgrid(K, L)\n\nY = cobb_douglas(K_grid, L_grid, alpha=1/2)\n# \nfig, ax = plt.subplots(figsize=(8, 6), dpi=300)\ncontours = ax.contour(K_grid, L_grid, Y, levels=8, cmap='viridis')\nax.clabel(contours, inline=True, fontsize=8)\nax.set_xlabel('K')\nax.set_ylabel('L')\nax.set_title('Cobb-Douglas isoquant')\nax.grid(True, linestyle='--', alpha=0.5)\nplt.show()\n\n\n\n\n\n\n\n\n函数也可以有多个返回值（返回元组）\n\ndef min_max(numbers):\n    return min(numbers), max(numbers)\n\nnums = [3, 8, 1, 6]\nmin, max = min_max(nums)\n\n可变参数：*args 接收任意数量的位置参数，类型为元组\n\ndef total(*args):\n    return sum(args)\n\nprint(total(1, 2, 3))\nprint(total(5, 10))  \n\n6\n15\n\n\n关键字参数：**kwargs 接收任意数量的关键字参数，类型为字典\n\ndef show_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nshow_info(name=\"Alice\", age=20)\n\nname: Alice\nage: 20\n\n\n\n\n6.3 自定义函数的例子\nBMI指数函数\n同样，也可以将上面计算BMI指数的过程，定义为一个函数：\n\ndef bmi(height, weight):\n    \"\"\"计算BMI指数并返回数值和健康状况\"\"\"\n    bmi = weight / (height ** 2)\n    if bmi &lt; 18.5:\n        status = \"偏瘦\"\n    elif bmi &lt; 24:\n        status = \"正常\"\n    elif bmi &lt; 28:\n        status = \"超重\"\n    else:\n        status = \"肥胖\"\n    return bmi, status\n\n# 示例调用\nbmi, status = bmi(1.75, 75)\nprint(f\"BMI = ：{bmi:.2f}，{status}\")\n\nBMI = ：24.49，超重\n\n\n世界银行经济体分组\n自定义函数常与其他功能结合使用，例如Pandas库的df.apply()方法。\n将前面例子中的if语句代码，赋值粘贴至某一个AI大模型平台，输入提示：“将下面的Python代码定义为一个函数”。得到类似下面的函数：\n\ndef classify_economy(gni):\n    if gni &lt;= 1135:\n        economy = \"低收入经济体\"\n    elif gni &lt;= 4465:\n        economy = \"中等偏下收入经济体\"\n    elif gni &lt;= 13845:\n        economy = \"中等偏上收入经济体\"\n    else:\n        economy = \"高收入经济体\"\n    return economy\ne = classify_economy(13500)\nprint(e)\n\n中等偏上收入经济体\n\n\n然后我们将该函数应用至世界银行数据。\n我们需要从World Bank数据库下载2024年GDP per capita (current US$)数据，.dropna()函数用于删除缺失值，然后对列[‘NY.GDP.PACP.CD’]应用自定义的classify_economy()函数：\n\nimport pandas as pd\nimport wbgapi as wb\ngdp_pc_2024 = wb.data.DataFrame(\"NY.GDP.PCAP.CD\", time = 2024)\ngdp_pc_2024 = gdp_pc_2024.dropna()\ngdp_pc_2024['NY.GDP.PCAP.CD'].apply(classify_economy)\n\neconomy\nAFE    中等偏下收入经济体\nAFW    中等偏下收入经济体\nAGO    中等偏下收入经济体\nALB    中等偏上收入经济体\nAND       高收入经济体\n         ...    \nXKX    中等偏上收入经济体\nYEM       低收入经济体\nZAF    中等偏上收入经济体\nZMB    中等偏下收入经济体\nZWE    中等偏下收入经济体\nName: NY.GDP.PCAP.CD, Length: 232, dtype: object\n\n\n\n\n6.4 模块的导入与使用\nPython的模块（module）是包含一组功能的代码文件，可以通过import语句导入并使用其中的函数、变量等。分为三类： - python自带模块，不需要安装，直接import载入就可以了，如math包； - 第三方模块，通常需要下载安装，然后载入，如numpy，scipy等； - 自定义模块，自己写的实现某些功能的py文件的集合。\n上面的例子中，实际上已经出现多次模块载入的应用，如Pandas、Numpy、Matplotlib等。\n\nimport math\nprint(math.sqrt(16))     \nprint(math.pi)           \n#\nfrom random import randint\nprint(randint(1, 10))    \n\n#\nimport datetime as dt\nnow = dt.datetime.now()\nprint(now)\n\n4.0\n3.141592653589793\n6\n2025-08-13 18:48:09.334453\n\n\n可以把自定义的函数等保存在.py格式等脚本文件中，自定义模块。例如，在文件夹pyfiles中my_module.py文件保存了一个计算BMI的函数，我们载入该函数然后进行计算：\n\nfrom pyfiles.my_module import bmi_index\n# \nbmi, status = bmi_index(1.75, 75)\nprint(f\"BMI = {bmi:.2f}\")\nprint(f\"健康状况：{status}\")\n\nBMI = 24.49\n健康状况：超重",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "python_basics.html#面向对象的编程",
    "href": "python_basics.html#面向对象的编程",
    "title": "Python 语言基础",
    "section": "7 面向对象的编程",
    "text": "7 面向对象的编程\nPython 是面向对象编程的语言。面向对象编程（Object Oriented Programming，OOP）是一种程序设计思想。它把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，相同属性和操作方法的对象被抽象为类。类（Class）就类似上面所说的模具，而对象（Object）就是使用模具生产出的零件，对象就是类的实例（Instance）。\n\n7.1 对象\n类（class）是面向对象编程（OOP）的核心概念，用于描述具有相同属性和方法的一类对象的模板或蓝图。 对象（object）是类的实例，拥有类定义的属性和方法。\n所有的数据类型，值，变量，函数，类，实例等等一切可操作的基本单元在 Python 都使用对象（Object）表示。每个对象有三个基本属性：ID，类型和值，也即有一块内存中存储了一个对象，这块内存中一定存有这三个属性。\n\na = 1\nprint(id(a), type(a), a)\nprint(id(bmi_index), type(bmi_index), bmi_index)\n\n140709394203560 &lt;class 'int'&gt; 1\n2353797050464 &lt;class 'function'&gt; &lt;function bmi_index at 0x00000224093CB060&gt;\n\n\n0x0000024FE78C6AC0 是这个函数在计算机内存中的地址。\n\n\n7.2 定义一个简单的类\n下面定义一个简单的类Student，它具有两个属性name、age，和一个方法introduce()：\n\nclass Student，定义了一个类，名为Student；\ndef __init__(self, name, age)，__init__ 是一个特殊的方法，被称为构造方法。当创建一个类的实例（也就是一个对象）时，它会自动被调用，主要作用是初始化对象的属性；\nself 是一个约定俗成的参数，它代表了正在被创建的那个对象本身。Python 通过 self 来知道操作的是哪个具体的对象。\nname 和 age 是在创建对象时需要传入的参数，它们将被用来设置对象的初始属性。\nself.name = name 和 self.age = age，将传入的 name 和 age 参数的值赋给了对象的属性，这里分别存储学生的名字和年龄；\ndef introduce(self)，定义introduce方法，它定义了 Student 对象可以执行的一个行为这里是打印一段包含学生姓名和年龄的自我介绍。\nstu1 = Student(name=\"Alice\", age=20)，创建了一个具体的对象，或者说实例，并将其赋值给变量 stu1。此时调用了 Student 类的构造方法 __init__，将 \"Alice\" 赋给 name，20 赋给 age。\nstu1.introduce()，调用了 stu1 对象的 introduce 方法。\n\n\n\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def introduce(self):\n        print(f\"Hello，My name is {self.name}，I'm {self.age} years old.\")\n \nstu1 = Student(name=\"Alice\", age=20)\nstu2 = Student(name=\"Bob\", age=22)\n \nstu1.introduce()\nstu2.introduce()\n\nHello，My name is Alice，I'm 20 years old.\nHello，My name is Bob，I'm 22 years old.\n\n\n\n\n7.3 例：定义一个局部均衡分析模型\n微观经济学中，简单的局部均衡市场模型表示为: \\[\n\\begin{cases}\nQ_{D} = a - b\\times P \\\\\nQ_{S} = c + d\\times P \\\\\nQ_{D} = Q_{S}\n\\end{cases}\n\\]\n我们定义一个类Market，将参数定义为属性，将需求、供给和均衡条件定义为三个方法：\n\ndemand计算给定价格的需求量；\nsupply计算给定价格的供给量\nequilibrium计算均衡价格和均衡数量;\n\n\nclass Market:\n    def __init__(self, a, b, c, d):\n        \"\"\"        \n        Qd = a - b*P\n        Qs = c + d*P\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    def demand(self, P):        \n        return self.a - self.b * P\n\n    def supply(self, P):        \n        return self.c + self.d * P\n\n    def equilibrium(self):\n        \"\"\"\n        Qd = Qs\n        \"\"\"\n        # a - b*P = c + d*P\n        # (a - c) = (b + d)*P        \n        P_eq = (self.a - self.c) / (self.b + self.d)\n        Q_eq = self.demand(P_eq)\n        return P_eq, Q_eq\n\n# \nmarket = Market(a=100, b=2, c=20, d=3)\nP_star, Q_star = market.equilibrium()\nprint(f\"Equilibrium Price = {P_star:.2f}\")\nprint(f\"Equilibrium Quantity = {Q_star:.2f}\")\n\nEquilibrium Price = 16.00\nEquilibrium Quantity = 68.00\n\n\n可以利用定义的market类中的方法绘制需求曲线和供给曲线：\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 生成价格区间\nP = np.linspace(0, 50, 200)\nQd = [market.demand(p) for p in P]\nQs = [market.supply(p) for p in P]\n\n# 绘图\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(Qd, P, label=\"Demand Qd\", color=\"blue\")\nax.plot(Qs, P, label=\"Supply Qs\", color=\"orange\")\nax.scatter(Q_star, P_star, color=\"red\", zorder=5)\nax.annotate(f\"Equilibrium\\n(Q={Q_star:.1f}, P={P_star:.1f})\",\n             xy=(Q_star, P_star), xytext=(Q_star+10, P_star+5),\n             arrowprops=dict(arrowstyle=\"-&gt;\", color=\"red\"))\nax.set_xlabel(\"Q\")\nax.set_ylabel(\"P\")\nax.legend()\nax.grid(True, linestyle=\"--\", alpha=0.5)\nplt.show()",
    "crumbs": [
      "Python基础",
      "Python基础"
    ]
  },
  {
    "objectID": "numpy.html",
    "href": "numpy.html",
    "title": "Numpy 和 Scipy",
    "section": "",
    "text": "有许多种方法创建数组，下面是一些简单的例子，使用np.array()函数，将列表、元组转化为数组：\n\nimport numpy as np\n\na = np.array([1, 2, 3, 4])\nprint(a)\n\n[1 2 3 4]\n\n\n注意，与列表不同，Numpy数组只能包含相同类型的数据，下面的例子中，np.array()函数自动将列表中的整数转换为浮点数：\n\nb = np.array([3.14, 4, 2, 3])\nb\n\narray([3.14, 4.  , 2.  , 3.  ])\n\n\n列表总是一维的，Numpy数组可以是多维的，例如下面的例子使用：\n\ndata = np.array([[1.5, -0.1, 3],\n                [0, -3, 6.5]])\nprint(data)\n\n[[ 1.5 -0.1  3. ]\n [ 0.  -3.   6.5]]\n\n\n数组data是二维数组，可以查看属性ndim和shape：\n\ndata.ndim\ndata.shape\n\n(2, 3)\n\n\n可以对data进行通常的数学运算：\n\nprint(data * 10)\nprint(data + data)\n\n[[ 15.  -1.  30.]\n [  0. -30.  65.]]\n[[ 3.  -0.2  6. ]\n [ 0.  -6.  13. ]]\n\n\nNumpy也有函数来生成一些特定格式的数组,如表 Table 1 所示：\n\n\n\nTable 1: Numpy中生成数组的函数\n\n\n\n\n\n\n\n\n\n函数名\n描述\n\n\n\n\narray\n将输入数据（列表、元组、数组或其他序列类型）转换为 ndarray，可以自动推断或显式指定数据类型；默认会复制输入数据\n\n\nasarray\n将输入转换为 ndarray，如果输入已经是 ndarray，则不会进行复制\n\n\narange\n类似于内置的 range，但返回的是 ndarray 而不是列表\n\n\nones, ones_like\n生成给定形状和数据类型的全 1 数组；ones_like 以另一个数组为模板，生成相同形状和数据类型的全 1 数组\n\n\nzeros, zeros_like\n类似于 ones 和 ones_like，但生成的是全 0 数组\n\n\nempty, empty_like\n通过分配新内存创建新数组，但不会像 ones 和 zeros 那样填充值\n\n\nfull, full_like\n生成给定形状和数据类型的数组，所有值都设置为指定的“填充值”；full_like 以另一个数组为模板，生成相同形状和数据类型的填充值数组\n\n\neye,identity\n生成单位矩阵（对角线为 1，其余为 0）\n\n\n\n\n\n\n\nzeros = np.zeros(10)\nprint(zeros)\nones = np.ones((2,3), dtype=float)\nprint(ones)\n# 单位矩阵\nidents = np.identity(3)\nprint(idents)\n\nevens = np.arange(0, 20, 2)\nprint(evens)\ngrids = np.linspace(0, 1, 21)\nprint(grids)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[1. 1. 1.]\n [1. 1. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[ 0  2  4  6  8 10 12 14 16 18]\n[0.   0.05 0.1  0.15 0.2  0.25 0.3  0.35 0.4  0.45 0.5  0.55 0.6  0.65\n 0.7  0.75 0.8  0.85 0.9  0.95 1.  ]\n\n\nNumpy中random子库包含丰富的生成随机数的函数，例如：\n\n#生成正态分布\nnums_norm = np.random.normal(loc=0, scale=1, size=(4, 3))\nprint(nums_norm)\nnums_int = np.random.randint(low=1, high=11, size=(2, 10))\nprint(nums_int)\n\n[[-1.37539399  1.26851301 -0.58911433]\n [ 0.71198134 -0.21477278 -0.66124069]\n [-0.67356475  1.05377389  0.43696482]\n [-1.42191885 -0.81106133  0.05037252]]\n[[ 3 10  8  4  6  7  5  8  4  8]\n [ 9  8  9  2 10 10  7  9  8  7]]\n\n\n\n\n\n注意索引与列表一样，从0开始；选择元素时不包括右侧。\n\nz = np.array((1,2,3,4,5))\nz[0]\nz[0:2]\nz[-1]\nz[::2]\nz[::-1]\n# 2D arrays\nz = np.array([[1,2],\n              [3, 4]])\nz[0,0]\nz[0,:]\nz[:,1]\n\narray([2, 4])\n\n\n\n\n\n数组方法众多，例如：\n代码段\n\na = np.array((4,3,2,1))\na.sort()\n\na.sum()\na.mean()\na.max()\na.min()\na.var()\na.std()\na.argmax()\na.cumsum()\na.cumprod()\n\narray([ 1,  2,  6, 24])\n\n\n\n\n\n注意，运算符 +, - , *, / 和 **，都是逐元素运算。例如：\n\na = np.array([1,2,3,4])\nb = np.array([5,6,7,8])\na + b\na * b\na + 10\na * 10\n# 2D array\nA = np.ones((2,2))\nB = np.ones((2,2))\nA + B\nA+10\nA * B\n(A+1) ** 2\n\narray([[4., 4.],\n       [4., 4.]])\n\n\n可以使用 @ 或 np.dot() 进行矩阵乘法。如果是向量则计算内积。\n\nA = np.array([[1,2],\n              [3,4]])\nB = np.array([[5,6,],\n              [7,8]])\nA@B\n#or\nnp.dot(A,B)\n#\nb = np.array([0, 1])\nA@b\n\narray([2, 4])\n\n\n\n\n\nNumpy中有一些列简便运算的函数。例如 np.poly1d()，多项式求和:\n\\[p(x) = a_{0} + a_{1}x + a_{2}x^{2} + \\cdots + a_{N}x^{N} = \\sum_{n=0}^{N}a_{n}x^{n} \\]\n\np = np.poly1d([1,2,3])\nprint(p)\nprint(p(2))\n\n   2\n1 x + 2 x + 3\n11\n\n\n注意，np.poly1d() 函数高阶项在前面。\n利用向量计算，自定义一个函数：\n\ndef poly1d(x, coef):\n    X = np.ones_like(coef)\n    X[1:] = x\n    y = np.cumprod(X) # y = [1,x,x**2,...]\n    return coef @ y[::-1]\n\ncoef = [1, 2, 3]\npoly1d(2, coef=coef)\n\nnp.int64(11)\n\n\n\n\n\nNumpy中有大量的与随机数生成器有关的函数。\n下面是一个例子，注意，没有设定随机种子数，因此每次运行结果会不同。\n\nimport numpy as np\n\n# Define an array of choices\nchoices = np.array(['apple', 'banana', 'orange', 'grape', 'kiwi'])\n\n# Perform random choice\nrandom_choice = np.random.choice(choices)\n\n# Print the random choice\nprint(random_choice)\n\napple\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 设置随机种子以便复现\nnp.random.seed(0)\n\n# 步数\nn_steps = 1000\n\n# 生成每一步的随机步长（-1 或 1）\nsteps = np.random.choice([-1, 1], size=n_steps)\n\n# 计算随机游走序列\nwalk = np.cumsum(steps)\n\n# 绘制线形图\nplt.plot(walk)\nplt.title('Random Walk')\nplt.xlabel('Step')\nplt.ylabel('Position')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n中心极限定理 (Central Limit Theorem, CLT) 是概率论中一个非常强大的定理。它指出，当从任何形状的总体中抽取足够大的独立同分布 (i.i.d.) 样本时，这些样本均值的分布将近似于正态分布，无论原始总体分布如何。样本量越大，近似程度越好。\n我们将通过以下步骤来模拟验证 CLT：\n\n选择一个非正态分布的总体: 比如，一个指数分布或均匀分布，它们的形状都不是钟形的。\n设置样本参数: 定义每次抽样的样本大小 (sample_size) 和重复抽样的次数 (num_samples)。\n重复抽样并计算均值: 从总体中抽取 num_samples 次样本，每次抽取 sample_size 个数据点，并计算每次抽样的平均值。\n可视化: 绘制样本均值的直方图，并与原始总体分布的直方图进行对比。\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams['font.family'] = 'SimHei'\nplt.rcParams['axes.unicode_minus'] = False\n\n# --- 1. 设置模拟参数 ---\npopulation_size = 1000000  # 原始总体的大小\nsample_size = 30           # 每次抽样的样本量 (通常大于30就被认为是“大样本”)\nnum_samples = 10000        # 重复抽样的次数，即我们将有多少个样本均值\nnp.random.seed(123)\n\n# --- 2. 选择一个非正态分布的总体 (例如：指数分布) ---\n# 指数分布 (Exponential Distribution) 是一种偏态分布，非常适合验证CLT\n# numpy.random.exponential(scale=1.0, size=None)\n# scale 参数是均值，这里我们设置均值为2.0\npopulation_data = np.random.exponential(scale=2.0, size=population_size)\n# 也可以用均匀分布作为总体进行验证\n# population_data_uniform = np.random.uniform(low=0.0, high=10.0, size=population_size)\n\n# --- 3. 重复抽样并计算均值 ---\nsample_means = []\nfor _ in np.arange(num_samples):\n    # 从总体中随机抽取 sample_size 个数据点\n    sample = np.random.choice(population_data, size=sample_size, replace=True)\n    # 计算样本的均值并添加到列表中\n    sample_means.append(np.mean(sample))\n\n# 将样本均值列表转换为 NumPy 数组，方便后续处理和绘图\nsample_means = np.array(sample_means)\n\n# --- 4. 可视化结果 ---\nplt.figure(figsize=(12, 12))\n\n# 绘制原始总体分布的直方图\nplt.subplot(2, 1, 1) # 1行2列的第一个图\nplt.hist(population_data, bins=50, density=True, color='skyblue', edgecolor='black', alpha=0.7)\nplt.title(f'原始总体分布 (指数分布)\\n均值: {np.mean(population_data):.2f}, 标准差: {np.std(population_data):.2f}')\nplt.xlabel('值')\nplt.ylabel('频率密度')\nplt.grid(True, linestyle='--', alpha=0.6)\n\n# 绘制样本均值分布的直方图\nplt.subplot(2, 1, 2) # 1行2列的第二个图\nplt.hist(sample_means, bins=50, density=True, color='lightcoral', edgecolor='black', alpha=0.7)\nplt.title(f'样本均值的分布 ({sample_size}个样本量，重复{num_samples}次)\\n均值: {np.mean(sample_means):.2f}, 标准差: {np.std(sample_means):.2f}')\nplt.xlabel('样本均值')\nplt.ylabel('频率密度')\nplt.grid(True, linestyle='--', alpha=0.6)\n\nplt.tight_layout() # 调整子图布局，避免重叠\nplt.show()\n\n# --- 5. 额外验证：比较均值和标准差 ---\nprint(\"\\n--- 模拟结果验证 ---\")\nprint(f\"原始总体的均值 (μ): {np.mean(population_data):.4f}\")\nprint(f\"原始总体的标准差 (σ): {np.std(population_data):.4f}\")\nprint(f\"样本均值的均值 (μ_x̄): {np.mean(sample_means):.4f}\")\n# 根据中心极限定理，样本均值的标准差 (标准误差) 应该约等于 总体标准差 / sqrt(样本量)\nexpected_std_of_means = np.std(population_data) / np.sqrt(sample_size)\nprint(f\"样本均值的标准差 (σ_x̄): {np.std(sample_means):.4f}\")\nprint(f\"理论上样本均值的标准差 (σ / sqrt(n)): {expected_std_of_means:.4f}\")\n\n\n\n\n\n\n\n\n\n--- 模拟结果验证 ---\n原始总体的均值 (μ): 1.9988\n原始总体的标准差 (σ): 1.9992\n样本均值的均值 (μ_x̄): 1.9984\n样本均值的标准差 (σ_x̄): 0.3653\n理论上样本均值的标准差 (σ / sqrt(n)): 0.3650\n\n\n\n\n\n\nNumpy中许多函数是通用函数(universal functions)，是一种在 ndarray 数据中进行逐元素操作的函数，大多数数学函数属于此类。\n例如 np.cos() 函数：\n\nnp.cos(1.0)\nnp.cos(np.linspace(0, 1, 3))\n\narray([1.        , 0.87758256, 0.54030231])\n\n\n例如，我们想计算\\(\\frac{0}{1},\\frac{1}{2},\\cdots, \\frac{4}{5}\\):\n\nnp.arange(5) / np.arange(1, 6)\n\narray([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])\n\n\n\n\n\nTable 2: Numpy中算术运算子和函数\n\n\n\n\n\n\n\n\n\n\n\n运算符\n对应的 ufunc\n描述\n示例\n\n\n\n\n+\nnp.add\n加法\n1 + 1 = 2\n\n\n-\nnp.subtract\n减法\n3 - 2 = 1\n\n\n-\nnp.negative\n一元取反\n-2\n\n\n*\nnp.multiply\n乘法\n2 * 3 = 6\n\n\n/\nnp.divide\n除法\n3 / 2 = 1.5\n\n\n//\nnp.floor_divide\n向下取整除法\n3 // 2 = 1\n\n\n**\nnp.power\n幂运算\n2 ** 3 = 8\n\n\n%\nnp.mod\n取模/余数\n9 % 4 = 1\n\n\n\n\n\n\n\n\n\n考察最大化函数 \\(f(x,y)\\) 在区间 $ [−a,a] $ 上的最大值： \\[\nf(x,y)= \\frac{cos(x^{2} + y^{2})}{1 + x^2 + y^2}\n\\] ​ 令\\(a=3\\)。 我们定义一个函数，然后生成数组，计算对应的-值，通过栅格（grid）搜索最大值（等于1）。\n\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nimport matplotlib.pyplot as plt\n\ndef f(x, y):\n    return np.cos(x**2 + y**2) / (1 + x**2 + y**2)\n\ngrid = np.linspace(-3, 3, 50)\nx, y = np.meshgrid(grid, grid)\nz = f(x, y)\n\n# 最大值\nmax_value = np.max(z)\nprint(\"函数的最大值:\", max_value)\n\n# 绘制3D图像\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x, y, z, cmap='viridis')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x, y)')\nplt.show()\n\n函数的最大值: 0.9925310162998334\n\n\n\n\n\n\n\n\n\n图示\n\n\n\n\nimport numpy as np # 载入numpy库\ndef lorenz_curve(y):\n    n = len(y)\n    y = np.sort(y) # 从小到大排序\n    s = np.zeros(n + 1) # 生成n+1 个数值零\n    s[1:] = np.cumsum(y) # 从第2个数（索引1）累计求和，使第一个数据点为（0，0）\n    cum_people = np.linspace(0, 1, n + 1)\n    cum_income = s / s[n] # s[n]为最后的值，即所有值的和\n    return cum_people, cum_income\n\n\nn = 2000\nnp.random.seed(1)\nsample = np.exp(np.random.randn(n))\nf_vals, l_vals = lorenz_curve(sample)\n#\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(f_vals, l_vals, label=f'lognormal sample', lw = 2)\nax.plot([0, 1], [0, 1], label='equality', lw = 2)\nax.fill_between(f_vals,l_vals, f_vals, alpha=0.06)\nax.fill_between(f_vals, l_vals, np.zeros_like(f_vals),alpha=0.06)\nax.vlines([0.8], [0], [0.43], linestyles='--', colors='gray')\nax.hlines([0.43], [0], [0.8], linestyles='--', colors='gray')\nax.set_xlim((0,1))\nax.set_ylim((0,1))\nax.text(0.55, 0.4,\"A\", fontsize=16)\nax.text(0.75,0.15,\"B\",fontsize=16)\nax.set_xlabel('Cumulative share of people')\nax.set_ylabel('Cumulative share of income')\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\ndef gini(y):\n    n = len(y)\n    y_1 = np.reshape(y, (n, 1))\n    y_2 = np.reshape(y, (1, n))\n    g_sum = np.sum(np.abs(y_1 - y_2)) # 利用了numpy的广播（broadcasting）\n    return g_sum / (2 * n * np.sum(y))\n\n\n# 模拟对数正态数据\nnp.random.seed(1)\nk = 5\nsigmas = np.linspace(0.2, 4, k)\nn = 2000\nginis = []\nfor sigma in sigmas:\n    mu = -sigma ** 2 / 2\n    y = np.exp(mu + sigma * np.random.randn(n))\n    ginis.append(gini(y))\n\n\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(sigmas, ginis, marker = 'o',label='simulated', lw = 2)\nax.set_xlabel('Standard deviation')\nax.set_ylabel('Gini coefficient')\nax.legend()\nplt.show()"
  },
  {
    "objectID": "numpy.html#numpy-基础",
    "href": "numpy.html#numpy-基础",
    "title": "Numpy 和 Scipy",
    "section": "",
    "text": "有许多种方法创建数组，下面是一些简单的例子，使用np.array()函数，将列表、元组转化为数组：\n\nimport numpy as np\n\na = np.array([1, 2, 3, 4])\nprint(a)\n\n[1 2 3 4]\n\n\n注意，与列表不同，Numpy数组只能包含相同类型的数据，下面的例子中，np.array()函数自动将列表中的整数转换为浮点数：\n\nb = np.array([3.14, 4, 2, 3])\nb\n\narray([3.14, 4.  , 2.  , 3.  ])\n\n\n列表总是一维的，Numpy数组可以是多维的，例如下面的例子使用：\n\ndata = np.array([[1.5, -0.1, 3],\n                [0, -3, 6.5]])\nprint(data)\n\n[[ 1.5 -0.1  3. ]\n [ 0.  -3.   6.5]]\n\n\n数组data是二维数组，可以查看属性ndim和shape：\n\ndata.ndim\ndata.shape\n\n(2, 3)\n\n\n可以对data进行通常的数学运算：\n\nprint(data * 10)\nprint(data + data)\n\n[[ 15.  -1.  30.]\n [  0. -30.  65.]]\n[[ 3.  -0.2  6. ]\n [ 0.  -6.  13. ]]\n\n\nNumpy也有函数来生成一些特定格式的数组,如表 Table 1 所示：\n\n\n\nTable 1: Numpy中生成数组的函数\n\n\n\n\n\n\n\n\n\n函数名\n描述\n\n\n\n\narray\n将输入数据（列表、元组、数组或其他序列类型）转换为 ndarray，可以自动推断或显式指定数据类型；默认会复制输入数据\n\n\nasarray\n将输入转换为 ndarray，如果输入已经是 ndarray，则不会进行复制\n\n\narange\n类似于内置的 range，但返回的是 ndarray 而不是列表\n\n\nones, ones_like\n生成给定形状和数据类型的全 1 数组；ones_like 以另一个数组为模板，生成相同形状和数据类型的全 1 数组\n\n\nzeros, zeros_like\n类似于 ones 和 ones_like，但生成的是全 0 数组\n\n\nempty, empty_like\n通过分配新内存创建新数组，但不会像 ones 和 zeros 那样填充值\n\n\nfull, full_like\n生成给定形状和数据类型的数组，所有值都设置为指定的“填充值”；full_like 以另一个数组为模板，生成相同形状和数据类型的填充值数组\n\n\neye,identity\n生成单位矩阵（对角线为 1，其余为 0）\n\n\n\n\n\n\n\nzeros = np.zeros(10)\nprint(zeros)\nones = np.ones((2,3), dtype=float)\nprint(ones)\n# 单位矩阵\nidents = np.identity(3)\nprint(idents)\n\nevens = np.arange(0, 20, 2)\nprint(evens)\ngrids = np.linspace(0, 1, 21)\nprint(grids)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[[1. 1. 1.]\n [1. 1. 1.]]\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[ 0  2  4  6  8 10 12 14 16 18]\n[0.   0.05 0.1  0.15 0.2  0.25 0.3  0.35 0.4  0.45 0.5  0.55 0.6  0.65\n 0.7  0.75 0.8  0.85 0.9  0.95 1.  ]\n\n\nNumpy中random子库包含丰富的生成随机数的函数，例如：\n\n#生成正态分布\nnums_norm = np.random.normal(loc=0, scale=1, size=(4, 3))\nprint(nums_norm)\nnums_int = np.random.randint(low=1, high=11, size=(2, 10))\nprint(nums_int)\n\n[[-1.37539399  1.26851301 -0.58911433]\n [ 0.71198134 -0.21477278 -0.66124069]\n [-0.67356475  1.05377389  0.43696482]\n [-1.42191885 -0.81106133  0.05037252]]\n[[ 3 10  8  4  6  7  5  8  4  8]\n [ 9  8  9  2 10 10  7  9  8  7]]\n\n\n\n\n\n注意索引与列表一样，从0开始；选择元素时不包括右侧。\n\nz = np.array((1,2,3,4,5))\nz[0]\nz[0:2]\nz[-1]\nz[::2]\nz[::-1]\n# 2D arrays\nz = np.array([[1,2],\n              [3, 4]])\nz[0,0]\nz[0,:]\nz[:,1]\n\narray([2, 4])\n\n\n\n\n\n数组方法众多，例如：\n代码段\n\na = np.array((4,3,2,1))\na.sort()\n\na.sum()\na.mean()\na.max()\na.min()\na.var()\na.std()\na.argmax()\na.cumsum()\na.cumprod()\n\narray([ 1,  2,  6, 24])\n\n\n\n\n\n注意，运算符 +, - , *, / 和 **，都是逐元素运算。例如：\n\na = np.array([1,2,3,4])\nb = np.array([5,6,7,8])\na + b\na * b\na + 10\na * 10\n# 2D array\nA = np.ones((2,2))\nB = np.ones((2,2))\nA + B\nA+10\nA * B\n(A+1) ** 2\n\narray([[4., 4.],\n       [4., 4.]])\n\n\n可以使用 @ 或 np.dot() 进行矩阵乘法。如果是向量则计算内积。\n\nA = np.array([[1,2],\n              [3,4]])\nB = np.array([[5,6,],\n              [7,8]])\nA@B\n#or\nnp.dot(A,B)\n#\nb = np.array([0, 1])\nA@b\n\narray([2, 4])\n\n\n\n\n\nNumpy中有一些列简便运算的函数。例如 np.poly1d()，多项式求和:\n\\[p(x) = a_{0} + a_{1}x + a_{2}x^{2} + \\cdots + a_{N}x^{N} = \\sum_{n=0}^{N}a_{n}x^{n} \\]\n\np = np.poly1d([1,2,3])\nprint(p)\nprint(p(2))\n\n   2\n1 x + 2 x + 3\n11\n\n\n注意，np.poly1d() 函数高阶项在前面。\n利用向量计算，自定义一个函数：\n\ndef poly1d(x, coef):\n    X = np.ones_like(coef)\n    X[1:] = x\n    y = np.cumprod(X) # y = [1,x,x**2,...]\n    return coef @ y[::-1]\n\ncoef = [1, 2, 3]\npoly1d(2, coef=coef)\n\nnp.int64(11)\n\n\n\n\n\nNumpy中有大量的与随机数生成器有关的函数。\n下面是一个例子，注意，没有设定随机种子数，因此每次运行结果会不同。\n\nimport numpy as np\n\n# Define an array of choices\nchoices = np.array(['apple', 'banana', 'orange', 'grape', 'kiwi'])\n\n# Perform random choice\nrandom_choice = np.random.choice(choices)\n\n# Print the random choice\nprint(random_choice)\n\napple\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 设置随机种子以便复现\nnp.random.seed(0)\n\n# 步数\nn_steps = 1000\n\n# 生成每一步的随机步长（-1 或 1）\nsteps = np.random.choice([-1, 1], size=n_steps)\n\n# 计算随机游走序列\nwalk = np.cumsum(steps)\n\n# 绘制线形图\nplt.plot(walk)\nplt.title('Random Walk')\nplt.xlabel('Step')\nplt.ylabel('Position')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n中心极限定理 (Central Limit Theorem, CLT) 是概率论中一个非常强大的定理。它指出，当从任何形状的总体中抽取足够大的独立同分布 (i.i.d.) 样本时，这些样本均值的分布将近似于正态分布，无论原始总体分布如何。样本量越大，近似程度越好。\n我们将通过以下步骤来模拟验证 CLT：\n\n选择一个非正态分布的总体: 比如，一个指数分布或均匀分布，它们的形状都不是钟形的。\n设置样本参数: 定义每次抽样的样本大小 (sample_size) 和重复抽样的次数 (num_samples)。\n重复抽样并计算均值: 从总体中抽取 num_samples 次样本，每次抽取 sample_size 个数据点，并计算每次抽样的平均值。\n可视化: 绘制样本均值的直方图，并与原始总体分布的直方图进行对比。\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams['font.family'] = 'SimHei'\nplt.rcParams['axes.unicode_minus'] = False\n\n# --- 1. 设置模拟参数 ---\npopulation_size = 1000000  # 原始总体的大小\nsample_size = 30           # 每次抽样的样本量 (通常大于30就被认为是“大样本”)\nnum_samples = 10000        # 重复抽样的次数，即我们将有多少个样本均值\nnp.random.seed(123)\n\n# --- 2. 选择一个非正态分布的总体 (例如：指数分布) ---\n# 指数分布 (Exponential Distribution) 是一种偏态分布，非常适合验证CLT\n# numpy.random.exponential(scale=1.0, size=None)\n# scale 参数是均值，这里我们设置均值为2.0\npopulation_data = np.random.exponential(scale=2.0, size=population_size)\n# 也可以用均匀分布作为总体进行验证\n# population_data_uniform = np.random.uniform(low=0.0, high=10.0, size=population_size)\n\n# --- 3. 重复抽样并计算均值 ---\nsample_means = []\nfor _ in np.arange(num_samples):\n    # 从总体中随机抽取 sample_size 个数据点\n    sample = np.random.choice(population_data, size=sample_size, replace=True)\n    # 计算样本的均值并添加到列表中\n    sample_means.append(np.mean(sample))\n\n# 将样本均值列表转换为 NumPy 数组，方便后续处理和绘图\nsample_means = np.array(sample_means)\n\n# --- 4. 可视化结果 ---\nplt.figure(figsize=(12, 12))\n\n# 绘制原始总体分布的直方图\nplt.subplot(2, 1, 1) # 1行2列的第一个图\nplt.hist(population_data, bins=50, density=True, color='skyblue', edgecolor='black', alpha=0.7)\nplt.title(f'原始总体分布 (指数分布)\\n均值: {np.mean(population_data):.2f}, 标准差: {np.std(population_data):.2f}')\nplt.xlabel('值')\nplt.ylabel('频率密度')\nplt.grid(True, linestyle='--', alpha=0.6)\n\n# 绘制样本均值分布的直方图\nplt.subplot(2, 1, 2) # 1行2列的第二个图\nplt.hist(sample_means, bins=50, density=True, color='lightcoral', edgecolor='black', alpha=0.7)\nplt.title(f'样本均值的分布 ({sample_size}个样本量，重复{num_samples}次)\\n均值: {np.mean(sample_means):.2f}, 标准差: {np.std(sample_means):.2f}')\nplt.xlabel('样本均值')\nplt.ylabel('频率密度')\nplt.grid(True, linestyle='--', alpha=0.6)\n\nplt.tight_layout() # 调整子图布局，避免重叠\nplt.show()\n\n# --- 5. 额外验证：比较均值和标准差 ---\nprint(\"\\n--- 模拟结果验证 ---\")\nprint(f\"原始总体的均值 (μ): {np.mean(population_data):.4f}\")\nprint(f\"原始总体的标准差 (σ): {np.std(population_data):.4f}\")\nprint(f\"样本均值的均值 (μ_x̄): {np.mean(sample_means):.4f}\")\n# 根据中心极限定理，样本均值的标准差 (标准误差) 应该约等于 总体标准差 / sqrt(样本量)\nexpected_std_of_means = np.std(population_data) / np.sqrt(sample_size)\nprint(f\"样本均值的标准差 (σ_x̄): {np.std(sample_means):.4f}\")\nprint(f\"理论上样本均值的标准差 (σ / sqrt(n)): {expected_std_of_means:.4f}\")\n\n\n\n\n\n\n\n\n\n--- 模拟结果验证 ---\n原始总体的均值 (μ): 1.9988\n原始总体的标准差 (σ): 1.9992\n样本均值的均值 (μ_x̄): 1.9984\n样本均值的标准差 (σ_x̄): 0.3653\n理论上样本均值的标准差 (σ / sqrt(n)): 0.3650\n\n\n\n\n\n\nNumpy中许多函数是通用函数(universal functions)，是一种在 ndarray 数据中进行逐元素操作的函数，大多数数学函数属于此类。\n例如 np.cos() 函数：\n\nnp.cos(1.0)\nnp.cos(np.linspace(0, 1, 3))\n\narray([1.        , 0.87758256, 0.54030231])\n\n\n例如，我们想计算\\(\\frac{0}{1},\\frac{1}{2},\\cdots, \\frac{4}{5}\\):\n\nnp.arange(5) / np.arange(1, 6)\n\narray([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])\n\n\n\n\n\nTable 2: Numpy中算术运算子和函数\n\n\n\n\n\n\n\n\n\n\n\n运算符\n对应的 ufunc\n描述\n示例\n\n\n\n\n+\nnp.add\n加法\n1 + 1 = 2\n\n\n-\nnp.subtract\n减法\n3 - 2 = 1\n\n\n-\nnp.negative\n一元取反\n-2\n\n\n*\nnp.multiply\n乘法\n2 * 3 = 6\n\n\n/\nnp.divide\n除法\n3 / 2 = 1.5\n\n\n//\nnp.floor_divide\n向下取整除法\n3 // 2 = 1\n\n\n**\nnp.power\n幂运算\n2 ** 3 = 8\n\n\n%\nnp.mod\n取模/余数\n9 % 4 = 1\n\n\n\n\n\n\n\n\n\n考察最大化函数 \\(f(x,y)\\) 在区间 $ [−a,a] $ 上的最大值： \\[\nf(x,y)= \\frac{cos(x^{2} + y^{2})}{1 + x^2 + y^2}\n\\] ​ 令\\(a=3\\)。 我们定义一个函数，然后生成数组，计算对应的-值，通过栅格（grid）搜索最大值（等于1）。\n\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nimport matplotlib.pyplot as plt\n\ndef f(x, y):\n    return np.cos(x**2 + y**2) / (1 + x**2 + y**2)\n\ngrid = np.linspace(-3, 3, 50)\nx, y = np.meshgrid(grid, grid)\nz = f(x, y)\n\n# 最大值\nmax_value = np.max(z)\nprint(\"函数的最大值:\", max_value)\n\n# 绘制3D图像\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x, y, z, cmap='viridis')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x, y)')\nplt.show()\n\n函数的最大值: 0.9925310162998334\n\n\n\n\n\n\n\n\n\n图示\n\n\n\n\nimport numpy as np # 载入numpy库\ndef lorenz_curve(y):\n    n = len(y)\n    y = np.sort(y) # 从小到大排序\n    s = np.zeros(n + 1) # 生成n+1 个数值零\n    s[1:] = np.cumsum(y) # 从第2个数（索引1）累计求和，使第一个数据点为（0，0）\n    cum_people = np.linspace(0, 1, n + 1)\n    cum_income = s / s[n] # s[n]为最后的值，即所有值的和\n    return cum_people, cum_income\n\n\nn = 2000\nnp.random.seed(1)\nsample = np.exp(np.random.randn(n))\nf_vals, l_vals = lorenz_curve(sample)\n#\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(f_vals, l_vals, label=f'lognormal sample', lw = 2)\nax.plot([0, 1], [0, 1], label='equality', lw = 2)\nax.fill_between(f_vals,l_vals, f_vals, alpha=0.06)\nax.fill_between(f_vals, l_vals, np.zeros_like(f_vals),alpha=0.06)\nax.vlines([0.8], [0], [0.43], linestyles='--', colors='gray')\nax.hlines([0.43], [0], [0.8], linestyles='--', colors='gray')\nax.set_xlim((0,1))\nax.set_ylim((0,1))\nax.text(0.55, 0.4,\"A\", fontsize=16)\nax.text(0.75,0.15,\"B\",fontsize=16)\nax.set_xlabel('Cumulative share of people')\nax.set_ylabel('Cumulative share of income')\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\ndef gini(y):\n    n = len(y)\n    y_1 = np.reshape(y, (n, 1))\n    y_2 = np.reshape(y, (1, n))\n    g_sum = np.sum(np.abs(y_1 - y_2)) # 利用了numpy的广播（broadcasting）\n    return g_sum / (2 * n * np.sum(y))\n\n\n# 模拟对数正态数据\nnp.random.seed(1)\nk = 5\nsigmas = np.linspace(0.2, 4, k)\nn = 2000\nginis = []\nfor sigma in sigmas:\n    mu = -sigma ** 2 / 2\n    y = np.exp(mu + sigma * np.random.randn(n))\n    ginis.append(gini(y))\n\n\nfig, ax = plt.subplots(figsize=(10, 8))\nax.plot(sigmas, ginis, marker = 'o',label='simulated', lw = 2)\nax.set_xlabel('Standard deviation')\nax.set_ylabel('Gini coefficient')\nax.legend()\nplt.show()"
  },
  {
    "objectID": "numpy.html#scipy-基础",
    "href": "numpy.html#scipy-基础",
    "title": "Numpy 和 Scipy",
    "section": "2 Scipy 基础",
    "text": "2 Scipy 基础"
  },
  {
    "objectID": "logistic.html",
    "href": "logistic.html",
    "title": "Logistic 回归",
    "section": "",
    "text": "在统计学中是一种对数几率模型，是离散选择法模型之一，属于多元变量分析范畴，是社会学、生物统计学、临床、数量心理学、计量经济学、市场营销等统计实证分析的常用方法。"
  },
  {
    "objectID": "logistic.html#logistic-与-lpm",
    "href": "logistic.html#logistic-与-lpm",
    "title": "Logistic 回归",
    "section": "1 Logistic 与 LPM",
    "text": "1 Logistic 与 LPM"
  },
  {
    "objectID": "logistic.html#logistic回归方法",
    "href": "logistic.html#logistic回归方法",
    "title": "Logistic 回归",
    "section": "2 Logistic回归方法",
    "text": "2 Logistic回归方法\nLPM \\[\nY = \\beta_{0} + \\beta_{1}X\n\\]\n\n2.1 Logisitc sigmoid 函数\n\\[\n\\sigma(z) = \\frac{1}{1 + \\exp(-z)}\n\\]\n其形状：\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef sigmoid(x):\n    return 1/(1+np.exp(-x))\nx = np.linspace(-10, 10, 500)\ny = sigmoid(x)\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(x, y, label = 'Sigmoid Function')\nax.set_title(\"Sigmoid Function Plot\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"sigmoid(x)\")\nax.grid()\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2.2"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "引言",
    "section": "",
    "text": "《基于Python的经济分析与应用》旨在将经济学理论与现代数据分析技术相结合，内容涵盖Python编程基础、数据采集与处理、经济数据分析、可视化展示及实际案例应用。\n通过学习，使学生掌握应用Python进行经济数据分析的方法，提高数据处理与决策支持能力，为未来从事数据驱动的经济分析、科学研究或制定经济决策打下坚实基础。",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#内容是关于什么的",
    "href": "intro.html#内容是关于什么的",
    "title": "引言",
    "section": "1 内容是关于什么的？",
    "text": "1 内容是关于什么的？\n\n1.1 经济数据分析\n对经济数据进行分析长期以来都是政策制定、投资者、企业和消费者关注的焦点：\n\n宏观经济形式分析。如毕马威的中国经济观察季度报告等、中国宏观经济论坛发布的CMF中国宏观经济专题报告等。\n美国经济分析局（Bureau of Economic Analysis，BEA）：负责公布美国宏观经济以及行业的统计数据，以及有关美国国内生产总值（GDP）和各个市/镇/乡/村/县和大都市区的数据；\n数据科学在人工智能时代的广泛应用；\n数据服务商的重要作用。如彭博社、Wind资讯等。\n\n\n\n1.2 数据分析方法\n将数据分析方法应用至经济学、金融学和国际贸易等学科的有关主题。主要包括：\n\n经济数据分析：如增长、不平等等、通货膨胀等宏观数据；\n统计分析方法：t检验、方差分析等；\n线性回归方法\n蒙特卡洛模拟分析\n机器学习基础方法\n投入产出模型；\n网络分析方法；\n\n\n\n1.3 主要参考书\n会用到部分Python有关的内容，如：\n\nMcKinney (2022)， 在线阅读\nVanderPlas (2016)， 在线阅读\nPython Programming for Economics and Finance",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#分析工具python",
    "href": "intro.html#分析工具python",
    "title": "引言",
    "section": "2 分析工具：Python",
    "text": "2 分析工具：Python\n我们使用Python作为主要的分析工具。根据TIOBE Index for August 2025，Python是目前最流行的编程语言。\n\n\n\n\n\n\nFigure 1: TIOBE Programming Community Index\n\n\n\n\n2.1 功能强大，应用广泛\nPython广泛应用于机器学习、科学计算等各个领域：\n\n机器学习\n数据科学\n通讯\n网页开发\nCGI and GUI\n自然语言处理\n游戏开发\n等等\n\n\n\n2.2 Python的特点\nPython具有许多优点：\n\n易读、易写和易调试；\n核心内容易学；\n众多库的支持；\n初学者友好\n支持多平台\n网络资源众多",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#安装和设置软件环境",
    "href": "intro.html#安装和设置软件环境",
    "title": "引言",
    "section": "3 安装和设置软件环境",
    "text": "3 安装和设置软件环境\n\n3.1 下载安装Python\n\n自官方网站下载Python，当前版本3.13.x。\n双击打开下载的安装程序，如果是Windows操作系统，在点击“Install Now”安装程序之前，注意勾选：Add Python to PATH，将Python的安装路径添加到操作系统的环境变量Path中，如图 Figure 2 所示：\n\n\n\n\n\n\n\nFigure 2: 将Python添加至环境\n\n\n\n\n在“命令提示符”输入python --version查看安装版本，如图 Figure 3 所示。\n\n\n\n\n\n\n\nFigure 3: Python 版本\n\n\n\n\n\n3.2 安装Jupyer Lab\n\n安装JupyterLab。通过命令提示符（或Mac OS的终端）安装：pip install jupyterlab。应用过程中经常需要使用pip安装程序，建议将镜像源配置为清华大学开源软件镜像站。\n在命令提示符输入:jupyter lab，就可以在浏览器启动Jupyter Lab，新建一个Notebook就可以使用了，如 Figure 4 所示 。选中单元格（cell），设置为“code”格式（其他两种是markdown和raw），输入：\n\n\nprint(\"Hello World!\")\n\nHello World!\n\n\n\n\n\n\n\n\nFigure 4: Jupyter Lab\n\n\n\n\n\n3.3 安装Visual Studio Code\nVisual Studio Code是由微软推出的免费、开源、跨平台的代码编辑器，支持几十种主流编程语言（如JavaScript、Python、C++、Java、Go 等），并且与微软推出的Copilot人工智能工具高度融合，拥有强大的功能和灵活的扩展性。\n\n下载安装Visual Studio Code。 要将软件设置为中文，可以使用快捷键Ctrl + Shift + P打开命令面板，输入Configure Display Languate，在出现的列表中，选择“中文（简体）”，根据提示重启VS Code，界面语言就会变为中文。\n在扩展（Extensions Marketplace）搜索安装插件：\n\nPython\nJupyter,\nExcel Viewer\nRainbow CSV\n\n\n应用时，Visual Studio Code 可以“打开文件”或者 “打开文件夹”将项目所在文件夹处打开。建议以打开文件夹方式，可以比较清楚的概览代码、数据、图形等子文件夹。\n\n\n3.4 安装第三方程序包和创建虚拟环境\n要安装第三方程序包，基本的方式是通过pip命令：\npython -m pip install SomePackage\n例如，在命令提示符，或者在Visual Studio Code使用快捷键Ctrl + Shift + \\ `新建终端，输入命令使用pip安装。：\n\nNumpy: python -m pip install numpy\nPandas: python -m pip install pandas\nMatplotlib: python -m pip install matplotlib\n\n建议为单独的项目设置一个Python虚拟环境：\n\n创建虚拟环境：在VSC中新建终端，运行：python -m venv &lt;env_name&gt;，其中&lt;env_name&gt;是你想给虚拟环境其的名称；\n激活虚拟环境：Windows系统下使用：&lt;env_name&gt;Scripts/activate，macOS下使用：source &lt;env_name&gt;/bin/activate\n停用虚拟环境： deactivate；\n\n更快捷的方式是通过下载记录有程序包名字的requirements.txt文件进行安装：\npip install -r requirements.txt\n可以将需要的第三方程序一次安装。",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#脚本模式和交互模式",
    "href": "intro.html#脚本模式和交互模式",
    "title": "引言",
    "section": "4 脚本模式和交互模式",
    "text": "4 脚本模式和交互模式\nPython可以交互式或脚本模式运行。\n\n4.1 交互式\n用户输入代码，回车运行。在如IDLE，Ipython都可以方便地进行交互式操作。例如：\n\n在命令提示符（或VSC终端）输入ipython，将打开Ipython的界面，输入3 + 3，回车，将在屏幕上立刻显示计算结果；\n在应用程序中打开 IDLE Shell，也可以方便的进行交互式操作；\n在Jupyter Notebook的代码单元格内，输入代码，点击运行显示结果；\n\n\n\n4.2 脚本模式\n脚本模式是将代码保存在.py格式的文件中，然后使用命令提示符调用脚本。\n例如，在文件夹pyfiles中保存有一个文件lunch.py，定义了一个随机选择午餐的函数lunch()，当运行该函数时，随机从列表中选择一个作为推荐的午餐。\n\nimport random\n\ndef lunch():\n    \"\"\"Randomly choose a lunch option and return the result.\"\"\"\n    lunch_list = [\"Rice Bowl\", \"Ramen\", \"Salad\", \"Burger\", \"Dumplings\", \"Pizza\"]\n    return random.choice(lunch_list)\n\nif __name__ == \"__main__\":\n    result = lunch()\n    print(\"Recomm:\",result)\n\nRecomm: Salad\n\n\n在命令提示符或终端中运行：\npython pyfiles/lunch.py\n当然，也可以先改变当前文件夹至pyfiles文件夹，就可以省略路径。\n\n\n4.3 在Visual Studio Code 中 应用 Jupyter notebook\n打开VSC，点击“文件- 新建文件”，从弹出的菜单选择“Jupyter Notebook”。\n\n\n\n\n\n\nFigure 5: 新建Jupyter Notebook\n\n\n\n下面的例子来自Matplotlib官方网站，将代码复制到Notebook的一个单元格中，点击左侧的运行三角箭头（VSC也许会让你选择一个核），绘制 Figure 6 所示的一个累计概率分布图：\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu = 200\nsigma = 25\nn_bins = 25\ndata = np.random.normal(mu, sigma, size=100)\n\nfig = plt.figure(figsize=(9, 4), layout=\"constrained\")\naxs = fig.subplots(1, 2, sharex=True, sharey=True)\n\n# Cumulative distributions.\naxs[0].ecdf(data, label=\"CDF\")\nn, bins, patches = axs[0].hist(data, n_bins, density=True, histtype=\"step\",\n                               cumulative=True, label=\"Cumulative histogram\")\nx = np.linspace(data.min(), data.max())\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (x - mu))**2))\ny = y.cumsum()\ny /= y[-1]\naxs[0].plot(x, y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Complementary cumulative distributions.\naxs[1].ecdf(data, complementary=True, label=\"CCDF\")\naxs[1].hist(data, bins=bins, density=True, histtype=\"step\", cumulative=-1,\n            label=\"Reversed cumulative histogram\")\naxs[1].plot(x, 1 - y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Label the figure.\nfig.suptitle(\"Cumulative distributions\")\nfor ax in axs:\n    ax.grid(True)\n    ax.legend()\n    ax.set_xlabel(\"Annual rainfall (mm)\")\n    ax.set_ylabel(\"Probability of occurrence\")\n    ax.label_outer()\n\nplt.show()\n\n\n\n\n\n\n\nFigure 6: 累计概率分布\n\n\n\n\n\nJupyter Notebook 延续了ipython中的%run命令，可以脚本模式运行：\n\n%run pyfiles/lunch.py\n\n推荐的午餐: 沙拉",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "intro.html#文档与帮助",
    "href": "intro.html#文档与帮助",
    "title": "引言",
    "section": "5 文档与帮助",
    "text": "5 文档与帮助\n\n5.1 help() 和?\nPython有非常详细的官方帮助文档，帮助新用户快速的熟悉其用法。\n例如，Python有一个内置函数help()，可以查看定义的文档，例如对函数len()：\n\nhelp(len)\n\nHelp on built-in function len in module builtins:\n\nlen(obj, /)\n    Return the number of items in a container.\n\n\n\n由于其重要性，Ipython和Jupyter中可以使用?作为缩写：\n\nlen?\n\n当然，对自定义的对象也是适用的。下面定义的函数，有一段函数的说明文字（docstring）：\n\ndef square(x):\n    \"\"\"\n    Calculates the square of a given number.\n\n    Args:\n        x (int or float): The number to be squared.\n\n    Returns:\n        int or float: The square of the input number.\n    \"\"\"\n    return x**2\n\n如果输入help()函数：\n\nhelp(square)\n\nHelp on function square in module __main__:\n\nsquare(x)\n    Calculates the square of a given number.\n\n    Args:\n        x (int or float): The number to be squared.\n\n    Returns:\n        int or float: The square of the input number.",
    "crumbs": [
      "Python基础",
      "引言"
    ]
  },
  {
    "objectID": "eco/Lib/site-packages/soupsieve-2.7.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/soupsieve-2.7.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pyzmq-27.0.0.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/pyzmq-27.0.0.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/period/test_indexing.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/period/test_indexing.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/datetimes/test_indexing.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/datetimes/test_indexing.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/missingno-0.5.2.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/missingno-0.5.2.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright (c) 2016 Aleksey Bilogur\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/cffi/recompiler.html",
    "href": "eco/Lib/site-packages/cffi/recompiler.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "eco/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/idna-3.10.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/idna-3.10.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/numpy/random/LICENSE.html",
    "href": "eco/Lib/site-packages/numpy/random/LICENSE.html",
    "title": "1 NCSA Open Source License",
    "section": "",
    "text": "This software is dual-licensed under the The University of Illinois/NCSA Open Source License (NCSA) and The 3-Clause BSD License\n\n1 NCSA Open Source License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nDeveloped by: Kevin Sheppard (kevin.sheppard@economics.ox.ac.uk, kevin.k.sheppard@gmail.com) http://www.kevinsheppard.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\nNeither the names of Kevin Sheppard, nor the names of any contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.\n\n\n2 3-Clause BSD License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n3 Components\nMany parts of this module have been derived from original sources, often the algorithm’s designer. Component licenses are located with the component code.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas/tests/indexes/period/test_constructors.html",
    "href": "eco/Lib/site-packages/pandas/tests/indexes/period/test_constructors.html",
    "title": "",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/pandas_datareader-0.10.0.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/pandas_datareader-0.10.0.dist-info/LICENSE.html",
    "title": "1 pandas license",
    "section": "",
    "text": "======= License =======\npandas is distributed under a 3-clause (“Simplified” or “New”) BSD license. Parts of NumPy, SciPy, numpydoc, bottleneck, which all have BSD-compatible licenses, are included. Their licenses follow the pandas license.\n\n1 pandas license\nCopyright (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team All rights reserved.\nCopyright (c) 2008-2011 AQR Capital Management, LLC All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials provided\n   with the distribution.\n\n* Neither the name of the copyright holder nor the names of any\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n2 About the Copyright Holders\nAQR Capital Management began pandas development in 2008. Development was led by Wes McKinney. AQR released the source under this license in 2009. Wes is now an employee of Lambda Foundry, and remains the pandas project lead.\nThe PyData Development Team is the collection of developers of the PyData project. This includes all of the PyData sub-projects, including pandas. The core team that coordinates development on GitHub can be found here: http://github.com/pydata.\nFull credits for pandas contributors can be found in the documentation.\n\n\n3 Our Copyright Policy\nPyData uses a shared copyright model. Each contributor maintains copyright over their contributions to PyData. However, it is important to note that these contributions are typically only changes to the repositories. Thus, the PyData source code, in its entirety, is not the copyright of any single person or institution. Instead, it is the collective copyright of the entire PyData Development Team. If individual contributors want to maintain a record of what changes/contributions they have specific copyright on, they should indicate their copyright in the commit message of the change when they commit the change to one of the PyData repositories.\nWith this in mind, the following banner should be used in any source code file to indicate the copyright and license terms:\n#—————————————————————————– # Copyright (c) 2012, PyData Development Team # All rights reserved. # # Distributed under the terms of the BSD Simplified License. # # The full license is in the LICENSE file, distributed with this software. #—————————————————————————–\nOther licenses can be found in the LICENSES directory.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "eco/Lib/site-packages/seaborn-0.13.2.dist-info/LICENSE.html",
    "href": "eco/Lib/site-packages/seaborn-0.13.2.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright (c) 2012-2023, Michael L. Waskom All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "前言",
    "section": "",
    "text": "前言\n本书是为南京师范大学商学院国际商务、数字经济专业硕士准备的课程讲义。目的是掌握基本的数据分析方法，为从事科学研究、论文写作奠定基础。\n本书特色：\n\n将Python与经济分析紧密结合；\n应用实际数据集。，无论是宏观还是微观数据，都是实际学术研究中常使用的数据集，如Penn World Table、CFPS数据集、CHNS等。另外，还大量使用了数据接口，如世界银行数据库的WBGAPI、AKshare等API接口下载数据。\n适合高年级本科生和研究生使用。分析方法是学术期刊经常出现，如熵权法、泰尔指数分解、出口产品复杂度等。\n\n本书内容来自教学实践，囿于作者水平，难免出现疏漏错误，欢迎批评指正。\n\n\n\n\n Back to top",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "matplotlib.html",
    "href": "matplotlib.html",
    "title": "数据可视化",
    "section": "",
    "text": "官方使用教程是非常重要的学习来源。"
  },
  {
    "objectID": "matplotlib.html#图形的构成",
    "href": "matplotlib.html#图形的构成",
    "title": "数据可视化",
    "section": "1 图形的构成",
    "text": "1 图形的构成\n图形的构成可以参考Matplotlib官方网站上Anatomy of a figure的说明：\n\n\n\n图形解剖图\n\n\n我们用一个例子来说明绘图的过程。下面的全球电影票房数据来自维基百科全球最高電影票房收入列表\n\nimport pandas as pd\nimport re\ndata = pd.read_excel(\"datasets/highest_gross_films.xlsx\")\ndata['全球票房'] = data['全球票房'].apply(lambda ser: pd.to_numeric(re.sub(r'\\D','', ser)))\ndf = data[:10]\ndf\n\n\n\n\n\n\n\n\n排名\n峰值\n影片名称\n全球票房\n年份\n\n\n\n\n0\n1\n1\n阿凡达\n2923706026\n2009\n\n\n1\n2\n1\n复仇者联盟：终局之战\n2797501328\n2019\n\n\n2\n3\n3\n阿凡达：水之道\n2320250281\n2022\n\n\n3\n4\n1\n泰坦尼克号\n2257844554\n1997\n\n\n4\n5\n5\n哪吒2\n2217080000\n2025\n\n\n5\n6\n3\n星球大战：原力觉醒\n2068223624\n2015\n\n\n6\n7\n4\n复仇者联盟：无限战争\n2048359754\n2018\n\n\n7\n8\n6\n蜘蛛侠：英雄无归\n1922598800\n2021\n\n\n8\n9\n8\n头脑特工队2\n1698863816\n2024\n\n\n9\n10\n3\n侏罗纪世界\n1671537444\n2015"
  },
  {
    "objectID": "matplotlib.html#绘图一般步骤",
    "href": "matplotlib.html#绘图一般步骤",
    "title": "数据可视化",
    "section": "2 绘图一般步骤",
    "text": "2 绘图一般步骤\n图形的种类非常多，应用Python绘图时可以大致分为几个步骤。\n\n2.1 载入必要的库\n除了基本的绘图工具Matplotlib外，Seaborn库也经常使用，在应用之前均应载入。\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n另外，Matplotlib 默认情况下不支持中文字符。如果你直接在图表标题、坐标轴标签或图例中使用中文，很可能会看到方框乱码或者问号。\n\nplt.rcParams['font.sans-serif'] = ['SimHei', 'Heiti TC', 'WenQuanYi Zen Hei', 'Arial']\n\nplt.rcParams[\"axes.unicode_minus\"] = False\n\n现在有了图形轴（Axes）的实例，就可以在上面绘制图形了。例如绘制一幅柱形图，使用.bar()方法：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(x=df['影片名称'], height=df['全球票房'], color='skyblue')\nplt.show()\n\n\n\n\n\n\n\n\n显然，图形还有改善的空间。比如横轴的标签，即电影名字挤在一起看不清楚，也可以设置纵轴标签、图形标题等：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(x=df['影片名称'], height=df['全球票房'], color='skyblue')\nax.set_yscale(\"log\")\nax.set_title('电影全球总票房前十名', fontsize=16, fontweight='bold')\nax.set_xlabel('影片名称', fontsize=12)\nax.set_ylabel('全球票房 ($)', fontsize=12)\nplt.xticks(rotation=45, ha='right') \nplt.show()\n\n\n\n\n\n\n\n\n横向柱形图\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.barh(y = df['影片名称'], width=df['全球票房'], color='skyblue')\nax.set_xscale(\"log\")\nax.set_title('电影全球总票房前十名', fontsize=16, fontweight='bold')\nax.set_ylabel('影片名称', fontsize=12)\nax.set_xlabel('全球票房 ($)', fontsize=12)\n\nplt.show()"
  },
  {
    "objectID": "matplotlib.html#常用的图形",
    "href": "matplotlib.html#常用的图形",
    "title": "数据可视化",
    "section": "3 常用的图形",
    "text": "3 常用的图形\n\n3.1 直方图\n直方图可以被看作是估计概率密度函数（PDF）的一种基本而直观的方法，但严格来说，它估计的是概率质量函数（PMF），尤其是在处理离散数据时。当用于连续数据时，它更像是PDF的一个粗略估计。\n直方图将数据分成一系列不重叠的“箱子”（bins）。对于每个箱子，它统计落入该箱子中的数据点的数量，并以一个矩形柱的高度来表示这个数量，当然也可以用每个柱子的高度表示该箱子中数据点所占的比例或频率。\n下面的例子自雅虎财经网站下载几支股票的月度（后复权调整）收盘价数据，然后使用df.pct_change()函数计算了简单收益率。\n\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\n#import yfinance as yf\n# stocks_list = ['AAPL','BA','MGM','AMZN','IBM','TSLA','GOOG','^GSPC']\n# start_date = \"2012-01-01\"\n# end_date = \"2025-06-30\"\n# df = yf.download(tickers=stocks_list,\n#          start=start_date,\n#          end=end_date, \n#          interval=\"1mo\",\n#          auto_adjust=True,\n#          progress=False)['Close']\n\n# df.to_csv(\"datasets/stocks_price_us.csv\")\n\nstocks_price_us = pd.read_csv(\"datasets/stocks_price_us.csv\",\n                     header=0, index_col=0, parse_dates=True )\n\nreturns = stocks_price_us.pct_change()\n\n例如，绘制苹果公司股票收益率的直方图：\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.hist(x=returns['AAPL'], bins=20, \n        color=\"skyblue\", edgecolor=\"black\") \nax.vlines(x=returns['AAPL'].mean(), \n        ymin=0, ymax=18, colors=\"darkred\",        \n        alpha=0.6)\nax.set_xlabel(\"Monthly Return of AAPL\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n\n\n\n\n\n\n\n\n如果纵轴希望表示为概率密度，加上参数density=True。\n下载的数据包含8家7家企业以及标准普尔500指数（GSPC），下面将收益率为子图绘制直方图。为了可比，横轴使用了sharex=True参数：\n\nfig, axes = plt.subplots(nrows=2, \n                        ncols=4,\n                        figsize=(15, 10),\n                        sharex=True)\nstock_index = 0\nfor row in range(2):\n    for col in range(4):\n        stock = returns.columns[stock_index]        \n        axes[row, col].hist(returns[stock], color=\"skyblue\",\n                edgecolor='black', bins=20)\n        axes[row, col].set_title(f'{stock}', fontsize=14)\n        stock_index += 1\nfig.supxlabel(\"Monthly Returns\", fontsize=16)\nfig.supylabel(\"Frequency\", fontsize=16)\nfig.suptitle(\"Histograms of Monthly Returns\", fontsize=18)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3.2 核密度图\n对连续数据来讲，估计概率密度函数的更好的方法是核密度函数估计（Kernel Density Estimator，KDE）。\n设 \\((x_{1}, x_{2},\\cdots ,x_{n})\\) 为从单变量分布中抽取的独立同分布样本，给定点 \\(x\\) 有未知的概率密度 \\(f(x)\\)，我们需要估计观察到的值的概率密度函数 \\(\\hat{f}(x)\\) 。\n在KDE估计过程中处于核心地位的是核函数，我们逐步来看应用的过程。\n假设有一个观测值，例如 \\(x = 0\\)，我们要估计观测值服从的概率密度函数，最合理的估计是使用一个PDF在该点取峰值，向两侧衰减。例如函数 \\(= \\exp(-x^{2})\\) 满足这个条件。但是我们知道，PDF下面积应为1，因此进行适当转换以满足该条件，记为： \\[\nK(x) = \\frac{1}{\\sqrt{2\\pi}}\\exp(\\frac{-x^{2}}{2})\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef k(x):\n    return np.exp(-x**2)\ndef K(x):\n    return (1/np.sqrt(2*np.pi))*np.exp(-x**2/2)\n\nx = np.linspace(-3.5, 3.5, 1000)\ny1 = k(x)\ny2 = K(x)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(x, y1, linewidth = 2.5, label = r\"$\\exp(-x^{2})$\")\nax.plot(x, y2, linewidth = 2.5, label = r\"$\\frac{1}{\\sqrt{2\\pi}}\\exp(\\frac{-x^{2}}{2})$\")\nax.set_xlabel(r'$x$', fontsize=16)\nax.set_ylabel('') \nax.legend(fontsize=16)\nplt.tight_layout()\nplt.show() \n\n\n\n\n\n\n\n\n这样我们就得到了一个非常常用的核函数 \\(K(x)\\)，零均值和单位方差的高斯（Gaussian）分布。\n对观测值中的任意点 \\(x_{i}\\)，相当于沿着 \\(x\\) 轴平移曲线，用核函数表示为： \\[\nK(x - x_{i})\n\\]\n要让曲线更宽或更窄，可以加入一个常数 \\(h\\) 在分母上，称为带宽。这样将核函数曲线下面积乘了 \\(h\\) ，为保持单位面积需要除以 \\(h\\)，即：\n \\[\n\\frac{1}{h}K(\\frac{x - x_{i}}{h})\\tag{5.1}\n\\]\n带宽的选择影响估计的密度函数，带宽越宽，曲线越平缓；带宽越小，曲线越陡峭。\nKDE估计阐释性例子\n下面利用上面的函数 5.1，从最简单的情况开始，逐步阐释KDE是如何进行的。\n首先假设观测值只包含一个点，\\(x_{1} = 1.33\\)，我们选择一个带宽，比如 \\(h=0.3\\)，估计的PDF为： \\[\n\\frac{1}{h}K(\\frac{x - x_{1}}{h})\n\\]\n\nx1 = 1.5\nh = 0.3\n\nx_grid = np.linspace(-1, 2.5, num = 500)\nfig, ax = plt.subplots(figsize=(8, 6))\nf_grid = K((x_grid-x1)/h)/h\nax.plot(x_grid, f_grid, linestyle = \"--\")\nax.scatter(x1, 0, marker=\"s\",s=50)\nax.annotate(r\"$x_{1}$\", xy=[x1, 0.02], fontsize=16)\nplt.show()\n\n\n\n\n\n\n\n\n现在假设第二个观测值为 \\(x_{2} = 0.5\\)，可以同样的方式估计 \\[\n\\frac{1}{h}K(\\frac{x - x_{2}}{h})\n\\]\n要得到一个概率密度函数，需要将两者加起来，然后除以2：\n\\[\nf(x) = \\frac{1}{2h}\\left[K(\\frac{x-x_{1}}{h}) + K(\\frac{x-x_{2}}{h}) \\right] = \\frac{1}{2h}\\sum_{i=1}^{2}K(\\frac{x-x_{i}}{h})\n\\]\n在Scipy库中，有常见的统计分布的概率密度函数，可以利用其正态分布的概率密度函数norm().pdf()非常简便的进行计算:\n\n对每个数据点xi，创建一个均值为xi、标准差为h的正态分布对象；\n对每个对象，计算x_d网格上的PDF值；\n对所有PDF值进行求和；\n\n\n\nfrom scipy.stats import norm\nx = np.array([1.5, 0.5])\nh = 0.3\nx_grid = np.linspace(-1, 2.5, num = 500)\n\nn = len(x)\ndensity = sum(norm(loc=xi, scale=h).pdf(x_grid) for xi in x)/n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nfor xi in x:\n    ax.plot(x_grid, norm(xi,h).pdf(x_grid), color = 'black', linestyle = \"--\")            \nax.plot(x_grid, density, color='red', \n            linewidth = 2.5, label = \"KDE with gaussian kernel function\")\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n很容易将上述方法类推到 \\(n\\) 个观测值 \\((x_{1}, x_{2},\\cdots ,x_{n})\\) 的情况：\n \\[\nf(x) = \\frac{1}{nh}\\sum_{i=1}^{n}K(\\frac{x-x_{i}}{h}) \\tag{5.2}\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\ndef plot_kde_scipy(data, h, n_points=500):\n    data_min = np.min(data)\n    data_max = np.max(data)\n    x_min = data_min - 3 * h\n    x_max = data_max + 3 * h\n    n = len(data)\n    x_grid = np.linspace(x_min, x_max, num=n_points)   \n    density = sum(norm(loc=xi, scale=h).pdf(x_grid) for xi in data)/n          \n    plt.figure(figsize=(8, 6))    \n    plt.fill_between(x_grid, density, alpha=0.3, color='skyblue')   \n    plt.plot(x_grid, density, color='cornflowerblue', linewidth=2)   \n    \n    plt.title(f'KDE Estimate using SciPy (Bandwidth h = {h})', fontsize=18)\n    plt.xlabel('x', fontsize=14)\n    plt.ylabel('Density', fontsize=14)\n    plt.ylim(bottom=-0.02)\n    plt.grid(True, linestyle='--', alpha=0.6)\n    plt.show()\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nbandwidth1 = 0.3\nplot_kde_scipy(data, h=bandwidth1)\n\n\n\n\n\n\n\n\nSeaborn中的kdeplot方法\nSeaborn库中有kdeplot函数，可以方便用来估计。带宽选择参数bw_method:\n\nScott方法(Scott (2015)): \\[\nh\\approx 1.06\\cdot\\hat{\\sigma}n^{-1/5}\n\\]\nSilvermans 方法(Silverman (2018))： \\[\nh = 0.9\\cdot \\min(\\hat{\\sigma}, IQR/1.35)n^{-1/5}\n\\]\n\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nimport seaborn as sns\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.kdeplot(data, bw_method=\"scott\",\n            alpha = 0.3,\n            linewidth = 2.5,\n            ax=ax)\n\nax.set_xlabel(\"value\", fontsize=14)\nax.set_ylabel(\"density\", fontsize=14)\nsns.despine(left=False, bottom=True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n可以取不同带宽看其影响。注意这里bw_adjust是作为一个系数乘以scott方法得到的带宽值，详见说明文档：\n\nbw_adjust_values = [0.2, 0.8, 1.4, 2.0]\nfig, ax = plt.subplots(figsize=(12, 8))\nfor bw in bw_adjust_values:\n    sns.kdeplot(data, bw_adjust=bw, label=f'bw_adjust = {bw}', linewidth=2.5)\nax.plot(data, np.zeros_like(data), '|k', markeredgewidth=1, label='Data Points')\n\nax.set_title('KDE Plots with Different Bandwidth Adjustments', fontsize=18)\nax.set_xlabel('x', fontsize=14)\nax.set_ylabel('Density', fontsize=14)\nax.legend(title='Bandwidth', fontsize=12)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n我们可以定义一个函数计算soctt方法的带宽值，然后用自定义的函数来绘制KDE图：\n\ndef scott_method(x):\n    h = 1.06*x.std()*len(x)**(-0.2)\n    return h\n\ndata = np.array([1.5, 0.5,-0.1, 0.9, 0.23])\nscott_value = scott_method(data)\nplot_kde_scipy(data, h=scott_value)\n\n\n\n\n\n\n\n\n除了正态核函数以外，还有其他核函数，但总体来讲核函数的影响没有带宽影响的差异大，Seaborn的kdeplot方法甚至取消了原本可以选择的设定。Scikit-Learn Kernel Density 算法提供了6种不同的核函数。另外，Pandas库的s.plot.kde()方法也可以绘制核密度图。\n\n\n3.3 热图\n热图是一种数据可视化技术，用颜色深浅来表示数据集中不同数值的大小或密集程度。\n\ncorr = returns.corr().round(2)\n\nfig, ax = plt.subplots(figsize=(10, 8))\nsns.heatmap(corr, annot=True,\n            ax=ax,\n            cmap='coolwarm')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3.4 箱形图\n\n\n3.5 散点图"
  },
  {
    "objectID": "matplotlib.html#多图和子图",
    "href": "matplotlib.html#多图和子图",
    "title": "数据可视化",
    "section": "4 多图和子图",
    "text": "4 多图和子图\n当有多幅图形绘制时，可以放在一张图形上或用子图排列。 ### 多图\n\n# 正态分布\nimport numpy as np\nfrom scipy.stats import norm\nnp.random.seed(12345)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nx = np.linspace(-4, 4, 500)\nfor i in range(3):\n    mu, std = np.random.uniform(-1,1), np.random.uniform(1, 3)\n    y = norm.pdf(x, loc = mu, scale = std)\n    current_label = rf\"$\\mu = {mu:.2f}$\"\n    ax.plot(x, y, linewidth = 2, alpha = 0.6, label = current_label)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n4.1 子图\n下面的例子绘制了4个子图，按照 \\(2\\times 2\\) 的方式排列nrows=2, ncols=2：\n\nnp.random.seed(123)\nfig, axes = plt.subplots(nrows=2, ncols=2,figsize=(10,8),sharex=True,sharey=True)\nfor i in range(2):\n    for j in range(2):\n        m, s = np.random.uniform(-1, 1), np.random.uniform(1, 2)\n        x = np.random.normal(m,s,100)\n        axes[i, j].hist(x, alpha = 0.6, bins=20)\n        title = rf\"$\\mu = {m:.2f},\\quad \\sigma = {s:.2f}$\"\n        axes[i, j].set(title = title, xticks = [-4, 0, 4],yticks = [])\nplt.show()\n\n\n\n\n\n\n\n\n\n\n4.2 图形风格\n\nplt.style.available\n\n['Solarize_Light2',\n '_classic_test_patch',\n '_mpl-gallery',\n '_mpl-gallery-nogrid',\n 'bmh',\n 'classic',\n 'dark_background',\n 'fast',\n 'fivethirtyeight',\n 'ggplot',\n 'grayscale',\n 'petroff10',\n 'seaborn-v0_8',\n 'seaborn-v0_8-bright',\n 'seaborn-v0_8-colorblind',\n 'seaborn-v0_8-dark',\n 'seaborn-v0_8-dark-palette',\n 'seaborn-v0_8-darkgrid',\n 'seaborn-v0_8-deep',\n 'seaborn-v0_8-muted',\n 'seaborn-v0_8-notebook',\n 'seaborn-v0_8-paper',\n 'seaborn-v0_8-pastel',\n 'seaborn-v0_8-poster',\n 'seaborn-v0_8-talk',\n 'seaborn-v0_8-ticks',\n 'seaborn-v0_8-white',\n 'seaborn-v0_8-whitegrid',\n 'tableau-colorblind10']\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use(\"ggplot\")\n\ndef f(x, theta):\n    return np.cos(np.pi * theta * x ) * np.exp(- x)\n\nθ_vals = np.linspace(0, 2, 10)\nx = np.linspace(0, 5, 200)\nfig, ax = plt.subplots(figsize=(8, 6))\n\nfor theta in θ_vals:\n    ax.plot(x, f(x, theta), label = rf\"$\\theta = {theta:.2f}$\")\n\nax.legend()\nplt.show()"
  },
  {
    "objectID": "matplotlib.html#应用收益率的几个典型事实",
    "href": "matplotlib.html#应用收益率的几个典型事实",
    "title": "数据可视化",
    "section": "5 应用：收益率的几个典型事实",
    "text": "5 应用：收益率的几个典型事实\n这部分内容，\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport yfinance as yf\nimport scipy.stats as stats\nimport statsmodels.api as sm\n\n然后下载或读取数据：\n\n# df = yf.download(['^GSPC', '^VIX'], \n#                 start='1990-01-01',\n#                 auto_adjust=True,                \n#                 progress=False)['Close']\n# df.to_csv('datasets/sp500_vix.csv')\n\ndf = pd.read_csv('datasets/sp500_vix.csv',                \n                header=0,\n                index_col=0,\n                parse_dates=True)\ndf.columns = [\"SP500\", \"VIX\"]\ndf['log_ret'] = np.log(df['SP500']/df['SP500'].shift(1))\ndf.dropna(inplace=True)\n\n\n5.1 厚尾\n\nfig,ax =plt.subplots(1,2,figsize=(10,6))\nsns.kdeplot(df['log_ret'], fill=False,label='kernel density',ax=ax[0])\nmu, sigma = stats.norm.fit(df['log_ret'])\nx = np.linspace(df['log_ret'].min(), df['log_ret'].max(), 1000)\ny = stats.norm.pdf(x, mu, sigma)\nax[0].plot(x, y, color='r', label='Normal Distribution',linestyle='--')\nax[0].legend(frameon=False)\nsm.qqplot(df['log_ret'], line='s', ax=ax[1])\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.2 高斯性质\n\nperiods = ['D','W','ME']\nfrequency = ['daily','weekly','monthly']\n\nfig, ax = plt.subplots(2,3,figsize=(12,8))\nfor i, p in enumerate(periods):\n    df_resample = df.resample(p).last()\n    log_return = np.log(df_resample['SP500']/df_resample['SP500'].shift(1)).dropna()\n    sns.histplot(log_return, kde=True,label='Histogram',ax=ax[0][i])\n    ax[0][i].set_title(frequency[i])\n    sm.qqplot(log_return, line='s', ax=ax[1][i])\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.3 波动集聚性\n\nfig, ax = plt.subplots(dpi=300,figsize=(10,6))\nax.plot(df['log_ret']*100,\n        label='SP500 Log Return')\nax.set_ylabel('Log Returns(%)')\nax.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.4 自相关\n\nfrom statsmodels.graphics.tsaplots import plot_acf\n\nperiods = ['D','W','ME']\nfrequency = ['daily','weekly','monthly']\n\nfig, ax = plt.subplots(3,3,figsize=(12, 8))\nfor i, p in enumerate(periods):\n    df_resample = df.resample(p).last()\n    log_return = np.log(df_resample['SP500']/df_resample['SP500'].shift(1)).dropna()\n    plot_acf(log_return,ax=ax[i][0],title='')  \n    plot_acf(log_return**2,ax=ax[i][1],title='')    \n    plot_acf(np.abs(log_return),ax=ax[i][2],title='')    \nax[0][0].set_ylabel('Daily Return')\nax[1][0].set_ylabel('Weekly Return')\nax[2][0].set_ylabel('Monthly Return')\nax[0][0].set_title('Log Return')\nax[0][1].set_title('Squared Return')\nax[0][2].set_title('Absolute Return')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.5 杠杆效应\n\ndf = pd.read_csv('datasets/sp500_vix.csv',                \n                header=0,\n                index_col=0,\n                parse_dates=True)\ndf.columns = [\"SP500\", \"VIX\"]\nret_sp = np.log(df/df.shift(1)).dropna()\n\nfig, ax = plt.subplots(2,1,figsize=(10, 8))\nax[0].plot(df['SP500'].loc[\"2018\":],\n             color='blue',lw=2)\nax[0].set_xlabel('Time')\nax[0].set_ylabel('Close Price')\nax2 = ax[0].twinx()\nax2.plot(ret_sp['SP500'].loc[\"2018\":],\n             color='red',alpha=0.7,lw=0.5)\nax2.set_ylabel('Log Return')\nsns.regplot(x='SP500', y='VIX', \n            data=ret_sp, ax=ax[1])\nax[1].set_xlabel('Log Returns of SP500')\nax[1].set_ylabel('Log Returns of Implied VIX')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "Pandas 及应用",
    "section": "",
    "text": "Pandas是数据分析最常用的包:"
  },
  {
    "objectID": "pandas.html#pandas-序列",
    "href": "pandas.html#pandas-序列",
    "title": "Pandas 及应用",
    "section": "1 Pandas 序列",
    "text": "1 Pandas 序列\nPandas中两类数据，Series 和 DataFrame；\nSeries 基于Numpy数组，支持许多类似运算；\nSeries 可以看作一“列”数据；\nDataFrame 可以看作储存相应列数据的二维对象；类似Excel表单；\nSeries一些方法\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(123)\ns = pd.Series(np.random.randn(100), name=\"daily return\")\ns.plot();\nnp.abs(s)\ns.describe()\n\ncount    100.000000\nmean       0.027109\nstd        1.133924\nmin       -2.798589\n25%       -0.832745\n50%       -0.053270\n75%        0.983388\nmax        2.392365\nName: daily return, dtype: float64\n\n\n\n\n\n\n\n\n\n\n1.1 Pandas数据框\nDataFrames 是几列数据组成，每一列对应一个变量；\n用来方便的处理行和列组织的数据；索引（index）对应行，变量列名（columns）对应列；\n可以读取各类软件格式存储数据，csv, excel, stata, html, json,sql等；"
  },
  {
    "objectID": "pandas.html#应用penn-world-table",
    "href": "pandas.html#应用penn-world-table",
    "title": "Pandas 及应用",
    "section": "2 应用：Penn World Table",
    "text": "2 应用：Penn World Table\n这一部分应用Penn World Table介绍对原始数据的一些常见处理方法。该数据集当前版本为PWT 10.01，包含183个国家1950-2019年的收入、产出、投入和生产率等指标，详细介绍可参见User Guide to PWT 10.0 data files。数据背后的方法、理论及使用建议，可参见 Feenstra, Inklaar, and Timmer (2015)。\n网站提供了Stata和Excel格式数据，这里我们下载了后者。数据本身是一个面板数据（Panel Data），“国家 - 年” 唯一识别一个观测值。我们从截面数据入手先只保留2019年数据， 然后再看更复杂的情况。\n\n2.1 导入数据\n假设数据保存在当前路径的datasets子文件中：\n\nimport pandas as pd\npwt = pd.read_excel(io = \"datasets/pwt1001.xlsx\",\n                header=0,                \n                sheet_name=\"Data\")\n# 保留2019年数据\npwt2019 = pwt[pwt['year'] == 2019].copy().drop(labels='cor_exp',axis=1)\n\n注意其中的几个参数，io是文件路径；header表明列标题行，这里是第一行；sheet_name是数据所在表单名；将载入的数据赋值给pwt数据框。我们只保留2019年的观测值，变量cor_exp在这一年全部为缺失值，这里直接删除了。\n先为pwt2019数据框设置索引变量，这里使用国家名代码变量（countrycode）：\n\npwt2019.set_index('countrycode', inplace=True)\n\n可以df.info()概率数据集，或者使用df.head()或df.tail()查看头部和尾部观测值：\n\npwt2019.info()\npwt2019.head()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 183 entries, ABW to ZWE\nData columns (total 50 columns):\n #   Column         Non-Null Count  Dtype  \n---  ------         --------------  -----  \n 0   country        183 non-null    object \n 1   currency_unit  183 non-null    object \n 2   year           183 non-null    int64  \n 3   rgdpe          183 non-null    float64\n 4   rgdpo          183 non-null    float64\n 5   pop            183 non-null    float64\n 6   emp            177 non-null    float64\n 7   avh            66 non-null     float64\n 8   hc             145 non-null    float64\n 9   ccon           183 non-null    float64\n 10  cda            183 non-null    float64\n 11  cgdpe          183 non-null    float64\n 12  cgdpo          183 non-null    float64\n 13  cn             180 non-null    float64\n 14  ck             137 non-null    float64\n 15  ctfp           118 non-null    float64\n 16  cwtfp          118 non-null    float64\n 17  rgdpna         183 non-null    float64\n 18  rconna         183 non-null    float64\n 19  rdana          183 non-null    float64\n 20  rnna           180 non-null    float64\n 21  rkna           137 non-null    float64\n 22  rtfpna         118 non-null    float64\n 23  rwtfpna        118 non-null    float64\n 24  labsh          138 non-null    float64\n 25  irr            137 non-null    float64\n 26  delta          180 non-null    float64\n 27  xr             183 non-null    float64\n 28  pl_con         183 non-null    float64\n 29  pl_da          183 non-null    float64\n 30  pl_gdpo        183 non-null    float64\n 31  i_cig          183 non-null    object \n 32  i_xm           183 non-null    object \n 33  i_xr           183 non-null    object \n 34  i_outlier      183 non-null    object \n 35  i_irr          137 non-null    object \n 36  statcap        127 non-null    float64\n 37  csh_c          183 non-null    float64\n 38  csh_i          183 non-null    float64\n 39  csh_g          183 non-null    float64\n 40  csh_x          183 non-null    float64\n 41  csh_m          183 non-null    float64\n 42  csh_r          183 non-null    float64\n 43  pl_c           183 non-null    float64\n 44  pl_i           183 non-null    float64\n 45  pl_g           183 non-null    float64\n 46  pl_x           183 non-null    float64\n 47  pl_m           183 non-null    float64\n 48  pl_n           180 non-null    float64\n 49  pl_k           137 non-null    float64\ndtypes: float64(42), int64(1), object(7)\nmemory usage: 72.9+ KB\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\n\n\n5 rows × 50 columns\n\n\n\n默认显示5条观测值，如果希望看到更多观测值，可以使用 df.tail(n=10) 修改数值。\n可以应用.shape, .ndim,.columns等属性查看基本信息，可以看到数据集包含51个变量共183个观测值。\n\nprint(pwt2019.shape)\nprint(pwt2019.columns)\n\n(183, 50)\nIndex(['country', 'currency_unit', 'year', 'rgdpe', 'rgdpo', 'pop', 'emp',\n       'avh', 'hc', 'ccon', 'cda', 'cgdpe', 'cgdpo', 'cn', 'ck', 'ctfp',\n       'cwtfp', 'rgdpna', 'rconna', 'rdana', 'rnna', 'rkna', 'rtfpna',\n       'rwtfpna', 'labsh', 'irr', 'delta', 'xr', 'pl_con', 'pl_da', 'pl_gdpo',\n       'i_cig', 'i_xm', 'i_xr', 'i_outlier', 'i_irr', 'statcap', 'csh_c',\n       'csh_i', 'csh_g', 'csh_x', 'csh_m', 'csh_r', 'pl_c', 'pl_i', 'pl_g',\n       'pl_x', 'pl_m', 'pl_n', 'pl_k'],\n      dtype='object')\n\n\n\n\n2.2 选择观测值和变量\n应用中经常对某些观测值或特定子集进行操作，因此很重要的一步是选择观测值和变量。\n最基本的方法可以通过Python数组的切片（slicing）方式选择特定的行。例如，选择第3至5个观测值：\n\npwt2019[2:5]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\n\n\n3 rows × 50 columns\n\n\n\n要选择列，可以用包含列名字的列表：\n\nvars_selected = ['country', 'rgdpe', 'rgdpo', 'pop', 'emp', 'cgdpe', 'cgdpo', 'ctfp' ]\ndf = pwt2019[vars_selected]\n\n\n2.2.1 .loc方法\n.loc 是基于 标签（label-based） 的数据选择方法。这意味着你使用行和列的实际标签名来选择数据，而不是它们的整数位置。\n例如，要选择金砖国家（BRICKS）的观测值：\n\nbricks = ['CHN', 'BRA', 'RUS', 'IND', 'ZAF']\npwt2019.loc[bricks]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCHN\nChina\nYuan Renminbi\n2019\n20056066.0\n2.025766e+07\n1433.783686\n798.807739\n2168.918848\n2.698987\n1.056606e+07\n...\n0.192402\n-0.167672\n-4.100976e-03\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nBRA\nBrazil\nBrazilian Real\n2019\n3089273.5\n3.080048e+06\n211.049527\n93.956825\n1707.795058\n3.091373\n2.566911e+06\n...\n0.132833\n-0.137775\n1.377994e-07\n0.599450\n0.528862\n0.663023\n0.646922\n0.638165\n0.355756\n0.579635\n\n\nRUS\nRussian Federation\nRussian Ruble\n2019\n4197222.5\n4.161194e+06\n145.872256\n71.670639\n1965.000000\n3.434408\n3.170826e+06\n...\n0.178951\n-0.086548\n-2.315040e-02\n0.411263\n0.573736\n0.281037\n0.576825\n0.690811\n0.466877\n0.366449\n\n\nIND\nIndia\nIndian Rupee\n2019\n8945547.0\n9.170555e+06\n1366.417754\n497.615723\n2122.940682\n2.171165\n6.608024e+06\n...\n0.051035\n-0.077878\n3.370060e-02\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.0\n7.340944e+05\n58.558270\n18.642710\n2191.363362\n2.908202\n6.236696e+05\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\n\n\n5 rows × 50 columns\n\n\n\n或者选择列：\n\nvariables = ['country', 'rgdpe', 'pop']\npwt2019.loc[:, variables]\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\nAruba\n3921.261230\n0.106314\n\n\nAGO\nAngola\n228151.015625\n31.825295\n\n\nAIA\nAnguilla\n376.634979\n0.014869\n\n\nALB\nAlbania\n35890.019531\n2.880917\n\n\nARE\nUnited Arab Emirates\n681525.812500\n9.770529\n\n\n...\n...\n...\n...\n\n\nVNM\nViet Nam\n750726.750000\n96.462106\n\n\nYEM\nYemen\n50052.933594\n29.161922\n\n\nZAF\nSouth Africa\n748940.000000\n58.558270\n\n\nZMB\nZambia\n57956.183594\n17.861030\n\n\nZWE\nZimbabwe\n42296.062500\n14.645468\n\n\n\n\n183 rows × 3 columns\n\n\n\n或者同时指定行和列：\n\npwt2019.loc[bricks, variables]\n\n\n\n\n\n\n\n\ncountry\nrgdpe\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nCHN\nChina\n20056066.0\n1433.783686\n\n\nBRA\nBrazil\n3089273.5\n211.049527\n\n\nRUS\nRussian Federation\n4197222.5\n145.872256\n\n\nIND\nIndia\n8945547.0\n1366.417754\n\n\nZAF\nSouth Africa\n748940.0\n58.558270\n\n\n\n\n\n\n\n\n\n2.2.2 .iloc方法\n相应的，.iloc 是基于整数位置（integer-location based）的，使用行和列的整数位置（从 0 开始）来选择数据。例如：\n\n# 选择第2行数据（索引位置为1）\npwt2019.iloc[1]\n# 选择第1行（索引为0）、第3行（索引为2）和第5行（索引为4）\npwt2019.iloc[[0, 2, 4]]\n# 选择前5行、第4至第6列观测值\npwt2019.iloc[:5, 3:6]\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\npop\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\n3921.261230\n3467.299561\n0.106314\n\n\nAGO\n228151.015625\n227855.718750\n31.825295\n\n\nAIA\n376.634979\n225.680527\n0.014869\n\n\nALB\n35890.019531\n36103.042969\n2.880917\n\n\nARE\n681525.812500\n645956.250000\n9.770529\n\n\n\n\n\n\n\n这里需要注意Python中索引位置。Python中进行切片（slicing）操作时，语法通常类似 [start:end]，要注意：\n\nstart：切片的起始索引，对应的元素会被包含。\nend：切片的结束索引，对应的元素不会被包含。\n\n\n\n2.2.3 根据条件筛选\n除了根据索引或位置选择数据外，也可以利用条件来筛选观测值。例如，根据人口变量（pop，单位：百万）选择2019年总人口超过2亿的观测值：\n\npwt2019[pwt2019['pop'] &gt;= 200]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBRA\nBrazil\nBrazilian Real\n2019\n3.089274e+06\n3.080048e+06\n211.049527\n93.956825\n1707.795058\n3.091373\n2.566911e+06\n...\n0.132833\n-0.137775\n1.377994e-07\n0.599450\n0.528862\n0.663023\n0.646922\n0.638165\n0.355756\n0.579635\n\n\nCHN\nChina\nYuan Renminbi\n2019\n2.005607e+07\n2.025766e+07\n1433.783686\n798.807739\n2168.918848\n2.698987\n1.056606e+07\n...\n0.192402\n-0.167672\n-4.100976e-03\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nIDN\nIndonesia\nRupiah\n2019\n3.104439e+06\n3.137931e+06\n270.625568\n131.170685\n2019.923395\n2.288165\n2.051190e+06\n...\n0.089377\n-0.081947\n-1.223290e-03\n0.377086\n0.359957\n0.295082\n0.601248\n0.669811\n0.215823\n0.387587\n\n\nIND\nIndia\nIndian Rupee\n2019\n8.945547e+06\n9.170555e+06\n1366.417754\n497.615723\n2122.940682\n2.171165\n6.608024e+06\n...\n0.051035\n-0.077878\n3.370060e-02\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\nNGA\nNigeria\nNaira\n2019\n9.834982e+05\n1.001537e+06\n200.963599\n73.020554\nNaN\n1.974245\n9.300954e+05\n...\n0.106134\n-0.078965\n-6.898887e-02\n0.418511\n1.166929\n0.288400\n0.507703\n0.602859\n0.788816\n0.920094\n\n\nPAK\nPakistan\nPakistan Rupee\n2019\n1.036800e+06\n1.088502e+06\n216.565318\n63.085052\n1966.907180\n1.770760\n1.023950e+06\n...\n0.040008\n-0.087298\n-2.582011e-14\n0.231672\n0.340412\n0.287822\n0.571041\n0.537927\n0.205466\nNaN\n\n\nUSA\nUnited States\nUS Dollar\n2019\n2.086051e+07\n2.059584e+07\n329.064917\n158.299591\n1765.346390\n3.749341\n1.682624e+07\n...\n0.111490\n-0.165832\n1.459136e-02\n1.005707\n0.988310\n1.266850\n0.717118\n0.752818\n1.069356\n1.000000\n\n\n\n\n7 rows × 50 columns\n\n\n\n注意，pwt2019['pop'] &gt;= 200 的结果是一列布林值，然后pwt2019[]选择返回取值为True的观测值。\n再例如，下面的代码包含了两个条件：\n\n国家名属于金砖国家。注意这里使用了Pandas 中的df.isin()函数；\n2019年人口超过10亿。\n\n当有不止一个条件时，我们用&, |表示and 和 or运算符；\n\nBRICKS = ['China','Brazil',  ' Russian Federation', 'India', 'South Africa']\n#\npwt2019[(pwt2019['country'].isin(BRICKS)) & (pwt2019['pop'] &gt; 1000)]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCHN\nChina\nYuan Renminbi\n2019\n20056066.0\n20257660.0\n1433.783686\n798.807739\n2168.918848\n2.698987\n10566063.0\n...\n0.192402\n-0.167672\n-0.004101\n0.716501\n0.679048\n0.865375\n0.695068\n0.734048\n0.457278\n0.598894\n\n\nIND\nIndia\nIndian Rupee\n2019\n8945547.0\n9170555.0\n1366.417754\n497.615723\n2122.940682\n2.171165\n6608023.5\n...\n0.051035\n-0.077878\n0.033701\n0.294905\n0.356979\n0.471800\n0.692824\n0.672622\n0.210450\n0.395132\n\n\n\n\n2 rows × 50 columns\n\n\n\n更复杂的情况，可以在条件语句中加入数学表达式。例如，下面的代码筛选了人均实际GDP超过2万美元和人口超过5000万的国家的观测值，这里人均实际GDP是购买力平价调整后支出法衡量的实际GDP与人口的比值：\n\npwt2019[(pwt2019['rgdpe']/pwt2019['pop'] &gt; 20000) & (pwt2019['pop'] &gt; 50)]\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEU\nGermany\nEuro\n2019\n4.308862e+06\n4275312.00\n83.517045\n44.795197\n1386.196834\n3.675378\n3.078229e+06\n...\n0.603715\n-0.550977\n0.000000\n0.881662\n0.850929\n1.006024\n0.701677\n0.673799\n0.822418\n0.651490\n\n\nFRA\nFrance\nEuro\n2019\n3.018885e+06\n2946958.25\n67.351247\n28.532564\n1504.912353\n3.230137\n2.233350e+06\n...\n0.274841\n-0.327385\n0.022188\n0.913003\n0.813518\n0.987091\n0.686175\n0.665962\n0.716193\n0.576515\n\n\nGBR\nUnited Kingdom\nPound Sterling\n2019\n3.118991e+06\n2989895.50\n67.530172\n32.982498\n1667.947711\n3.773596\n2.414706e+06\n...\n0.227445\n-0.346071\n0.065275\n0.992262\n0.699868\n0.912168\n0.687633\n0.668252\n0.624869\n0.796017\n\n\nITA\nItaly\nEuro\n2019\n2.508404e+06\n2466327.50\n60.550075\n25.596329\n1717.833818\n3.158385\n1.810091e+06\n...\n0.307117\n-0.292341\n0.001006\n0.846609\n0.590234\n0.969897\n0.704260\n0.657741\n0.471262\n0.585280\n\n\nJPN\nJapan\nYen\n2019\n5.028348e+06\n5036891.00\n126.860301\n69.976692\n1691.085260\n3.593987\n3.765120e+06\n...\n0.190841\n-0.190701\n0.005592\n1.048585\n1.007949\n0.932528\n0.734816\n0.751225\n1.011635\n0.788685\n\n\nKOR\nRepublic of Korea\nWon\n2019\n2.090946e+06\n2162705.25\n51.225308\n26.798534\n1979.526258\n3.765123\n1.314779e+06\n...\n0.466232\n-0.403080\n0.000459\n0.848224\n0.732208\n0.758751\n0.654067\n0.701660\n0.557140\n0.657925\n\n\nRUS\nRussian Federation\nRussian Ruble\n2019\n4.197222e+06\n4161194.50\n145.872256\n71.670639\n1965.000000\n3.434408\n3.170826e+06\n...\n0.178951\n-0.086548\n-0.023150\n0.411263\n0.573736\n0.281037\n0.576825\n0.690811\n0.466877\n0.366449\n\n\nTUR\nTurkey\nNew Turkish Lira\n2019\n2.227538e+06\n2248225.75\n83.429615\n28.087334\n1832.000000\n2.514292\n1.555716e+06\n...\n0.119963\n-0.147055\n0.066752\n0.393921\n0.313990\n0.259054\n0.671110\n0.636799\n0.207867\n0.477120\n\n\nUSA\nUnited States\nUS Dollar\n2019\n2.086051e+07\n20595844.00\n329.064917\n158.299591\n1765.346390\n3.749341\n1.682624e+07\n...\n0.111490\n-0.165832\n0.014591\n1.005707\n0.988310\n1.266850\n0.717118\n0.752818\n1.069356\n1.000000\n\n\n\n\n9 rows × 50 columns\n\n\n\n\n\n\n2.3 apply 方法\nPandas中一个广泛应用的方法是 df.apply()，它将一个函数应用到每一行/列，返回一个序列；\n函数可以是内嵌的（built in）也可以是自定义的，例如，计算每一列的最大值，为了节省输出空间，使用子集df数据框：\n\ndf.apply(np.max, axis=0)\n\ncountry       Zimbabwe\nrgdpe       20860506.0\nrgdpo       20595844.0\npop        1433.783686\nemp         798.807739\ncgdpe       20791364.0\ncgdpo       20566034.0\nctfp          1.276913\ndtype: object\n\n\n或者，自定义一个函数range(x)计算极差：\n\nimport numpy as np\ndef range(x):\n    return np.max(x) - np.min(x)\ndf.select_dtypes(np.number).apply(range)\n\nrgdpe    2.086041e+07\nrgdpo    2.059577e+07\npop      1.433779e+03\nemp      7.988052e+02\ncgdpe    2.079126e+07\ncgdpo    2.056595e+07\nctfp     1.222178e+00\ndtype: float64\n\n\n再例如，归一化（normalization）经常使用minmax方法： \\[\nY = \\frac{X_{i} - \\min(X_{i})}{\\max(X_{i}) - \\min(X_{i})}\n\\]\n我们定义一个函数minmax()，然后应用apply()方法：\n\ndef minmax(S):\n    return (S-S.min())/(S.max() - S.min())\npwt2019[['pop','rgdpe', 'emp']].apply(minmax)\n\n\n\n\n\n\n\n\npop\nrgdpe\nemp\n\n\ncountrycode\n\n\n\n\n\n\n\nABW\n0.000071\n0.000183\n0.000056\n\n\nAGO\n0.022193\n0.010932\n0.020834\n\n\nAIA\n0.000007\n0.000013\nNaN\n\n\nALB\n0.002006\n0.001716\n0.001344\n\n\nARE\n0.006811\n0.032666\n0.007269\n\n\n...\n...\n...\n...\n\n\nVNM\n0.067275\n0.035983\n0.063091\n\n\nYEM\n0.020336\n0.002395\n0.006922\n\n\nZAF\n0.040838\n0.035898\n0.023335\n\n\nZMB\n0.012454\n0.002774\n0.006538\n\n\nZWE\n0.010211\n0.002023\n0.008548\n\n\n\n\n183 rows × 3 columns\n\n\n\n经常将lambda函数方法与df.apply()方法相结合。例如，数据集中有4个指标度量GDP，分别是['rgdpe', 'rgdpo','cgdpe','cgdpo']，假设我们希望计算一个加权平均数，权重为（0.3，0.2，0.3，0.2）：\n\nvariables = ['rgdpe', 'rgdpo','cgdpe','cgdpo']\ndf[variables].apply(lambda row:\n    row['rgdpe']*0.3 + row['rgdpo']*0.2 + row['cgdpe']*0.3 + row['cgdpo']*0.2,\n    axis=1)\n\ncountrycode\nABW      3736.787085\nAGO    227005.793750\nAIA       318.944440\nALB     35987.783203\nARE    664187.912500\n           ...      \nVNM    739027.362500\nYEM     50759.290625\nZAF    742988.068750\nZMB     57414.339062\nZWE     41768.012500\nLength: 183, dtype: float64\n\n\n注意，z选项axis = 1 ，将函数应用至每一行，默认值为0。\n\n\n2.4 检测和处理缺失值\nPandas中最常用的缺失值表示是NaN（Not a Number）。可以使用isnull()或isna()函数检测缺失值，返回一个布尔型的DataFrame，其中True表示缺失值：\n\npwt2019.isna()\n#pwt2019.isnull()\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nAGO\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nAIA\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nALB\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nARE\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nYEM\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nZAF\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nZMB\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nZWE\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n183 rows × 50 columns\n\n\n\n下面的的代码计算了缺失值的数量，将其除以样本容量得到缺失值比例，然后按照降序排序，并将比例最高的前15个变量绘制柱形图：\n\nfig, ax = plt.subplots(figsize=(8, 6))\n(pwt2019.isna().sum()/pwt2019.shape[0]*100).sort_values(ascending=False)[:15].plot(kind='bar', ax=ax)\nax.set_ylabel(\"%\")\nplt.show()\n\n\n\n\n\n\n\n\n另一种图示的方法是类似矩阵绘图的方式，将缺失值标记出来，missingno库有简单的命令实现：\n\nimport missingno as msno\nplt.figure(figsize=(12, 6))\nmsno.matrix(pwt2019)\nplt.title(\"Missing Values Matrix\")\nplt.show()\n\n&lt;Figure size 1152x576 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n删除缺失值\n处理缺失值的方法有很多种，选择哪种方法取决于你的数据特性、缺失原因以及分析目标。最直接的方法是使用df.dropna()函数删除包含缺失值的行或列：\n\n# 删除含缺失值的行\npwt2019.dropna()\n# 删除含缺失值的列\npwt2019.dropna(axis=1)\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nccon\ncda\ncgdpe\ncgdpo\n...\ncsh_i\ncsh_g\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n3023.694824\n3877.659668\n3912.334717\n3466.241943\n...\n0.246366\n0.214084\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n155943.718750\n198750.421875\n227771.609375\n223289.312500\n...\n0.191710\n0.199723\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n438.470032\n509.044983\n375.136444\n241.384537\n...\n0.292376\n0.303098\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n33399.167969\n40868.316406\n35808.343750\n36288.328125\n...\n0.205828\n0.206071\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n306771.156250\n515623.312500\n678241.187500\n635332.812500\n...\n0.328729\n0.127105\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n582677.062500\n758821.937500\n747853.750000\n723142.687500\n...\n0.243582\n0.095490\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n49266.472656\n67992.531250\n49937.042969\n51983.429688\n...\n0.360231\n0.300234\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n623669.562500\n741675.937500\n748245.937500\n735067.062500\n...\n0.160538\n0.227329\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n38698.402344\n56536.863281\n57695.066406\n56811.105469\n...\n0.313996\n0.171331\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n43961.839844\n47128.785156\n42325.117188\n41081.722656\n...\n0.077089\n0.227109\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n\n\n\n\n183 rows × 32 columns\n\n\n\n另外，上面的命令并没有改变原数据框，可以通过赋值方式保存。或者加上选项df.dropna(inplace=True)，即在原数据框中生效。\n填充\ndf.fillna()是用于填充缺失值的核心函数。\n\n#\npwt2019.fillna(0)\n#\npwt2019.select_dtypes(np.number).fillna(0).combine_first(pwt2019)\npwt2019.select_dtypes(np.number).fillna(pwt2019.mean(numeric_only=True)).combine_first(pwt2019)\npwt2019.select_dtypes(np.number).fillna(pwt2019.median(numeric_only=True)).combine_first(pwt2019)\n\n\n\n\n\n\n\n\navh\nccon\ncda\ncgdpe\ncgdpo\nck\ncn\ncountry\ncsh_c\ncsh_g\n...\nrgdpe\nrgdpna\nrgdpo\nrkna\nrnna\nrtfpna\nrwtfpna\nstatcap\nxr\nyear\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1818.281597\n3023.694824\n3877.659668\n3912.334717\n3466.241943\n0.000209\n1.742797e+04\nAruba\n0.658242\n0.214084\n...\n3921.261230\n3068.758301\n3467.299561\n1.032467\n1.739027e+04\n0.995869\n1.000326\n67.777800\n1.790000\n2019\n\n\nAGO\n1818.281597\n155943.718750\n198750.421875\n227771.609375\n223289.312500\n0.016624\n1.299232e+06\nAngola\n0.498670\n0.199723\n...\n228151.015625\n222151.062500\n227855.718750\n1.005457\n1.300951e+06\n0.936524\n0.916698\n48.888900\n364.825805\n2019\n\n\nAIA\n1818.281597\n438.470032\n509.044983\n375.136444\n241.384537\n0.005160\n2.266816e+03\nAnguilla\n1.513381\n0.303098\n...\n376.634979\n223.456711\n225.680527\n1.068386\n2.260053e+03\n0.995869\n1.000326\n67.777800\n2.700000\n2019\n\n\nALB\n1818.281597\n33399.167969\n40868.316406\n35808.343750\n36288.328125\n0.005160\n2.239714e+05\nAlbania\n0.714312\n0.206071\n...\n35890.019531\n37204.773438\n36103.042969\n1.068386\n2.226235e+05\n0.995869\n1.000326\n78.888900\n109.850833\n2019\n\n\nARE\n1818.281597\n306771.156250\n515623.312500\n678241.187500\n635332.812500\n0.005160\n4.453746e+06\nUnited Arab Emirates\n0.355746\n0.127105\n...\n681525.812500\n647986.250000\n645956.250000\n1.068386\n4.454460e+06\n0.995869\n1.000326\n67.777800\n3.672500\n2019\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2131.968232\n582677.062500\n758821.937500\n747853.750000\n723142.687500\n0.005160\n1.962286e+06\nViet Nam\n0.710267\n0.095490\n...\n750726.750000\n741653.562500\n724123.375000\n1.068386\n1.964750e+06\n0.995869\n1.000326\n78.888900\n23050.241667\n2019\n\n\nYEM\n1818.281597\n49266.472656\n67992.531250\n49937.042969\n51983.429688\n0.005160\n5.312318e+05\nYemen\n0.647500\n0.300234\n...\n50052.933594\n40069.593750\n51828.058594\n1.068386\n5.404372e+05\n0.995869\n1.000326\n38.888867\n250.250000\n2019\n\n\nZAF\n2191.363362\n623669.562500\n741675.937500\n748245.937500\n735067.062500\n0.033228\n2.816883e+06\nSouth Africa\n0.621124\n0.227329\n...\n748940.000000\n732851.625000\n734094.375000\n1.036546\n2.811258e+06\n0.965773\n0.972355\n75.555567\n14.448427\n2019\n\n\nZMB\n1818.281597\n38698.402344\n56536.863281\n57695.066406\n56811.105469\n0.004523\n2.841112e+05\nZambia\n0.509846\n0.171331\n...\n57956.183594\n56282.273438\n56783.714844\n1.117712\n2.851388e+05\n0.955966\n0.921073\n55.555567\n12.889418\n2019\n\n\nZWE\n1818.281597\n43961.839844\n47128.785156\n42325.117188\n41081.722656\n0.000733\n5.939553e+04\nZimbabwe\n0.842998\n0.227109\n...\n42296.062500\n42694.070312\n40826.570312\n1.055221\n5.974304e+04\n0.910977\n0.902522\n56.666633\n1.000000\n2019\n\n\n\n\n183 rows × 50 columns\n\n\n\n\n#pwt2019.fillna(method='ffill')\npwt2019.fillna(method='bfill')\n\nC:\\Users\\admin\\AppData\\Local\\Temp\\ipykernel_54420\\1604694572.py:2: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n  pwt2019.fillna(method='bfill')\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\n1609.068998\n1.481984\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\n1609.068998\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n1.075898\n1609.068998\n2.964992\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.793385\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\n1609.068998\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.793385\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\n1609.068998\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.793385\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n0.525546\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\n2191.363362\n1.842989\n49266.472656\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n0.525546\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\nNaN\n2.686845\n38698.402344\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 50 columns\n\n\n\n插值法（Interpolation）\n除了填充给定值以外，也有更复杂的插值法。\n\npwt2019.interpolate(method=\"linear\")\n\nC:\\Users\\admin\\AppData\\Local\\Temp\\ipykernel_54420\\33985437.py:1: FutureWarning: DataFrame.interpolate with object dtype is deprecated and will raise in a future version. Call obj.infer_objects(copy=False) before interpolating instead.\n  pwt2019.interpolate(method=\"linear\")\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\n8.860430\nNaN\n2.223488\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.495372\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.594710\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.694047\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n1.485950\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\n2161.665797\n1.842989\n49266.472656\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n1.005748\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\n2191.363362\n2.686845\n38698.402344\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\n2191.363362\n2.713408\n43961.839844\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 50 columns\n\n\n\n更复杂的方法涉及到模型估计问题，如KNN预测等。Scikit-learn库有专门的方法，这里就不多涉及。\n\nfrom sklearn.impute import SimpleImputer\nimputer_mean = SimpleImputer(strategy='mean')\npd.DataFrame(imputer_mean.fit_transform(pwt2019.select_dtypes(np.number)), columns=pwt2019.select_dtypes(np.number).columns)\n\n\n\n\n\n\n\n\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\n\n\n0\n2019.0\n3921.261230\n3467.299561\n0.106314\n0.047601\n1849.981084\n2.709271\n3023.694824\n3877.659668\n3912.334717\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\n1\n2019.0\n228151.015625\n227855.718750\n31.825295\n16.644962\n1849.981084\n1.481984\n155943.718750\n198750.421875\n227771.609375\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\n2\n2019.0\n376.634979\n225.680527\n0.014869\n18.736708\n1849.981084\n2.709271\n438.470032\n509.044983\n375.136444\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\n0.835094\n\n\n3\n2019.0\n35890.019531\n36103.042969\n2.880917\n1.075898\n1849.981084\n2.964992\n33399.167969\n40868.316406\n35808.343750\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\n0.835094\n\n\n4\n2019.0\n681525.812500\n645956.250000\n9.770529\n5.808834\n1849.981084\n2.746695\n306771.156250\n515623.312500\n678241.187500\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\n0.835094\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n178\n2019.0\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n758821.937500\n747853.750000\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\n0.835094\n\n\n179\n2019.0\n50052.933594\n51828.058594\n29.161922\n5.531877\n1849.981084\n1.842989\n49266.472656\n67992.531250\n49937.042969\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\n0.835094\n\n\n180\n2019.0\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n741675.937500\n748245.937500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\n181\n2019.0\n57956.183594\n56783.714844\n17.861030\n5.225448\n1849.981084\n2.686845\n38698.402344\n56536.863281\n57695.066406\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\n182\n2019.0\n42296.062500\n40826.570312\n14.645468\n6.831017\n1849.981084\n2.713408\n43961.839844\n47128.785156\n42325.117188\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 43 columns\n\n\n\n\n\n2.5 缩尾处理\n应用中，常需要对异常值进行一定的处理，其中一种方法是缩尾处理（Winsorize），将极端值替换为某个百分位数的值，例如，将上限设为 99 百分位数，下限设为 1 百分位数。\n可以使用df.clip()函数实现，例如全要素生产率水平ctfp：\n\nq95 = pwt2019['ctfp'].quantile(0.95)\nq05 = pwt2019['ctfp'].quantile(0.05)\n\npwt2019['ctfp'].dropna().clip(lower=q05, upper=q95, inplace=False)\n\ncountrycode\nAGO    0.387996\nARG    0.828559\nARM    0.838301\nAUS    0.837649\nAUT    0.829206\n         ...   \nUSA    1.000000\nVEN    0.266597\nZAF    0.547630\nZMB    0.266597\nZWE    0.374524\nName: ctfp, Length: 118, dtype: float64\n\n\n\n\n2.6 观测值排序\n有时候需要对数据集进行一定的排序，Pandas中可以按索引(df.sort_index)和值（df.sort_values）排序。\n例如，将索引按降序排序，这里的索引是国家代码，因此升序/降序是按照字母顺序：\n\npwt2019.sort_index(ascending=False)\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZWE\nZimbabwe\nUS Dollar\n2019\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n...\n0.213562\n-0.270959\n-8.979837e-02\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\nZMB\nZambia\nKwacha\n2019\n57956.183594\n56783.714844\n17.861030\n5.225448\nNaN\n2.686845\n38698.402344\n...\n0.215397\n-0.238961\n2.839118e-02\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZAF\nSouth Africa\nRand\n2019\n748940.000000\n734094.375000\n58.558270\n18.642710\n2191.363362\n2.908202\n623669.562500\n...\n0.184207\n-0.198112\n4.914912e-03\n0.463660\n0.523813\n0.447869\n0.660216\n0.604546\n0.315006\n0.525546\n\n\nYEM\nYemen\nYemeni Rial\n2019\n50052.933594\n51828.058594\n29.161922\n5.531877\nNaN\n1.842989\n49266.472656\n...\n0.000723\n-0.135297\n-1.733917e-01\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\nNaN\n\n\nVNM\nViet Nam\nDong\n2019\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n...\n0.526032\n-0.518066\n-5.730492e-02\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nARE\nUnited Arab Emirates\nUAE Dirham\n2019\n681525.812500\n645956.250000\n9.770529\n5.808834\nNaN\n2.746695\n306771.156250\n...\n0.889652\n-0.701231\n-4.849206e-07\n0.725061\n0.480580\n0.692488\n0.688882\n0.647336\n0.270424\nNaN\n\n\nALB\nAlbania\nLek\n2019\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n...\n0.126594\n-0.313949\n6.114468e-02\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nAIA\nAnguilla\nEast Caribbean Dollar\n2019\n376.634979\n225.680527\n0.014869\nNaN\nNaN\nNaN\n438.470032\n...\n1.480300\n-2.445801\n-1.433542e-01\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nAGO\nAngola\nKwanza\n2019\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n...\n0.344351\n-0.113983\n-1.204703e-01\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nABW\nAruba\nAruban Guilder\n2019\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\n\n\n183 rows × 50 columns\n\n\n\n来看df.sort_values的例子，假设我们希望按2019年的人均GDP（PPP链式调整后）降序排列：\n\npwt2019['rgdp_per'] = pwt2019['rgdpe']/pwt2019['pop']\npwt2019.sort_values(by='rgdp_per', ascending=False) \n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nyear\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\n...\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\nrgdp_per\n\n\ncountrycode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLUX\nLuxembourg\nEuro\n2019\n69541.328125\n55710.792969\n0.615729\n0.460663\n1505.558542\n3.619643\n27761.587891\n...\n-0.634807\n0.471916\n1.068363\n0.746287\n1.494213\n0.699133\n0.634588\n0.679715\n1.277610\n112941.453342\n\n\nMAC\nChina, Macao SAR\nPataca\n2019\n67463.125000\n59874.164062\n0.640445\n0.387800\nNaN\n2.962418\n23970.996094\n...\n-0.287785\n0.704883\n0.786052\n0.792587\n0.848400\n0.709010\n0.694729\n0.575298\n2.026497\n105337.890061\n\n\nQAT\nQatar\nQatari Rial\n2019\n292963.531250\n323141.156250\n2.832067\n2.083951\nNaN\n3.259456\n86421.289062\n...\n-0.143853\n-0.100826\n0.887102\n0.496124\n0.890964\n0.526706\n0.649064\n0.333427\n0.602027\n103445.127269\n\n\nIRL\nIreland\nEuro\n2019\n499741.093750\n501053.593750\n4.882495\n2.260448\n1771.977942\n3.185517\n149572.484375\n...\n-0.338841\n-0.045312\n1.093603\n0.648436\n1.102568\n0.670558\n0.603306\n0.556753\n0.924193\n102353.631443\n\n\nSGP\nSingapore\nSingapore Dollar\n2019\n514376.312500\n477907.875000\n5.804337\n3.759604\n2330.165875\n4.351568\n229661.500000\n...\n-1.117445\n0.204641\n0.761578\n0.687142\n0.709089\n0.711649\n0.673213\n0.465293\n0.946837\n88619.305271\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nMWI\nMalawi\nKwacha\n2019\n20362.392578\n21635.066406\n18.628747\n7.950418\nNaN\n2.039123\n20989.886719\n...\n-0.241531\n0.077543\n0.362767\n0.652624\n0.379577\n0.619848\n0.560215\n0.474424\nNaN\n1093.062919\n\n\nCOD\nD.R. of the Congo\nFranc Congolais\n2019\n89061.671875\n88673.375000\n86.790567\n25.139931\nNaN\n1.679057\n78981.921875\n...\n-0.098445\n-0.059303\n0.460019\n0.950114\n0.540407\n0.646659\n0.656502\n0.620774\nNaN\n1026.167646\n\n\nCAF\nCentral African Republic\nCFA Franc BEAC\n2019\n4532.561035\n4642.448730\n4.745185\n1.844328\nNaN\n1.561627\n5007.587891\n...\n-0.131944\n-0.125820\n0.495756\n0.669973\n0.333296\n0.685964\n0.632491\n0.375996\n0.637043\n955.191639\n\n\nBDI\nBurundi\nBurundi Franc\n2019\n8664.988281\n9109.688477\n11.530580\n5.003588\nNaN\n1.416526\n9894.192383\n...\n-0.252394\n0.007603\n0.329781\n0.543323\n0.303669\n0.650272\n0.475958\n0.351376\n0.512554\n751.478961\n\n\nVEN\nVenezuela (Bolivarian Republic of)\nBolivar Fuerte\n2019\n7166.571777\n7160.106934\n28.515829\n11.694400\nNaN\n2.893462\n9266.067383\n...\n-0.001072\n-0.402837\n18.143538\n34.444988\n14.175777\n0.581305\n0.645909\n20.694918\n12.002436\n251.319075\n\n\n\n\n183 rows × 51 columns\n\n\n\n\n\n2.7 数据集合并\n实际应用中，数据可能来自不同的来源，经常需要合并数据集，pd.merge()函数\n\nimport wbgapi as wb\ninf = wb.data.DataFrame(series='NY.GDP.DEFL.KD.ZG', time='2019')\npd.merge(df[['country','pop','emp']], inf, left_index=True, right_index=True)\n\n\n\n\n\n\n\n\ncountry\npop\nemp\nNY.GDP.DEFL.KD.ZG\n\n\n\n\nABW\nAruba\n0.106314\n0.047601\n6.017818\n\n\nAGO\nAngola\n31.825295\n16.644962\n19.187004\n\n\nALB\nAlbania\n2.880917\n1.075898\n1.000633\n\n\nARE\nUnited Arab Emirates\n9.770529\n5.808834\n-3.194409\n\n\nARG\nArgentina\n44.780677\n20.643215\n49.195579\n\n\n...\n...\n...\n...\n...\n\n\nVNM\nViet Nam\n96.462106\n50.399563\n2.423227\n\n\nYEM\nYemen\n29.161922\n5.531877\nNaN\n\n\nZAF\nSouth Africa\n58.558270\n18.642710\n4.613525\n\n\nZMB\nZambia\n17.861030\n5.225448\n7.633470\n\n\nZWE\nZimbabwe\n14.645468\n6.831017\n225.394837\n\n\n\n\n180 rows × 4 columns\n\n\n\n\n\n2.8 多级索引\n这里的数据是一个面板数据，“国家-年”对应一个观测值，可以利用Pandas的多级索引功能，详见Pandas文档MultiIndex / advanced indexing。\n\npwt = pd.read_excel(io = \"datasets/pwt1001.xlsx\",\n                header=0,                \n                sheet_name=\"Data\")\npwt.set_index(['countrycode','year'], inplace=True)\n\n我们可以使用.loc()方法选择需要的数据，例如：\n\n# 中国子集\ndf_china = pwt.loc['CHN']\n# 中国、美国子集\ndf_china_us = pwt.loc[['CHN','USA']]\n# 变量子集\ndf_sub_china_us = pwt.loc[['CHN', 'USA']][['rgdpe','rgdpo']]\n\n如果需要选择某一年的截面数据：\n\npwt.loc[(slice(None), [2019]), :]\n# 1992年之后的数据\npwt.loc[(slice(None), slice(1992, None)), :]\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1992\nAruba\nAruban Guilder\n2944.516113\n3370.537598\n0.068235\n0.030903\nNaN\nNaN\n1722.105103\n2955.295898\n...\n0.777795\n-0.477860\n-0.035383\n0.412954\n0.259626\n0.432003\n0.319757\n0.482569\n0.269071\n0.903971\n\n\n1993\nAruba\nAruban Guilder\n3131.370850\n3698.532471\n0.072504\n0.032912\nNaN\nNaN\n1860.497559\n3167.873291\n...\n0.824972\n-0.601976\n-0.035119\n0.437298\n0.272653\n0.471235\n0.354660\n0.455204\n0.281028\n0.897604\n\n\n1994\nAruba\nAruban Guilder\n3537.953369\n4172.824219\n0.076700\n0.034896\nNaN\nNaN\n2015.998657\n3393.726807\n...\n0.764192\n-0.501460\n-0.040448\n0.447622\n0.297497\n0.427549\n0.377078\n0.508004\n0.310169\n0.939461\n\n\n1995\nAruba\nAruban Guilder\n3412.874512\n4184.156250\n0.080324\n0.036628\nNaN\nNaN\n2034.535400\n3435.050781\n...\n0.765721\n-0.542942\n-0.030582\n0.451724\n0.303802\n0.525235\n0.404533\n0.547051\n0.282667\n0.820760\n\n\n1996\nAruba\nAruban Guilder\n3428.601074\n3977.093018\n0.083200\n0.038026\nNaN\nNaN\n2167.170654\n3444.941162\n...\n0.840301\n-0.669186\n-0.034326\n0.462360\n0.318055\n0.558904\n0.419020\n0.506942\n0.291405\n0.803551\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617188\n39798.644531\n13.814629\n6.393752\nNaN\n2.584653\n44249.355469\n47325.460938\n...\n0.140172\n-0.287693\n-0.051930\n0.479228\n0.651287\n0.541446\n0.616689\n0.533235\n0.425715\n1.778124\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203125\n40963.191406\n14.030331\n6.504374\nNaN\n2.616257\n43291.566406\n46404.160156\n...\n0.131920\n-0.251232\n-0.016258\n0.470640\n0.651027\n0.539631\n0.619789\n0.519718\n0.419446\n1.728804\n\n\n2017\nZimbabwe\nUS Dollar\n44672.175781\n44316.742188\n14.236595\n6.611773\nNaN\n2.648248\n46113.945312\n49457.570312\n...\n0.126722\n-0.202827\n-0.039897\n0.473560\n0.639560\n0.519956\n0.619739\n0.552042\n0.418681\n1.756007\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109375\n43420.898438\n14.438802\n6.714952\nNaN\n2.680630\n46198.441406\n49665.386719\n...\n0.144485\n-0.263658\n-0.020791\n0.543757\n0.655473\n0.529867\n0.641361\n0.561526\n0.426527\n1.830088\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n47128.785156\n...\n0.213562\n-0.270959\n-0.089798\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n5124 rows × 50 columns\n\n\n\n这里使用了df.loc结合slice函数的方法，注意：\n\nslice(None): 这表示选择 所有 countrycode。\nslice(1992, None): 这表示从 year 的 1992年 开始，选择到 所有后续年份。由于索引是排序的（通常情况下），这有效地选择了所有 year &gt; 1992 的数据。\n:表示选择所有列。\n\n上面的例子使用slice函数不是那么直观，也可以使用df.index.get_level_values('year')提取索引year的值，形成一个序列（可以另存为一个变量），然后利用表达式生成一个布尔序列，对数据框进行筛选：\n\npwt[pwt.index.get_level_values('year') &gt; 1992]\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1993\nAruba\nAruban Guilder\n3131.370850\n3698.532471\n0.072504\n0.032912\nNaN\nNaN\n1860.497559\n3167.873291\n...\n0.824972\n-0.601976\n-0.035119\n0.437298\n0.272653\n0.471235\n0.354660\n0.455204\n0.281028\n0.897604\n\n\n1994\nAruba\nAruban Guilder\n3537.953369\n4172.824219\n0.076700\n0.034896\nNaN\nNaN\n2015.998657\n3393.726807\n...\n0.764192\n-0.501460\n-0.040448\n0.447622\n0.297497\n0.427549\n0.377078\n0.508004\n0.310169\n0.939461\n\n\n1995\nAruba\nAruban Guilder\n3412.874512\n4184.156250\n0.080324\n0.036628\nNaN\nNaN\n2034.535400\n3435.050781\n...\n0.765721\n-0.542942\n-0.030582\n0.451724\n0.303802\n0.525235\n0.404533\n0.547051\n0.282667\n0.820760\n\n\n1996\nAruba\nAruban Guilder\n3428.601074\n3977.093018\n0.083200\n0.038026\nNaN\nNaN\n2167.170654\n3444.941162\n...\n0.840301\n-0.669186\n-0.034326\n0.462360\n0.318055\n0.558904\n0.419020\n0.506942\n0.291405\n0.803551\n\n\n1997\nAruba\nAruban Guilder\n3718.441406\n4282.010254\n0.085451\n0.039143\nNaN\nNaN\n2264.614014\n3740.265869\n...\n0.849453\n-0.723889\n-0.017507\n0.481048\n0.325158\n0.563639\n0.417158\n0.481417\n0.299164\n0.821012\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617188\n39798.644531\n13.814629\n6.393752\nNaN\n2.584653\n44249.355469\n47325.460938\n...\n0.140172\n-0.287693\n-0.051930\n0.479228\n0.651287\n0.541446\n0.616689\n0.533235\n0.425715\n1.778124\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203125\n40963.191406\n14.030331\n6.504374\nNaN\n2.616257\n43291.566406\n46404.160156\n...\n0.131920\n-0.251232\n-0.016258\n0.470640\n0.651027\n0.539631\n0.619789\n0.519718\n0.419446\n1.728804\n\n\n2017\nZimbabwe\nUS Dollar\n44672.175781\n44316.742188\n14.236595\n6.611773\nNaN\n2.648248\n46113.945312\n49457.570312\n...\n0.126722\n-0.202827\n-0.039897\n0.473560\n0.639560\n0.519956\n0.619739\n0.552042\n0.418681\n1.756007\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109375\n43420.898438\n14.438802\n6.714952\nNaN\n2.680630\n46198.441406\n49665.386719\n...\n0.144485\n-0.263658\n-0.020791\n0.543757\n0.655473\n0.529867\n0.641361\n0.561526\n0.426527\n1.830088\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n47128.785156\n...\n0.213562\n-0.270959\n-0.089798\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n4941 rows × 50 columns\n\n\n\n当然，可以同时选择指定的变量和年份，例如：\n\npwt.loc[(slice(None),[2016,2019]), ['rgdpe','rgdpo']]\n#\npwt.loc[(([\"CHN\", \"USA\"], [2016,2019])), ['rgdpe','rgdpo']]\n\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\n\n\ncountrycode\nyear\n\n\n\n\n\n\nCHN\n2016\n18611202.0\n18591710.0\n\n\n2019\n20056066.0\n20257660.0\n\n\nUSA\n2016\n19285252.0\n19095196.0\n\n\n2019\n20860506.0\n20595844.0\n\n\n\n\n\n\n\n除了通常的排序以外，由于有了二级索引，如果按索引排序，两级索引变量是同时排序的：\n\npwt.sort_index()\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1950\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1954\nAruba\nAruban Guilder\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\nZimbabwe\nUS Dollar\n40141.617188\n39798.644531\n13.814629\n6.393752\nNaN\n2.584653\n44249.355469\n47325.460938\n...\n0.140172\n-0.287693\n-0.051930\n0.479228\n0.651287\n0.541446\n0.616689\n0.533235\n0.425715\n1.778124\n\n\n2016\nZimbabwe\nUS Dollar\n41875.203125\n40963.191406\n14.030331\n6.504374\nNaN\n2.616257\n43291.566406\n46404.160156\n...\n0.131920\n-0.251232\n-0.016258\n0.470640\n0.651027\n0.539631\n0.619789\n0.519718\n0.419446\n1.728804\n\n\n2017\nZimbabwe\nUS Dollar\n44672.175781\n44316.742188\n14.236595\n6.611773\nNaN\n2.648248\n46113.945312\n49457.570312\n...\n0.126722\n-0.202827\n-0.039897\n0.473560\n0.639560\n0.519956\n0.619739\n0.552042\n0.418681\n1.756007\n\n\n2018\nZimbabwe\nUS Dollar\n44325.109375\n43420.898438\n14.438802\n6.714952\nNaN\n2.680630\n46198.441406\n49665.386719\n...\n0.144485\n-0.263658\n-0.020791\n0.543757\n0.655473\n0.529867\n0.641361\n0.561526\n0.426527\n1.830088\n\n\n2019\nZimbabwe\nUS Dollar\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n47128.785156\n...\n0.213562\n-0.270959\n-0.089798\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n12810 rows × 50 columns\n\n\n\n可以对两级索引以列表的形式分别设定排序的顺序。例如，先将国家代码按字母升序，然后将年降序：\n\npwt.sort_index(ascending=[True, False])\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n2019\nAruba\nAruban Guilder\n3921.261230\n3467.299561\n0.106314\n0.047601\nNaN\nNaN\n3023.694824\n3877.659668\n...\n0.973115\n-1.091808\n2.125691e-07\n0.883092\n0.815759\n0.744329\n0.707260\n0.622660\n0.805100\n0.648114\n\n\n2018\nAruba\nAruban Guilder\n3927.566650\n3444.658691\n0.105845\n0.047391\nNaN\nNaN\n3040.981201\n3903.104736\n...\n1.015919\n-1.141796\n6.378183e-07\n0.857056\n0.789754\n0.722777\n0.661298\n0.584303\n0.788550\n0.641680\n\n\n2017\nAruba\nAruban Guilder\n3979.910400\n3062.580566\n0.105366\n0.047176\nNaN\nNaN\n3044.065674\n3912.317871\n...\n1.117661\n-1.395119\n-1.487947e-16\n0.809308\n0.732397\n0.682043\n0.654755\n0.512391\n0.739654\n0.648690\n\n\n2016\nAruba\nAruban Guilder\n3953.522217\n3320.976807\n0.104872\n0.046955\nNaN\nNaN\n3025.953857\n3915.882080\n...\n1.028300\n-1.184166\n0.000000e+00\n0.798115\n0.713214\n0.667523\n0.606928\n0.523677\n0.658227\n0.583411\n\n\n2015\nAruba\nAruban Guilder\n3959.592529\n3921.183350\n0.104341\n0.046717\nNaN\nNaN\n3029.995605\n3972.749268\n...\n0.923424\n-0.925770\n1.913542e-06\n0.795370\n0.667704\n0.660781\n0.586393\n0.589976\n0.585710\n0.514230\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n1954\nZimbabwe\nUS Dollar\n6373.737305\n6277.433594\n3.172192\n1.481345\nNaN\n1.17999\n5446.246582\n6939.838867\n...\n0.000010\n-0.000005\n-1.181179e-01\n0.123506\n0.119157\n0.106431\n0.093195\n0.077997\n0.102318\nNaN\n\n\n1953\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1950\nZimbabwe\nUS Dollar\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n12810 rows × 50 columns\n\n\n\n\n\n2.9 stack 和 unstack\n数据有“长（long）”和“宽（wide）”两种组织方式，Penn World Table 是以“长”的形式保存的。有时候需要在两种数据格式之间进行转换，就需要用到df.stack()和df.unstack()函数。\n注意，df.unstack()函数的参数level=，设置为哪一级索引，便生成为列。默认在最后一级索引上转换，即年，因此列便为年，行为国家，反之，列为国家，行为年。如下面例子所示，为了简便只保留了三个国家5年的数据：\n\npwt_sub = pwt.loc[([\"CHN\", \"KOR\", \"USA\"], slice(2015, None)), [\"rgdpe\", \"pop\"]]\n# \npwt_sub_wide = pwt_sub.unstack(level=-1)\n# pwt_sub.unstack(level=0)\n\n要获得长格式的数据，使用df.stack()即可：\n\npwt_sub_wide.stack(future_stack=True)\n\n\n\n\n\n\n\n\n\nrgdpe\npop\n\n\ncountrycode\nyear\n\n\n\n\n\n\nCHN\n2015\n1.786628e+07\n1406.847870\n\n\n2016\n1.861120e+07\n1414.049351\n\n\n2017\n1.950114e+07\n1421.021791\n\n\n2018\n1.950871e+07\n1427.647786\n\n\n2019\n2.005607e+07\n1433.783686\n\n\nKOR\n2015\n1.928057e+06\n50.823093\n\n\n2016\n1.999700e+06\n50.983457\n\n\n2017\n2.070936e+06\n51.096415\n\n\n2018\n2.102052e+06\n51.171706\n\n\n2019\n2.090946e+06\n51.225308\n\n\nUSA\n2015\n1.890512e+07\n320.878310\n\n\n2016\n1.928525e+07\n323.015995\n\n\n2017\n1.975475e+07\n325.084756\n\n\n2018\n2.036944e+07\n327.096265\n\n\n2019\n2.086051e+07\n329.064917\n\n\n\n\n\n\n\n当我们从一些数据库下载数据时，常见形式为列为不同时期相同变量的值。例如，从世界银行下载人均GDP和人口数据：\n\nimport wbgapi as wb\ndf = wb.data.DataFrame(series=['NY.GDP.PCAP.CD', \"SP.POP.TOTL\"], \n                                #time=range(2017,2020),\n                                time=['YR2017','YR2018','YR2019'],\n                                 numericTimeKeys=True)\ndf.head()\n\n\n\n\n\n\n\n\n\n2017\n2018\n2019\n\n\neconomy\nseries\n\n\n\n\n\n\n\nABW\nNY.GDP.PCAP.CD\n2.844005e+04\n3.008213e+04\n3.109621e+04\n\n\nSP.POP.TOTL\n1.087350e+05\n1.089080e+05\n1.092030e+05\n\n\nAFE\nNY.GDP.PCAP.CD\n1.520212e+03\n1.538902e+03\n1.493818e+03\n\n\nSP.POP.TOTL\n6.400587e+08\n6.578011e+08\n6.759502e+08\n\n\nAFG\nNY.GDP.PCAP.CD\n5.254698e+02\n4.913372e+02\n4.966025e+02\n\n\n\n\n\n\n\n下载的数据df索引是“economy - series”，每一年数据一列。我们希望序列成为列变量，时间成为索引。我们可以先对数据进行转置成宽格式的数据，然后再在国家层面堆叠，使其成为索引，再交换索引排序得到通常的情况：\n\ndf.T.stack(level=0, future_stack=True).swaplevel().sort_index()\n\n\n\n\n\n\n\n\nseries\nNY.GDP.PCAP.CD\nSP.POP.TOTL\n\n\neconomy\n\n\n\n\n\n\n\nABW\n2017\n28440.051964\n108735.0\n\n\n2018\n30082.127645\n108908.0\n\n\n2019\n31096.205074\n109203.0\n\n\nAFE\n2017\n1520.212231\n640058741.0\n\n\n2018\n1538.901679\n657801085.0\n\n\n...\n...\n...\n...\n\n\nZMB\n2018\n1463.899979\n17973569.0\n\n\n2019\n1258.986198\n18513839.0\n\n\nZWE\n2017\n3448.086991\n14812482.0\n\n\n2018\n2271.852504\n15034452.0\n\n\n2019\n1683.913136\n15271368.0\n\n\n\n\n798 rows × 2 columns\n\n\n\n另外，stack不是唯一的方法，也可以使用df.melt()结合df.pivot_table()函数来实现：\n\ndf_reset = df.reset_index()\ndf_long = df_reset.melt(id_vars=['economy', 'series'], var_name='year', value_name='value')\ndf_long.pivot_table(index=['economy', 'year'], columns='series', values='value')\n\n\n\n\n\n\n\n\nseries\nNY.GDP.PCAP.CD\nSP.POP.TOTL\n\n\neconomy\nyear\n\n\n\n\n\n\nABW\n2017\n28440.051964\n108735.0\n\n\n2018\n30082.127645\n108908.0\n\n\n2019\n31096.205074\n109203.0\n\n\nAFE\n2017\n1520.212231\n640058741.0\n\n\n2018\n1538.901679\n657801085.0\n\n\n...\n...\n...\n...\n\n\nZMB\n2018\n1463.899979\n17973569.0\n\n\n2019\n1258.986198\n18513839.0\n\n\nZWE\n2017\n3448.086991\n14812482.0\n\n\n2018\n2271.852504\n15034452.0\n\n\n2019\n1683.913136\n15271368.0\n\n\n\n\n795 rows × 2 columns\n\n\n\n\n\n2.10 Pandas中的分组计算（groupby）\nPandas 的分组（groupby()）方法按照“分割-应用-组合（split-apply-combine）”的原理，创建一个 groupby 对象，可以应用各种方法来聚合、转换或过滤数据。更多介绍参见Pandas官方文档Group by: split-apply-combine。\n选择合适的方法：\n\n如果你的操作只是简单的统计（如求和、平均值），优先使用聚合方法，它们通常效率最高。\n如果需要返回与原始 DataFrame 相同长度的结果，例如进行组内标准化，使用转换方法。\n如果需要根据组的属性来决定保留或丢弃整个组，使用过滤方法。\n当以上方法都无法满足需求时，或者需要执行更复杂的自定义逻辑时，使用apply()方法。\n\n\n2.10.1 聚合方法（Aggregation Methods）\n聚合方法将每个组的数据压缩成一个单一的值，是最常用的groupby操作，例如mean(),sum(),count(),size(),min(),max(),std(),var(),median()等常见的统计量，或者first(),last(),nth(n)等获取第一个、最好一个或第n个值：\n索引\n例如，根据索引计算世界人口，先在索引上分组，然后使用.sum()函数：\n\npwt.groupby(level=1)['pop'].sum()\n\nyear\n1950    1297.363356\n1951    1345.648916\n1952    1948.874249\n1953    2005.091897\n1954    2048.591355\n           ...     \n2015    7254.659556\n2016    7336.956076\n2017    7418.960776\n2018    7500.383052\n2019    7580.896719\nName: pop, Length: 70, dtype: float64\n\n\navh变量度量了“Average annual hours worked by persons engaged”,让我们分组计算平均，得到按年和按国家平均\n\navh = pwt[pwt['avh'].notna()]\nfig, ax = plt.subplots(2, 1, figsize=(12, 12))\navh.groupby(level=1)['avh'].mean().sort_values(ascending=False).plot(kind='line', ax=ax[0])\nax[0].set_xlabel(\"\")\nax[0].set_ylabel(\"Average annual hours worked by persons engaged\")\navh.groupby(level=0)['avh'].mean().sort_values(ascending=False)[:25].plot(kind='bar', ax=ax[1])\nax[1].set_xlabel(\"\")\nax[1].set_ylabel(\"Average annual hours worked by persons engaged\")\nplt.show()\n\n\n\n\n\n\n\n\n最常见的是按变量进行分组，例如，按国家名country分组，最后一个观测值：\n\npwt.groupby(by=['country']).last()\n\n\n\n\n\n\n\n\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlbania\nLek\n35890.019531\n36103.042969\n2.880917\n1.075898\nNaN\n2.964992\n33399.167969\n40868.316406\n35808.343750\n...\n0.126594\n-0.313949\n0.061145\n0.473077\n0.456882\n0.235589\n0.629832\n0.525463\n0.300975\nNaN\n\n\nAlgeria\nAlgerian Dinar\n488952.375000\n507487.562500\n43.053054\n11.273454\nNaN\n2.383965\n365349.093750\n518958.812500\n487570.812500\n...\n0.136288\n-0.135642\n-0.030636\n0.331240\n0.512451\n0.206330\n0.519368\n0.606340\n0.327416\nNaN\n\n\nAngola\nKwanza\n228151.015625\n227855.718750\n31.825295\n16.644962\nNaN\n1.481984\n155943.718750\n198750.421875\n227771.609375\n...\n0.344351\n-0.113983\n-0.120470\n0.438169\n0.342872\n0.240024\n0.476486\n0.611627\n0.211084\n0.396034\n\n\nAnguilla\nEast Caribbean Dollar\n376.634979\n225.680527\n0.014869\n0.005348\nNaN\nNaN\n438.470032\n509.044983\n375.136444\n...\n1.480300\n-2.445801\n-0.143354\n1.064513\n1.029199\n0.732212\n0.768944\n0.602734\n0.897989\nNaN\n\n\nAntigua and Barbuda\nEast Caribbean Dollar\n1986.163208\n1603.854492\n0.097118\n0.038500\nNaN\nNaN\n1787.816772\n2415.362061\n1979.578003\n...\n0.029888\n-0.609532\n0.099326\n0.899944\n0.951402\n0.519169\n0.766929\n0.571459\n0.668208\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVenezuela (Bolivarian Republic of)\nBolivar Fuerte\n7166.571777\n7160.106934\n28.515829\n11.694400\n1903.851607\n2.893462\n9266.067383\n10055.498047\n7167.786133\n...\n0.000002\n-0.001072\n-0.402837\n18.143538\n34.444988\n14.175777\n0.581305\n0.645909\n20.694918\n12.002436\n\n\nViet Nam\nDong\n750726.750000\n724123.375000\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.062500\n758821.937500\n747853.750000\n...\n0.526032\n-0.518066\n-0.057305\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\nNaN\n\n\nYemen\nYemeni Rial\n50052.933594\n51828.058594\n29.161922\n5.531877\nNaN\n1.842989\n49266.472656\n67992.531250\n49937.042969\n...\n0.000723\n-0.135297\n-0.173392\n0.777612\n0.238807\n0.211786\n0.632594\n0.670528\n0.174729\nNaN\n\n\nZambia\nKwacha\n57956.183594\n56783.714844\n17.861030\n5.225448\nNaN\n2.686845\n38698.402344\n56536.863281\n57695.066406\n...\n0.215397\n-0.238961\n0.028391\n0.373077\n0.482041\n0.330470\n0.574416\n0.531915\n0.295188\n0.360382\n\n\nZimbabwe\nUS Dollar\n42296.062500\n40826.570312\n14.645468\n6.831017\nNaN\n2.713408\n43961.839844\n47128.785156\n42325.117188\n...\n0.213562\n-0.270959\n-0.089798\n0.494755\n0.652439\n0.500927\n0.487763\n0.430082\n0.419883\n1.580885\n\n\n\n\n183 rows × 49 columns\n\n\n\n\n\n2.10.2 转换方法（Transformation Methods）\n\ntransform(func): 对每个组应用函数，并将结果广播回原始 DataFrame 的形状。\nrank(method='average'): 计算组内排名。\nfillna(value): 在组内填充缺失值。\n\n\navh.groupby(level=1)['avh'].transform('mean')\navh.groupby(level=1)['avh'].mean()\n\nyear\n1950    2171.439158\n1951    2190.832106\n1952    2181.242069\n1953    2183.205302\n1954    2179.603764\n           ...     \n2015    1865.220762\n2016    1871.137771\n2017    1858.542897\n2018    1854.065910\n2019    1849.981084\nName: avh, Length: 70, dtype: float64\n\n\n注意，转换与聚合的区别,转换将生成的值与原数据观测值一样多，这里是3492个，而聚合只有70个。\n.transform()方法可以与lambda函数相结合，例如：\n\npwt.select_dtypes(np.number).groupby(level=0).transform(lambda x: (x - x.mean())/x.std())\n\n\n\n\n\n\n\n\n\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\ncgdpe\ncgdpo\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABW\n1950\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1954\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nZWE\n2015\n0.557612\n0.538962\n1.363168\n1.481502\nNaN\n1.684506\n1.065064\n0.878946\n0.568115\n0.518456\n...\n0.573238\n-1.555246\n-0.255119\n0.529681\n1.749130\n2.268319\n1.207733\n0.980568\n1.694797\n-0.574098\n\n\n2016\n0.653705\n0.602805\n1.422588\n1.547890\nNaN\n1.752335\n1.007497\n0.829250\n0.663904\n0.595112\n...\n0.494790\n-1.255079\n0.076671\n0.502201\n1.747821\n2.254739\n1.223349\n0.905110\n1.640276\n-0.603384\n\n\n2017\n0.808743\n0.786654\n1.479408\n1.612345\nNaN\n1.820993\n1.177133\n0.993953\n0.830524\n0.783048\n...\n0.445374\n-0.856577\n-0.143192\n0.511544\n1.690031\n2.107590\n1.223093\n1.085555\n1.633616\n-0.587231\n\n\n2018\n0.789505\n0.737542\n1.535110\n1.674266\nNaN\n1.890490\n1.182212\n1.005163\n0.812158\n0.742264\n...\n0.614240\n-1.357370\n0.034511\n0.736143\n1.770227\n2.181716\n1.331997\n1.138501\n1.701857\n-0.543242\n\n\n2019\n0.677034\n0.595315\n1.592041\n1.743921\nNaN\n1.960838\n1.047783\n0.868337\n0.699789\n0.606955\n...\n1.270920\n-1.417482\n-0.607332\n0.579359\n1.754938\n1.965274\n0.558390\n0.404721\n1.644073\n-0.691219\n\n\n\n\n12810 rows × 43 columns\n\n\n\n\n\n2.10.3 过滤方法（Filtration Methods）\n过滤方法会根据每个组的某个条件来排除整个组。\n\nfilter(func): 根据一个返回布尔值的函数来过滤组。如果函数对一个组返回 True，则保留该组；否则，删除该组。\n\n\npwt.groupby(level=0).filter(lambda x: x['pop'].mean() &gt; 50)\n\n\n\n\n\n\n\n\n\ncountry\ncurrency_unit\nrgdpe\nrgdpo\npop\nemp\navh\nhc\nccon\ncda\n...\ncsh_x\ncsh_m\ncsh_r\npl_c\npl_i\npl_g\npl_x\npl_m\npl_n\npl_k\n\n\ncountrycode\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBGD\n1950\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1951\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1952\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1953\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1954\nBangladesh\nTaka\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nVNM\n2015\nViet Nam\nDong\n561821.1875\n572777.5000\n92.677076\n52.840004\n2191.370436\n2.669350\n443934.56250\n574238.5625\n...\n0.442469\n-0.439203\n-0.000265\n0.336687\n0.410447\n0.227190\n0.635741\n0.655327\n0.257087\nNaN\n\n\n2016\nViet Nam\nDong\n601767.5625\n596363.1250\n93.640422\n53.302799\n2169.551504\n2.716025\n473113.40625\n610603.4375\n...\n0.462526\n-0.451460\n-0.024112\n0.337684\n0.396817\n0.236729\n0.633399\n0.643034\n0.244760\nNaN\n\n\n2017\nViet Nam\nDong\n653410.8125\n647224.9375\n94.600648\n53.703396\n2131.968232\n2.764934\n507151.37500\n660755.8750\n...\n0.516055\n-0.517211\n-0.019750\n0.340993\n0.387264\n0.240045\n0.644062\n0.636934\n0.242858\nNaN\n\n\n2018\nViet Nam\nDong\n705553.3750\n689643.4375\n95.545962\n54.069103\n2131.968232\n2.816210\n543525.25000\n708143.1875\n...\n0.522278\n-0.519110\n-0.033603\n0.346216\n0.395235\n0.244325\n0.678972\n0.663970\n0.245893\nNaN\n\n\n2019\nViet Nam\nDong\n750726.7500\n724123.3750\n96.462106\n50.399563\n2131.968232\n2.869998\n582677.06250\n758821.9375\n...\n0.526032\n-0.518066\n-0.057305\n0.347591\n0.399158\n0.245056\n0.695617\n0.676502\n0.249708\nNaN\n\n\n\n\n1260 rows × 50 columns\n\n\n\n\n\n2.10.4 应用方法（Application Methods）\napply() 方法是最通用的方法，它允许你对每个组应用任何自定义函数。这个函数可以执行聚合、转换或过滤操作，或者任何更复杂的逻辑。\n\napply(func): 将一个自定义函数应用于每个组。函数的返回值可以是 Series、DataFrame 或标量。"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "参考文献\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "参考文献"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "1 后记",
    "section": "",
    "text": "1 后记\nIn summary, this book has no content whatsoever.\n\n\n\n\n Back to top",
    "crumbs": [
      "总结"
    ]
  }
]